"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tabster";
exports.ids = ["vendor-chunks/tabster"];
exports.modules = {

/***/ "(ssr)/./node_modules/tabster/dist/tabster.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/tabster/dist/tabster.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncFocusSources: () => (/* binding */ AsyncFocusSources),\n/* harmony export */   DeloserFocusLostEvent: () => (/* binding */ DeloserFocusLostEvent),\n/* harmony export */   DeloserFocusLostEventName: () => (/* binding */ DeloserFocusLostEventName),\n/* harmony export */   DeloserRestoreFocusEvent: () => (/* binding */ DeloserRestoreFocusEvent),\n/* harmony export */   DeloserRestoreFocusEventName: () => (/* binding */ DeloserRestoreFocusEventName),\n/* harmony export */   DeloserStrategies: () => (/* binding */ DeloserStrategies),\n/* harmony export */   EventsTypes: () => (/* binding */ EventsTypes),\n/* harmony export */   FOCUSABLE_SELECTOR: () => (/* binding */ FOCUSABLE_SELECTOR),\n/* harmony export */   GroupperMoveFocusActions: () => (/* binding */ GroupperMoveFocusActions),\n/* harmony export */   GroupperMoveFocusEvent: () => (/* binding */ GroupperMoveFocusEvent),\n/* harmony export */   GroupperMoveFocusEventName: () => (/* binding */ GroupperMoveFocusEventName),\n/* harmony export */   GroupperTabbabilities: () => (/* binding */ GroupperTabbabilities),\n/* harmony export */   ModalizerActiveEvent: () => (/* binding */ ModalizerActiveEvent),\n/* harmony export */   ModalizerActiveEventName: () => (/* binding */ ModalizerActiveEventName),\n/* harmony export */   ModalizerFocusInEventName: () => (/* binding */ ModalizerFocusInEventName),\n/* harmony export */   ModalizerFocusOutEventName: () => (/* binding */ ModalizerFocusOutEventName),\n/* harmony export */   ModalizerInactiveEvent: () => (/* binding */ ModalizerInactiveEvent),\n/* harmony export */   ModalizerInactiveEventName: () => (/* binding */ ModalizerInactiveEventName),\n/* harmony export */   MoverDirections: () => (/* binding */ MoverDirections),\n/* harmony export */   MoverKeys: () => (/* binding */ MoverKeys),\n/* harmony export */   MoverMemorizedElementEvent: () => (/* binding */ MoverMemorizedElementEvent),\n/* harmony export */   MoverMemorizedElementEventName: () => (/* binding */ MoverMemorizedElementEventName),\n/* harmony export */   MoverMoveFocusEvent: () => (/* binding */ MoverMoveFocusEvent),\n/* harmony export */   MoverMoveFocusEventName: () => (/* binding */ MoverMoveFocusEventName),\n/* harmony export */   MoverStateEvent: () => (/* binding */ MoverStateEvent),\n/* harmony export */   MoverStateEventName: () => (/* binding */ MoverStateEventName),\n/* harmony export */   ObservedElementAccessibilities: () => (/* binding */ ObservedElementAccessibilities),\n/* harmony export */   ObservedElementFailureReasons: () => (/* binding */ ObservedElementFailureReasons),\n/* harmony export */   ObservedElementRequestStatuses: () => (/* binding */ ObservedElementRequestStatuses),\n/* harmony export */   RestoreFocusOrders: () => (/* binding */ RestoreFocusOrders),\n/* harmony export */   RestorerRestoreFocusEvent: () => (/* binding */ RestorerRestoreFocusEvent),\n/* harmony export */   RestorerRestoreFocusEventName: () => (/* binding */ RestorerRestoreFocusEventName),\n/* harmony export */   RestorerTypes: () => (/* binding */ RestorerTypes),\n/* harmony export */   RootBlurEvent: () => (/* binding */ RootBlurEvent),\n/* harmony export */   RootBlurEventName: () => (/* binding */ RootBlurEventName),\n/* harmony export */   RootFocusEvent: () => (/* binding */ RootFocusEvent),\n/* harmony export */   RootFocusEventName: () => (/* binding */ RootFocusEventName),\n/* harmony export */   SysDummyInputsPositions: () => (/* binding */ SysDummyInputsPositions),\n/* harmony export */   TABSTER_ATTRIBUTE_NAME: () => (/* binding */ TABSTER_ATTRIBUTE_NAME),\n/* harmony export */   TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME: () => (/* binding */ TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME),\n/* harmony export */   TabsterCustomEvent: () => (/* binding */ TabsterCustomEvent),\n/* harmony export */   TabsterFocusInEvent: () => (/* binding */ TabsterFocusInEvent),\n/* harmony export */   TabsterFocusInEventName: () => (/* binding */ TabsterFocusInEventName),\n/* harmony export */   TabsterFocusOutEvent: () => (/* binding */ TabsterFocusOutEvent),\n/* harmony export */   TabsterFocusOutEventName: () => (/* binding */ TabsterFocusOutEventName),\n/* harmony export */   TabsterMoveFocusEvent: () => (/* binding */ TabsterMoveFocusEvent),\n/* harmony export */   TabsterMoveFocusEventName: () => (/* binding */ TabsterMoveFocusEventName),\n/* harmony export */   Types: () => (/* binding */ Types),\n/* harmony export */   Visibilities: () => (/* binding */ Visibilities),\n/* harmony export */   createTabster: () => (/* binding */ createTabster),\n/* harmony export */   dispatchGroupperMoveFocusEvent: () => (/* binding */ dispatchGroupperMoveFocusEvent),\n/* harmony export */   dispatchMoverMemorizedElementEvent: () => (/* binding */ dispatchMoverMemorizedElementEvent),\n/* harmony export */   dispatchMoverMoveFocusEvent: () => (/* binding */ dispatchMoverMoveFocusEvent),\n/* harmony export */   disposeTabster: () => (/* binding */ disposeTabster),\n/* harmony export */   forceCleanup: () => (/* binding */ forceCleanup),\n/* harmony export */   getCrossOrigin: () => (/* binding */ getCrossOrigin),\n/* harmony export */   getDeloser: () => (/* binding */ getDeloser),\n/* harmony export */   getDummyInputContainer: () => (/* binding */ getDummyInputContainer),\n/* harmony export */   getGroupper: () => (/* binding */ getGroupper),\n/* harmony export */   getInternal: () => (/* binding */ getInternal),\n/* harmony export */   getModalizer: () => (/* binding */ getModalizer),\n/* harmony export */   getMover: () => (/* binding */ getMover),\n/* harmony export */   getObservedElement: () => (/* binding */ getObservedElement),\n/* harmony export */   getOutline: () => (/* binding */ getOutline),\n/* harmony export */   getRestorer: () => (/* binding */ getRestorer),\n/* harmony export */   getShadowDOMAPI: () => (/* binding */ getShadowDOMAPI),\n/* harmony export */   getTabster: () => (/* binding */ getTabster),\n/* harmony export */   getTabsterAttribute: () => (/* binding */ getTabsterAttribute),\n/* harmony export */   isNoOp: () => (/* binding */ isNoOp),\n/* harmony export */   makeNoOp: () => (/* binding */ makeNoOp),\n/* harmony export */   mergeTabsterProps: () => (/* binding */ mergeTabsterProps),\n/* harmony export */   setTabsterAttribute: () => (/* binding */ setTabsterAttribute)\n/* harmony export */ });\n/* harmony import */ var keyborg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! keyborg */ \"(ssr)/./node_modules/keyborg/dist/esm/index.js\");\n\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst TABSTER_ATTRIBUTE_NAME = \"data-tabster\";\nconst TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME = \"data-tabster-dummy\";\nconst FOCUSABLE_SELECTOR = `:is(${/*#__PURE__*/[\"a[href]\", \"button\", \"input\", \"select\", \"textarea\", \"*[tabindex]\", \"*[contenteditable]\", \"details > summary\", \"audio[controls]\", \"video[controls]\"].join(\", \")}):not(:disabled)`;\nconst AsyncFocusSources = {\n  EscapeGroupper: 1,\n  Restorer: 2,\n  Deloser: 3\n};\nconst ObservedElementAccessibilities = {\n  Any: 0,\n  Accessible: 1,\n  Focusable: 2\n};\nconst ObservedElementRequestStatuses = {\n  Waiting: 0,\n  Succeeded: 1,\n  Canceled: 2,\n  TimedOut: 3\n};\nconst ObservedElementFailureReasons = {\n  CanceledFocusChange: 1,\n  TimeoutElementNotInDOM: 2,\n  TimeoutElementNotAccessible: 3,\n  TimeoutElementNotFocusable: 4,\n  TimeoutElementNotReady: 5,\n  SupersededByNewRequest: 6,\n  FocusCallFailed: 7\n};\nconst RestoreFocusOrders = {\n  History: 0,\n  DeloserDefault: 1,\n  RootDefault: 2,\n  DeloserFirst: 3,\n  RootFirst: 4\n};\nconst DeloserStrategies = {\n  /**\n   * If the focus is lost, the focus will be restored automatically using all available focus history.\n   * This is the default strategy.\n   */\n  Auto: 0,\n  /**\n   * If the focus is lost from this Deloser instance, the focus will not be restored automatically.\n   * The application might listen to the event and restore the focus manually.\n   * But if it is lost from another Deloser instance, the history of this Deloser could be used finding\n   * the element to focus.\n   */\n  Manual: 1\n};\nconst Visibilities = {\n  Invisible: 0,\n  PartiallyVisible: 1,\n  Visible: 2\n};\nconst RestorerTypes = {\n  Source: 0,\n  Target: 1\n};\nconst MoverDirections = {\n  Both: 0,\n  // Default, both left/up keys move to the previous, right/down move to the next.\n  Vertical: 1,\n  // Only up/down arrows move to the next/previous.\n  Horizontal: 2,\n  // Only left/right arrows move to the next/previous.\n  Grid: 3,\n  // Two-dimentional movement depending on the visual placement.\n  GridLinear: 4 // Two-dimentional movement depending on the visual placement. Allows linear movement.\n};\nconst MoverKeys = {\n  ArrowUp: 1,\n  ArrowDown: 2,\n  ArrowLeft: 3,\n  ArrowRight: 4,\n  PageUp: 5,\n  PageDown: 6,\n  Home: 7,\n  End: 8\n};\nconst GroupperTabbabilities = {\n  Unlimited: 0,\n  Limited: 1,\n  // The tabbability is limited to the container and explicit Enter is needed to go inside.\n  LimitedTrapFocus: 2 // The focus is limited as above, plus trapped when inside.\n};\nconst GroupperMoveFocusActions = {\n  Enter: 1,\n  Escape: 2\n};\nconst SysDummyInputsPositions = {\n  Auto: 0,\n  // Tabster will place dummy inputs depending on the container tag name and on the default behaviour.\n  Inside: 1,\n  // Tabster will always place dummy inputs inside the container.\n  Outside: 2 // Tabster will always place dummy inputs outside of the container.\n};\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction getTabsterOnElement(tabster, element) {\n  var _a;\n  return (_a = tabster.storageEntry(element)) === null || _a === void 0 ? void 0 : _a.tabster;\n}\nfunction updateTabsterByAttribute(tabster, element, dispose) {\n  var _a, _b, _c;\n  const newAttrValue = dispose || tabster._noop ? undefined : element.getAttribute(TABSTER_ATTRIBUTE_NAME);\n  let entry = tabster.storageEntry(element);\n  let newAttr;\n  if (newAttrValue) {\n    if (newAttrValue !== ((_a = entry === null || entry === void 0 ? void 0 : entry.attr) === null || _a === void 0 ? void 0 : _a.string)) {\n      try {\n        const newValue = JSON.parse(newAttrValue);\n        if (typeof newValue !== \"object\") {\n          throw new Error(`Value is not a JSON object, got '${newAttrValue}'.`);\n        }\n        newAttr = {\n          string: newAttrValue,\n          object: newValue\n        };\n      } catch (e) {\n        if (true) {\n          console.error(`data-tabster attribute error: ${e}`, element);\n        }\n      }\n    } else {\n      return;\n    }\n  } else if (!entry) {\n    return;\n  }\n  if (!entry) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    entry = tabster.storageEntry(element, true);\n  }\n  if (!entry.tabster) {\n    entry.tabster = {};\n  }\n  const tabsterOnElement = entry.tabster || {};\n  const oldTabsterProps = ((_b = entry.attr) === null || _b === void 0 ? void 0 : _b.object) || {};\n  const newTabsterProps = (newAttr === null || newAttr === void 0 ? void 0 : newAttr.object) || {};\n  for (const key of Object.keys(oldTabsterProps)) {\n    if (!newTabsterProps[key]) {\n      if (key === \"root\") {\n        const root = tabsterOnElement[key];\n        if (root) {\n          tabster.root.onRoot(root, true);\n        }\n      }\n      switch (key) {\n        case \"deloser\":\n        case \"root\":\n        case \"groupper\":\n        case \"modalizer\":\n        case \"restorer\":\n        case \"mover\":\n          // eslint-disable-next-line no-case-declarations\n          const part = tabsterOnElement[key];\n          if (part) {\n            part.dispose();\n            delete tabsterOnElement[key];\n          }\n          break;\n        case \"observed\":\n          delete tabsterOnElement[key];\n          if (tabster.observedElement) {\n            tabster.observedElement.onObservedElementUpdate(element);\n          }\n          break;\n        case \"focusable\":\n        case \"outline\":\n        case \"uncontrolled\":\n        case \"sys\":\n          delete tabsterOnElement[key];\n          break;\n      }\n    }\n  }\n  for (const key of Object.keys(newTabsterProps)) {\n    const sys = newTabsterProps.sys;\n    switch (key) {\n      case \"deloser\":\n        if (tabsterOnElement.deloser) {\n          tabsterOnElement.deloser.setProps(newTabsterProps.deloser);\n        } else {\n          if (tabster.deloser) {\n            tabsterOnElement.deloser = tabster.deloser.createDeloser(element, newTabsterProps.deloser);\n          } else if (true) {\n            console.error(\"Deloser API used before initialization, please call `getDeloser()`\");\n          }\n        }\n        break;\n      case \"root\":\n        if (tabsterOnElement.root) {\n          tabsterOnElement.root.setProps(newTabsterProps.root);\n        } else {\n          tabsterOnElement.root = tabster.root.createRoot(element, newTabsterProps.root, sys);\n        }\n        tabster.root.onRoot(tabsterOnElement.root);\n        break;\n      case \"modalizer\":\n        {\n          let newModalizerProps;\n          const modalizerAPI = tabster.modalizer;\n          if (tabsterOnElement.modalizer) {\n            const props = newTabsterProps.modalizer;\n            const newModalizerId = props.id;\n            if (newModalizerId && ((_c = oldTabsterProps === null || oldTabsterProps === void 0 ? void 0 : oldTabsterProps.modalizer) === null || _c === void 0 ? void 0 : _c.id) !== newModalizerId) {\n              // Modalizer id is changed, given the modalizers have complex logic and could be\n              // composite, it is easier to recreate the Modalizer instance than to implement\n              // the id update.\n              tabsterOnElement.modalizer.dispose();\n              newModalizerProps = props;\n            } else {\n              tabsterOnElement.modalizer.setProps(props);\n            }\n          } else {\n            if (modalizerAPI) {\n              newModalizerProps = newTabsterProps.modalizer;\n            } else if (true) {\n              console.error(\"Modalizer API used before initialization, please call `getModalizer()`\");\n            }\n          }\n          if (modalizerAPI && newModalizerProps) {\n            tabsterOnElement.modalizer = modalizerAPI.createModalizer(element, newModalizerProps, sys);\n          }\n        }\n        break;\n      case \"restorer\":\n        if (tabsterOnElement.restorer) {\n          tabsterOnElement.restorer.setProps(newTabsterProps.restorer);\n        } else {\n          if (tabster.restorer) {\n            if (newTabsterProps.restorer) {\n              tabsterOnElement.restorer = tabster.restorer.createRestorer(element, newTabsterProps.restorer);\n            }\n          } else if (true) {\n            console.error(\"Restorer API used before initialization, please call `getRestorer()`\");\n          }\n        }\n        break;\n      case \"focusable\":\n        tabsterOnElement.focusable = newTabsterProps.focusable;\n        break;\n      case \"groupper\":\n        if (tabsterOnElement.groupper) {\n          tabsterOnElement.groupper.setProps(newTabsterProps.groupper);\n        } else {\n          if (tabster.groupper) {\n            tabsterOnElement.groupper = tabster.groupper.createGroupper(element, newTabsterProps.groupper, sys);\n          } else if (true) {\n            console.error(\"Groupper API used before initialization, please call `getGroupper()`\");\n          }\n        }\n        break;\n      case \"mover\":\n        if (tabsterOnElement.mover) {\n          tabsterOnElement.mover.setProps(newTabsterProps.mover);\n        } else {\n          if (tabster.mover) {\n            tabsterOnElement.mover = tabster.mover.createMover(element, newTabsterProps.mover, sys);\n          } else if (true) {\n            console.error(\"Mover API used before initialization, please call `getMover()`\");\n          }\n        }\n        break;\n      case \"observed\":\n        if (tabster.observedElement) {\n          tabsterOnElement.observed = newTabsterProps.observed;\n          tabster.observedElement.onObservedElementUpdate(element);\n        } else if (true) {\n          console.error(\"ObservedElement API used before initialization, please call `getObservedElement()`\");\n        }\n        break;\n      case \"uncontrolled\":\n        tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;\n        break;\n      case \"outline\":\n        if (tabster.outline) {\n          tabsterOnElement.outline = newTabsterProps.outline;\n        } else if (true) {\n          console.error(\"Outline API used before initialization, please call `getOutline()`\");\n        }\n        break;\n      case \"sys\":\n        tabsterOnElement.sys = newTabsterProps.sys;\n        break;\n      default:\n        console.error(`Unknown key '${key}' in data-tabster attribute value.`);\n    }\n  }\n  if (newAttr) {\n    entry.attr = newAttr;\n  } else {\n    if (Object.keys(tabsterOnElement).length === 0) {\n      delete entry.tabster;\n      delete entry.attr;\n    }\n    tabster.storageEntry(element, false);\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Events sent by Tabster.\n */\nconst TabsterFocusInEventName = \"tabster:focusin\";\nconst TabsterFocusOutEventName = \"tabster:focusout\";\n// Event is dispatched when Tabster wants to move focus as the result of\n// handling keyboard event. This allows to preventDefault() if you want to have\n// some custom logic.\nconst TabsterMoveFocusEventName = \"tabster:movefocus\";\n/**\n * Events sent by Deloser.\n */\nconst DeloserFocusLostEventName = \"tabster:deloser:focus-lost\";\n/**\n * Events to be sent to Deloser by the application.\n */\nconst DeloserRestoreFocusEventName = \"tabster:deloser:restore-focus\";\n/**\n * Events sent by Modalizer.\n */\nconst ModalizerActiveEventName = \"tabster:modalizer:active\";\nconst ModalizerInactiveEventName = \"tabster:modalizer:inactive\";\nconst ModalizerFocusInEventName = \"tabster:modalizer:focusin\";\nconst ModalizerFocusOutEventName = \"tabster:modalizer:focusout\";\n/**\n * Events sent by Mover.\n */\nconst MoverStateEventName = \"tabster:mover:state\";\n/**\n * Events to be sent to Mover by the application.\n */\n// Event that can be dispatched by the application to programmatically move\n// focus inside Mover.\nconst MoverMoveFocusEventName = \"tabster:mover:movefocus\";\n// Event that can be dispatched by the application to forget or modify\n// memorized element in Mover with memorizeCurrent property.\nconst MoverMemorizedElementEventName = \"tabster:mover:memorized-element\";\n/**\n * Events sent by Groupper.\n */\n/**\n * Events to be sent to Groupper by the application.\n */\n// Event that can be dispatched by the application to programmatically enter\n// or escape Groupper.\nconst GroupperMoveFocusEventName = \"tabster:groupper:movefocus\";\n/**\n * Events sent by Restorer.\n */\nconst RestorerRestoreFocusEventName = \"tabster:restorer:restore-focus\";\n/**\n * Events sent by Root.\n */\nconst RootFocusEventName = \"tabster:root:focus\";\nconst RootBlurEventName = \"tabster:root:blur\";\n// Node.js environments do not have CustomEvent and it is needed for the events to be\n// evaluated. It doesn't matter if it works or not in Node.js environment.\n// So, we just need to make sure that it doesn't throw undefined reference.\nconst CustomEvent_ = typeof CustomEvent !== \"undefined\" ? CustomEvent : function () {\n  /* no-op */\n};\nclass TabsterCustomEvent extends CustomEvent_ {\n  constructor(type, detail) {\n    super(type, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail\n    });\n    this.details = detail;\n  }\n}\nclass TabsterFocusInEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(TabsterFocusInEventName, detail);\n  }\n}\nclass TabsterFocusOutEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(TabsterFocusOutEventName, detail);\n  }\n}\nclass TabsterMoveFocusEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(TabsterMoveFocusEventName, detail);\n  }\n}\nclass MoverStateEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(MoverStateEventName, detail);\n  }\n}\nclass MoverMoveFocusEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(MoverMoveFocusEventName, detail);\n  }\n}\nclass MoverMemorizedElementEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(MoverMemorizedElementEventName, detail);\n  }\n}\nclass GroupperMoveFocusEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(GroupperMoveFocusEventName, detail);\n  }\n}\nclass ModalizerActiveEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(ModalizerActiveEventName, detail);\n  }\n}\nclass ModalizerInactiveEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(ModalizerInactiveEventName, detail);\n  }\n}\nclass DeloserFocusLostEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(DeloserFocusLostEventName, detail);\n  }\n}\nclass DeloserRestoreFocusEvent extends TabsterCustomEvent {\n  constructor() {\n    super(DeloserRestoreFocusEventName);\n  }\n}\nclass RestorerRestoreFocusEvent extends TabsterCustomEvent {\n  constructor() {\n    super(RestorerRestoreFocusEventName);\n  }\n}\nclass RootFocusEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(RootFocusEventName, detail);\n  }\n}\nclass RootBlurEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(RootBlurEventName, detail);\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst _createMutationObserver = callback => new MutationObserver(callback);\nconst _createTreeWalker = (doc, root, whatToShow, filter) => doc.createTreeWalker(root, whatToShow, filter);\nconst _getParentNode = node => node ? node.parentNode : null;\nconst _getParentElement = element => element ? element.parentElement : null;\nconst _nodeContains = (parent, child) => !!(child && (parent === null || parent === void 0 ? void 0 : parent.contains(child)));\nconst _getActiveElement = doc => doc.activeElement;\nconst _querySelector = (element, selector) => element.querySelector(selector);\nconst _querySelectorAll = (element, selector) => Array.prototype.slice.call(element.querySelectorAll(selector), 0);\nconst _getElementById = (doc, id) => doc.getElementById(id);\nconst _getFirstChild = node => (node === null || node === void 0 ? void 0 : node.firstChild) || null;\nconst _getLastChild = node => (node === null || node === void 0 ? void 0 : node.lastChild) || null;\nconst _getNextSibling = node => (node === null || node === void 0 ? void 0 : node.nextSibling) || null;\nconst _getPreviousSibling = node => (node === null || node === void 0 ? void 0 : node.previousSibling) || null;\nconst _getFirstElementChild = element => (element === null || element === void 0 ? void 0 : element.firstElementChild) || null;\nconst _getLastElementChild = element => (element === null || element === void 0 ? void 0 : element.lastElementChild) || null;\nconst _getNextElementSibling = element => (element === null || element === void 0 ? void 0 : element.nextElementSibling) || null;\nconst _getPreviousElementSibling = element => (element === null || element === void 0 ? void 0 : element.previousElementSibling) || null;\nconst _appendChild = (parent, child) => parent.appendChild(child);\nconst _insertBefore = (parent, child, referenceChild) => parent.insertBefore(child, referenceChild);\nconst _getSelection = ref => {\n  var _a;\n  return ((_a = ref.ownerDocument) === null || _a === void 0 ? void 0 : _a.getSelection()) || null;\n};\nconst _getElementsByName = (referenceElement, name) => referenceElement.ownerDocument.getElementsByName(name);\nconst dom = {\n  createMutationObserver: _createMutationObserver,\n  createTreeWalker: _createTreeWalker,\n  getParentNode: _getParentNode,\n  getParentElement: _getParentElement,\n  nodeContains: _nodeContains,\n  getActiveElement: _getActiveElement,\n  querySelector: _querySelector,\n  querySelectorAll: _querySelectorAll,\n  getElementById: _getElementById,\n  getFirstChild: _getFirstChild,\n  getLastChild: _getLastChild,\n  getNextSibling: _getNextSibling,\n  getPreviousSibling: _getPreviousSibling,\n  getFirstElementChild: _getFirstElementChild,\n  getLastElementChild: _getLastElementChild,\n  getNextElementSibling: _getNextElementSibling,\n  getPreviousElementSibling: _getPreviousElementSibling,\n  appendChild: _appendChild,\n  insertBefore: _insertBefore,\n  getSelection: _getSelection,\n  getElementsByName: _getElementsByName\n};\nfunction setDOMAPI(domapi) {\n  for (const key of Object.keys(domapi)) {\n    dom[key] = domapi[key];\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nlet _isBrokenIE11;\nconst _DOMRect = typeof DOMRect !== \"undefined\" ? DOMRect : class {\n  constructor(x, y, width, height) {\n    this.left = x || 0;\n    this.top = y || 0;\n    this.right = (x || 0) + (width || 0);\n    this.bottom = (y || 0) + (height || 0);\n  }\n};\nlet _uidCounter = 0;\ntry {\n  // IE11 only accepts `filter` argument as a function (not object with the `acceptNode`\n  // property as the docs define). Also `entityReferenceExpansion` argument is not\n  // optional. And it throws exception when the above arguments aren't there.\n  document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);\n  _isBrokenIE11 = false;\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n} catch (e) {\n  _isBrokenIE11 = true;\n}\nconst _updateDummyInputsTimeout = 100;\nfunction getInstanceContext(getWindow) {\n  const win = getWindow();\n  let ctx = win.__tabsterInstanceContext;\n  if (!ctx) {\n    ctx = {\n      elementByUId: {},\n      basics: {\n        Promise: win.Promise || undefined,\n        WeakRef: win.WeakRef || undefined\n      },\n      containerBoundingRectCache: {},\n      lastContainerBoundingRectCacheId: 0,\n      fakeWeakRefs: [],\n      fakeWeakRefsStarted: false\n    };\n    win.__tabsterInstanceContext = ctx;\n  }\n  return ctx;\n}\nfunction disposeInstanceContext(win) {\n  const ctx = win.__tabsterInstanceContext;\n  if (ctx) {\n    ctx.elementByUId = {};\n    delete ctx.WeakRef;\n    ctx.containerBoundingRectCache = {};\n    if (ctx.containerBoundingRectCacheTimer) {\n      win.clearTimeout(ctx.containerBoundingRectCacheTimer);\n    }\n    if (ctx.fakeWeakRefsTimer) {\n      win.clearTimeout(ctx.fakeWeakRefsTimer);\n    }\n    ctx.fakeWeakRefs = [];\n    delete win.__tabsterInstanceContext;\n  }\n}\nfunction createWeakMap(win) {\n  const ctx = win.__tabsterInstanceContext;\n  return new ((ctx === null || ctx === void 0 ? void 0 : ctx.basics.WeakMap) || WeakMap)();\n}\nfunction hasSubFocusable(element) {\n  return !!element.querySelector(FOCUSABLE_SELECTOR);\n}\nclass FakeWeakRef {\n  constructor(target) {\n    this._target = target;\n  }\n  deref() {\n    return this._target;\n  }\n  static cleanup(fwr, forceRemove) {\n    if (!fwr._target) {\n      return true;\n    }\n    if (forceRemove || !documentContains(fwr._target.ownerDocument, fwr._target)) {\n      delete fwr._target;\n      return true;\n    }\n    return false;\n  }\n}\nclass WeakHTMLElement {\n  constructor(getWindow, element, data) {\n    const context = getInstanceContext(getWindow);\n    let ref;\n    if (context.WeakRef) {\n      ref = new context.WeakRef(element);\n    } else {\n      ref = new FakeWeakRef(element);\n      context.fakeWeakRefs.push(ref);\n    }\n    this._ref = ref;\n    this._data = data;\n  }\n  get() {\n    const ref = this._ref;\n    let element;\n    if (ref) {\n      element = ref.deref();\n      if (!element) {\n        delete this._ref;\n      }\n    }\n    return element;\n  }\n  getData() {\n    return this._data;\n  }\n}\nfunction cleanupFakeWeakRefs(getWindow, forceRemove) {\n  const context = getInstanceContext(getWindow);\n  context.fakeWeakRefs = context.fakeWeakRefs.filter(e => !FakeWeakRef.cleanup(e, forceRemove));\n}\nfunction startFakeWeakRefsCleanup(getWindow) {\n  const context = getInstanceContext(getWindow);\n  if (!context.fakeWeakRefsStarted) {\n    context.fakeWeakRefsStarted = true;\n    context.WeakRef = getWeakRef(context);\n  }\n  if (!context.fakeWeakRefsTimer) {\n    context.fakeWeakRefsTimer = getWindow().setTimeout(() => {\n      context.fakeWeakRefsTimer = undefined;\n      cleanupFakeWeakRefs(getWindow);\n      startFakeWeakRefsCleanup(getWindow);\n    }, 2 * 60 * 1000); // 2 minutes.\n  }\n}\nfunction stopFakeWeakRefsCleanupAndClearStorage(getWindow) {\n  const context = getInstanceContext(getWindow);\n  context.fakeWeakRefsStarted = false;\n  if (context.fakeWeakRefsTimer) {\n    getWindow().clearTimeout(context.fakeWeakRefsTimer);\n    context.fakeWeakRefsTimer = undefined;\n    context.fakeWeakRefs = [];\n  }\n}\nfunction createElementTreeWalker(doc, root, acceptNode) {\n  // IE11 will throw an exception when the TreeWalker root is not an Element.\n  if (root.nodeType !== Node.ELEMENT_NODE) {\n    return undefined;\n  }\n  // TypeScript isn't aware of IE11 behaving badly.\n  const filter = _isBrokenIE11 ? acceptNode : {\n    acceptNode\n  };\n  return dom.createTreeWalker(doc, root, NodeFilter.SHOW_ELEMENT, filter,\n  // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.\n  false /* Last argument is not optional for IE11! */);\n}\nfunction getBoundingRect(getWindow, element) {\n  let cacheId = element.__tabsterCacheId;\n  const context = getInstanceContext(getWindow);\n  const cached = cacheId ? context.containerBoundingRectCache[cacheId] : undefined;\n  if (cached) {\n    return cached.rect;\n  }\n  const scrollingElement = element.ownerDocument && element.ownerDocument.documentElement;\n  if (!scrollingElement) {\n    return new _DOMRect();\n  }\n  // A bounding rect of the top-level element contains the whole page regardless of the\n  // scrollbar. So, we improvise a little and limiting the final result...\n  let left = 0;\n  let top = 0;\n  let right = scrollingElement.clientWidth;\n  let bottom = scrollingElement.clientHeight;\n  if (element !== scrollingElement) {\n    const r = element.getBoundingClientRect();\n    left = Math.max(left, r.left);\n    top = Math.max(top, r.top);\n    right = Math.min(right, r.right);\n    bottom = Math.min(bottom, r.bottom);\n  }\n  const rect = new _DOMRect(left < right ? left : -1, top < bottom ? top : -1, left < right ? right - left : 0, top < bottom ? bottom - top : 0);\n  if (!cacheId) {\n    cacheId = \"r-\" + ++context.lastContainerBoundingRectCacheId;\n    element.__tabsterCacheId = cacheId;\n  }\n  context.containerBoundingRectCache[cacheId] = {\n    rect,\n    element\n  };\n  if (!context.containerBoundingRectCacheTimer) {\n    context.containerBoundingRectCacheTimer = window.setTimeout(() => {\n      context.containerBoundingRectCacheTimer = undefined;\n      for (const cId of Object.keys(context.containerBoundingRectCache)) {\n        delete context.containerBoundingRectCache[cId].element.__tabsterCacheId;\n      }\n      context.containerBoundingRectCache = {};\n    }, 50);\n  }\n  return rect;\n}\nfunction isElementVerticallyVisibleInContainer(getWindow, element, tolerance) {\n  const container = getScrollableContainer(element);\n  if (!container) {\n    return false;\n  }\n  const containerRect = getBoundingRect(getWindow, container);\n  const elementRect = element.getBoundingClientRect();\n  const intersectionTolerance = elementRect.height * (1 - tolerance);\n  const topIntersection = Math.max(0, containerRect.top - elementRect.top);\n  const bottomIntersection = Math.max(0, elementRect.bottom - containerRect.bottom);\n  const totalIntersection = topIntersection + bottomIntersection;\n  return totalIntersection === 0 || totalIntersection <= intersectionTolerance;\n}\nfunction scrollIntoView(getWindow, element, alignToTop) {\n  // Built-in DOM's scrollIntoView() is cool, but when we have nested containers,\n  // it scrolls all of them, not just the deepest one. So, trying to work it around.\n  const container = getScrollableContainer(element);\n  if (container) {\n    const containerRect = getBoundingRect(getWindow, container);\n    const elementRect = element.getBoundingClientRect();\n    if (alignToTop) {\n      container.scrollTop += elementRect.top - containerRect.top;\n    } else {\n      container.scrollTop += elementRect.bottom - containerRect.bottom;\n    }\n  }\n}\nfunction getScrollableContainer(element) {\n  const doc = element.ownerDocument;\n  if (doc) {\n    for (let el = dom.getParentElement(element); el; el = dom.getParentElement(el)) {\n      if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {\n        return el;\n      }\n    }\n    return doc.documentElement;\n  }\n  return null;\n}\nfunction makeFocusIgnored(element) {\n  element.__shouldIgnoreFocus = true;\n}\nfunction shouldIgnoreFocus(element) {\n  return !!element.__shouldIgnoreFocus;\n}\nfunction getUId(wnd) {\n  const rnd = new Uint32Array(4);\n  if (wnd.crypto && wnd.crypto.getRandomValues) {\n    wnd.crypto.getRandomValues(rnd);\n  } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {\n    wnd.msCrypto.getRandomValues(rnd);\n  } else {\n    for (let i = 0; i < rnd.length; i++) {\n      rnd[i] = 0xffffffff * Math.random();\n    }\n  }\n  const srnd = [];\n  for (let i = 0; i < rnd.length; i++) {\n    srnd.push(rnd[i].toString(36));\n  }\n  srnd.push(\"|\");\n  srnd.push((++_uidCounter).toString(36));\n  srnd.push(\"|\");\n  srnd.push(Date.now().toString(36));\n  return srnd.join(\"\");\n}\nfunction getElementUId(getWindow, element) {\n  const context = getInstanceContext(getWindow);\n  let uid = element.__tabsterElementUID;\n  if (!uid) {\n    uid = element.__tabsterElementUID = getUId(getWindow());\n  }\n  if (!context.elementByUId[uid] && documentContains(element.ownerDocument, element)) {\n    context.elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n  }\n  return uid;\n}\nfunction getWindowUId(win) {\n  let uid = win.__tabsterCrossOriginWindowUID;\n  if (!uid) {\n    uid = win.__tabsterCrossOriginWindowUID = getUId(win);\n  }\n  return uid;\n}\nfunction clearElementCache(getWindow, parent) {\n  const context = getInstanceContext(getWindow);\n  for (const key of Object.keys(context.elementByUId)) {\n    const wel = context.elementByUId[key];\n    const el = wel && wel.get();\n    if (el && parent) {\n      if (!dom.nodeContains(parent, el)) {\n        continue;\n      }\n    }\n    delete context.elementByUId[key];\n  }\n}\n// IE11 doesn't have document.contains()...\nfunction documentContains(doc, element) {\n  return dom.nodeContains(doc === null || doc === void 0 ? void 0 : doc.body, element);\n}\nfunction matchesSelector(element, selector) {\n  const matches = element.matches || element.matchesSelector || element.msMatchesSelector || element.webkitMatchesSelector;\n  return matches && matches.call(element, selector);\n}\nfunction getPromise(getWindow) {\n  const context = getInstanceContext(getWindow);\n  if (context.basics.Promise) {\n    return context.basics.Promise;\n  }\n  throw new Error(\"No Promise defined.\");\n}\nfunction getWeakRef(context) {\n  return context.basics.WeakRef;\n}\nlet _lastTabsterPartId = 0;\nclass TabsterPart {\n  constructor(tabster, element, props) {\n    const getWindow = tabster.getWindow;\n    this._tabster = tabster;\n    this._element = new WeakHTMLElement(getWindow, element);\n    this._props = {\n      ...props\n    };\n    this.id = \"i\" + ++_lastTabsterPartId;\n  }\n  getElement() {\n    return this._element.get();\n  }\n  getProps() {\n    return this._props;\n  }\n  setProps(props) {\n    this._props = {\n      ...props\n    };\n  }\n}\n/**\n * Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them\n */\nclass DummyInput {\n  constructor(getWindow, isOutside, props, element, fixedTarget) {\n    var _a;\n    this._focusIn = e => {\n      if (this._fixedTarget) {\n        const target = this._fixedTarget.get();\n        if (target) {\n          (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(target);\n        }\n        return;\n      }\n      const input = this.input;\n      if (this.onFocusIn && input) {\n        const relatedTarget = e.relatedTarget;\n        this.onFocusIn(this, this._isBackward(true, input, relatedTarget), relatedTarget);\n      }\n    };\n    this._focusOut = e => {\n      if (this._fixedTarget) {\n        return;\n      }\n      this.useDefaultAction = false;\n      const input = this.input;\n      if (this.onFocusOut && input) {\n        const relatedTarget = e.relatedTarget;\n        this.onFocusOut(this, this._isBackward(false, input, relatedTarget), relatedTarget);\n      }\n    };\n    const win = getWindow();\n    const input = win.document.createElement(\"i\");\n    input.tabIndex = 0;\n    input.setAttribute(\"role\", \"none\");\n    input.setAttribute(TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME, \"\");\n    input.setAttribute(\"aria-hidden\", \"true\");\n    const style = input.style;\n    style.position = \"fixed\";\n    style.width = style.height = \"1px\";\n    style.opacity = \"0.001\";\n    style.zIndex = \"-1\";\n    style.setProperty(\"content-visibility\", \"hidden\");\n    makeFocusIgnored(input);\n    this.input = input;\n    this.isFirst = props.isFirst;\n    this.isOutside = isOutside;\n    this._isPhantom = (_a = props.isPhantom) !== null && _a !== void 0 ? _a : false;\n    this._fixedTarget = fixedTarget;\n    input.addEventListener(\"focusin\", this._focusIn);\n    input.addEventListener(\"focusout\", this._focusOut);\n    input.__tabsterDummyContainer = element;\n    if (this._isPhantom) {\n      this._disposeTimer = win.setTimeout(() => {\n        delete this._disposeTimer;\n        this.dispose();\n      }, 0);\n      this._clearDisposeTimeout = () => {\n        if (this._disposeTimer) {\n          win.clearTimeout(this._disposeTimer);\n          delete this._disposeTimer;\n        }\n        delete this._clearDisposeTimeout;\n      };\n    }\n  }\n  dispose() {\n    var _a;\n    if (this._clearDisposeTimeout) {\n      this._clearDisposeTimeout();\n    }\n    const input = this.input;\n    if (!input) {\n      return;\n    }\n    delete this._fixedTarget;\n    delete this.onFocusIn;\n    delete this.onFocusOut;\n    delete this.input;\n    input.removeEventListener(\"focusin\", this._focusIn);\n    input.removeEventListener(\"focusout\", this._focusOut);\n    delete input.__tabsterDummyContainer;\n    (_a = dom.getParentNode(input)) === null || _a === void 0 ? void 0 : _a.removeChild(input);\n  }\n  setTopLeft(top, left) {\n    var _a;\n    const style = (_a = this.input) === null || _a === void 0 ? void 0 : _a.style;\n    if (style) {\n      style.top = `${top}px`;\n      style.left = `${left}px`;\n    }\n  }\n  _isBackward(isIn, current, previous) {\n    return isIn && !previous ? !this.isFirst : !!(previous && current.compareDocumentPosition(previous) & Node.DOCUMENT_POSITION_FOLLOWING);\n  }\n}\nconst DummyInputManagerPriorities = {\n  Root: 1,\n  Modalizer: 2,\n  Mover: 3,\n  Groupper: 4\n};\nclass DummyInputManager {\n  constructor(tabster, element, priority, sys, outsideByDefault, callForDefaultAction) {\n    this._element = element;\n    this._instance = new DummyInputManagerCore(tabster, element, this, priority, sys, outsideByDefault, callForDefaultAction);\n  }\n  _setHandlers(onFocusIn, onFocusOut) {\n    this._onFocusIn = onFocusIn;\n    this._onFocusOut = onFocusOut;\n  }\n  moveOut(backwards) {\n    var _a;\n    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOut(backwards);\n  }\n  moveOutWithDefaultAction(backwards, relatedEvent) {\n    var _a;\n    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOutWithDefaultAction(backwards, relatedEvent);\n  }\n  getHandler(isIn) {\n    return isIn ? this._onFocusIn : this._onFocusOut;\n  }\n  setTabbable(tabbable) {\n    var _a;\n    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.setTabbable(this, tabbable);\n  }\n  dispose() {\n    if (this._instance) {\n      this._instance.dispose(this);\n      delete this._instance;\n    }\n    delete this._onFocusIn;\n    delete this._onFocusOut;\n  }\n  static moveWithPhantomDummy(tabster, element,\n  // The target element to move to or out of.\n  moveOutOfElement,\n  // Whether to move out of the element or into it.\n  isBackward,\n  // Are we tabbing of shift-tabbing?\n  relatedEvent // The event that triggered the move.\n  ) {\n    // Phantom dummy is a hack to use browser's default action to move\n    // focus from a specific point in the application to the next/previous\n    // element. Default action is needed because next focusable element\n    // is not always available to focus directly (for example, next focusable\n    // is inside isolated iframe) or for uncontrolled areas we want to make\n    // sure that something that controls it takes care of the focusing.\n    // It works in a way that during the Tab key handling, we create a dummy\n    // input element, place it to the specific place in the DOM and focus it,\n    // then the default action of the Tab press will move focus from our dummy\n    // input. And we remove it from the DOM right after that.\n    const dummy = new DummyInput(tabster.getWindow, true, {\n      isPhantom: true,\n      isFirst: true\n    });\n    const input = dummy.input;\n    if (input) {\n      let parent;\n      let insertBefore;\n      // Let's say we have a following DOM structure:\n      // <div>\n      //   <button>Button1</button>\n      //   <div id=\"uncontrolled\" data-tabster={uncontrolled: {}}>\n      //     <button>Button2</button>\n      //     <button>Button3</button>\n      //   </div>\n      //   <button>Button4</button>\n      // </div>\n      //\n      // We pass the \"uncontrolled\" div as the element to move to or out of.\n      //\n      // When we pass moveOutOfElement=true and isBackward=false,\n      // the phantom dummy input will be inserted before Button4.\n      //\n      // When we pass moveOutOfElement=true and isBackward=true, there are\n      // two cases. If the uncontrolled element is focusable (has tabindex=0),\n      // the phantom dummy input will be inserted after Button1. If the\n      // uncontrolled element is not focusable, the phantom dummy input will be\n      // inserted before Button2.\n      //\n      // When we pass moveOutOfElement=false and isBackward=false, the\n      // phantom dummy input will be inserted after Button1.\n      //\n      // When we pass moveOutOfElement=false and isBackward=true, the phantom\n      // dummy input will be inserted before Button4.\n      //\n      // And we have a corner case for <body> and we make sure that the inserted\n      // dummy is inserted properly when there are existing permanent dummies.\n      if (element.tagName === \"BODY\") {\n        // We cannot insert elements outside of BODY.\n        parent = element;\n        insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? dom.getFirstElementChild(element) : null;\n      } else {\n        if (moveOutOfElement && (!isBackward || isBackward && !tabster.focusable.isFocusable(element, false, true, true))) {\n          parent = element;\n          insertBefore = isBackward ? element.firstElementChild : null;\n        } else {\n          parent = dom.getParentElement(element);\n          insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? element : dom.getNextElementSibling(element);\n        }\n        let potentialDummy;\n        let dummyFor;\n        do {\n          // This is a safety pillow for the cases when someone, combines\n          // groupper with uncontrolled on the same node. Which is technically\n          // not correct, but moving into the container element via its dummy\n          // input would produce a correct behaviour in uncontrolled mode.\n          potentialDummy = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? dom.getPreviousElementSibling(insertBefore) : insertBefore;\n          dummyFor = getDummyInputContainer(potentialDummy);\n          if (dummyFor === element) {\n            insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? potentialDummy : dom.getNextElementSibling(potentialDummy);\n          } else {\n            dummyFor = null;\n          }\n        } while (dummyFor);\n      }\n      if (parent === null || parent === void 0 ? void 0 : parent.dispatchEvent(new TabsterMoveFocusEvent({\n        by: \"root\",\n        owner: parent,\n        next: null,\n        relatedEvent\n      }))) {\n        dom.insertBefore(parent, input, insertBefore);\n        (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(input);\n      }\n    }\n  }\n  static addPhantomDummyWithTarget(tabster, sourceElement, isBackward, targetElement) {\n    const dummy = new DummyInput(tabster.getWindow, true, {\n      isPhantom: true,\n      isFirst: true\n    }, undefined, new WeakHTMLElement(tabster.getWindow, targetElement));\n    const input = dummy.input;\n    if (input) {\n      let dummyParent;\n      let insertBefore;\n      if (hasSubFocusable(sourceElement) && !isBackward) {\n        dummyParent = sourceElement;\n        insertBefore = dom.getFirstElementChild(sourceElement);\n      } else {\n        dummyParent = dom.getParentElement(sourceElement);\n        insertBefore = isBackward ? sourceElement : dom.getNextElementSibling(sourceElement);\n      }\n      if (dummyParent) {\n        dom.insertBefore(dummyParent, input, insertBefore);\n      }\n    }\n  }\n}\nfunction setDummyInputDebugValue(dummy, wrappers) {\n  var _a;\n  const what = {\n    1: \"Root\",\n    2: \"Modalizer\",\n    3: \"Mover\",\n    4: \"Groupper\"\n  };\n  (_a = dummy.input) === null || _a === void 0 ? void 0 : _a.setAttribute(TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME, [`isFirst=${dummy.isFirst}`, `isOutside=${dummy.isOutside}`, ...wrappers.map(w => `(${what[w.priority]}, tabbable=${w.tabbable})`)].join(\", \"));\n}\nclass DummyInputObserver {\n  constructor(win) {\n    this._updateQueue = new Set();\n    this._lastUpdateQueueTime = 0;\n    this._changedParents = new WeakSet();\n    this._dummyElements = [];\n    this._dummyCallbacks = new WeakMap();\n    this._domChanged = parent => {\n      var _a;\n      if (this._changedParents.has(parent)) {\n        return;\n      }\n      this._changedParents.add(parent);\n      if (this._updateDummyInputsTimer) {\n        return;\n      }\n      this._updateDummyInputsTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {\n        delete this._updateDummyInputsTimer;\n        for (const ref of this._dummyElements) {\n          const dummyElement = ref.get();\n          if (dummyElement) {\n            const callback = this._dummyCallbacks.get(dummyElement);\n            if (callback) {\n              const dummyParent = dom.getParentNode(dummyElement);\n              if (!dummyParent || this._changedParents.has(dummyParent)) {\n                callback();\n              }\n            }\n          }\n        }\n        this._changedParents = new WeakSet();\n      }, _updateDummyInputsTimeout);\n    };\n    this._win = win;\n  }\n  add(dummy, callback) {\n    if (!this._dummyCallbacks.has(dummy) && this._win) {\n      this._dummyElements.push(new WeakHTMLElement(this._win, dummy));\n      this._dummyCallbacks.set(dummy, callback);\n      this.domChanged = this._domChanged;\n    }\n  }\n  remove(dummy) {\n    this._dummyElements = this._dummyElements.filter(ref => {\n      const element = ref.get();\n      return element && element !== dummy;\n    });\n    this._dummyCallbacks.delete(dummy);\n    if (this._dummyElements.length === 0) {\n      delete this.domChanged;\n    }\n  }\n  dispose() {\n    var _a;\n    const win = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this);\n    if (this._updateTimer) {\n      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n    if (this._updateDummyInputsTimer) {\n      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateDummyInputsTimer);\n      delete this._updateDummyInputsTimer;\n    }\n    this._changedParents = new WeakSet();\n    this._dummyCallbacks = new WeakMap();\n    this._dummyElements = [];\n    this._updateQueue.clear();\n    delete this.domChanged;\n    delete this._win;\n  }\n  updatePositions(compute) {\n    if (!this._win) {\n      // As this is a public method, we make sure that it has no effect when\n      // called after dispose().\n      return;\n    }\n    this._updateQueue.add(compute);\n    this._lastUpdateQueueTime = Date.now();\n    this._scheduledUpdatePositions();\n  }\n  _scheduledUpdatePositions() {\n    var _a;\n    if (this._updateTimer) {\n      return;\n    }\n    this._updateTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {\n      delete this._updateTimer;\n      // updatePositions() might be called quite a lot during the scrolling.\n      // So, instead of clearing the timeout and scheduling a new one, we\n      // check if enough time has passed since the last updatePositions() call\n      // and only schedule a new one if not.\n      // At maximum, we will update dummy inputs positions\n      // _updateDummyInputsTimeout * 2 after the last updatePositions() call.\n      if (this._lastUpdateQueueTime + _updateDummyInputsTimeout <= Date.now()) {\n        // A cache for current bulk of updates to reduce getComputedStyle() calls.\n        const scrollTopLeftCache = new Map();\n        const setTopLeftCallbacks = [];\n        for (const compute of this._updateQueue) {\n          setTopLeftCallbacks.push(compute(scrollTopLeftCache));\n        }\n        this._updateQueue.clear();\n        // We're splitting the computation of offsets and setting them to avoid extra\n        // reflows.\n        for (const setTopLeft of setTopLeftCallbacks) {\n          setTopLeft();\n        }\n        // Explicitly clear to not hold references till the next garbage collection.\n        scrollTopLeftCache.clear();\n      } else {\n        this._scheduledUpdatePositions();\n      }\n    }, _updateDummyInputsTimeout);\n  }\n}\n/**\n * Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)\n */\nclass DummyInputManagerCore {\n  constructor(tabster, element, manager, priority, sys, outsideByDefault, callForDefaultAction) {\n    this._wrappers = [];\n    this._isOutside = false;\n    this._transformElements = new Set();\n    this._onFocusIn = (dummyInput, isBackward, relatedTarget) => {\n      this._onFocus(true, dummyInput, isBackward, relatedTarget);\n    };\n    this._onFocusOut = (dummyInput, isBackward, relatedTarget) => {\n      this._onFocus(false, dummyInput, isBackward, relatedTarget);\n    };\n    this.moveOut = backwards => {\n      var _a;\n      const first = this._firstDummy;\n      const last = this._lastDummy;\n      if (first && last) {\n        // For the sake of performance optimization, the dummy input\n        // position in the DOM updates asynchronously from the DOM change.\n        // Calling _ensurePosition() to make sure the position is correct.\n        this._ensurePosition();\n        const firstInput = first.input;\n        const lastInput = last.input;\n        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n        if (firstInput && lastInput && element) {\n          let toFocus;\n          if (backwards) {\n            firstInput.tabIndex = 0;\n            toFocus = firstInput;\n          } else {\n            lastInput.tabIndex = 0;\n            toFocus = lastInput;\n          }\n          if (toFocus) {\n            (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(toFocus);\n          }\n        }\n      }\n    };\n    /**\n     * Prepares to move focus out of the given element by focusing\n     * one of the dummy inputs and setting the `useDefaultAction` flag\n     * @param backwards focus moving to an element behind the given element\n     */\n    this.moveOutWithDefaultAction = (backwards, relatedEvent) => {\n      var _a;\n      const first = this._firstDummy;\n      const last = this._lastDummy;\n      if (first && last) {\n        // For the sake of performance optimization, the dummy input\n        // position in the DOM updates asynchronously from the DOM change.\n        // Calling _ensurePosition() to make sure the position is correct.\n        this._ensurePosition();\n        const firstInput = first.input;\n        const lastInput = last.input;\n        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n        if (firstInput && lastInput && element) {\n          let toFocus;\n          if (backwards) {\n            if (!first.isOutside && this._tabster.focusable.isFocusable(element, true, true, true)) {\n              toFocus = element;\n            } else {\n              first.useDefaultAction = true;\n              firstInput.tabIndex = 0;\n              toFocus = firstInput;\n            }\n          } else {\n            last.useDefaultAction = true;\n            lastInput.tabIndex = 0;\n            toFocus = lastInput;\n          }\n          if (toFocus && element.dispatchEvent(new TabsterMoveFocusEvent({\n            by: \"root\",\n            owner: element,\n            next: null,\n            relatedEvent\n          }))) {\n            (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(toFocus);\n          }\n        }\n      }\n    };\n    this.setTabbable = (manager, tabbable) => {\n      var _a, _b;\n      for (const w of this._wrappers) {\n        if (w.manager === manager) {\n          w.tabbable = tabbable;\n          break;\n        }\n      }\n      const wrapper = this._getCurrent();\n      if (wrapper) {\n        const tabIndex = wrapper.tabbable ? 0 : -1;\n        let input = (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input;\n        if (input) {\n          input.tabIndex = tabIndex;\n        }\n        input = (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input;\n        if (input) {\n          input.tabIndex = tabIndex;\n        }\n      }\n      if (true) {\n        this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);\n        this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);\n      }\n    };\n    /**\n     * Adds dummy inputs as the first and last child of the given element\n     * Called each time the children under the element is mutated\n     */\n    this._addDummyInputs = () => {\n      if (this._addTimer) {\n        return;\n      }\n      this._addTimer = this._getWindow().setTimeout(() => {\n        delete this._addTimer;\n        this._ensurePosition();\n        if (true) {\n          this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);\n          this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);\n        }\n        this._addTransformOffsets();\n      }, 0);\n    };\n    this._addTransformOffsets = () => {\n      this._tabster._dummyObserver.updatePositions(this._computeTransformOffsets);\n    };\n    this._computeTransformOffsets = scrollTopLeftCache => {\n      var _a, _b;\n      const from = ((_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input) || ((_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input);\n      const transformElements = this._transformElements;\n      const newTransformElements = new Set();\n      let scrollTop = 0;\n      let scrollLeft = 0;\n      const win = this._getWindow();\n      for (let element = from; element && element.nodeType === Node.ELEMENT_NODE; element = dom.getParentElement(element)) {\n        let scrollTopLeft = scrollTopLeftCache.get(element);\n        // getComputedStyle() and element.scrollLeft/Top() cause style recalculation,\n        // so we cache the result across all elements in the current bulk.\n        if (scrollTopLeft === undefined) {\n          const transform = win.getComputedStyle(element).transform;\n          if (transform && transform !== \"none\") {\n            scrollTopLeft = {\n              scrollTop: element.scrollTop,\n              scrollLeft: element.scrollLeft\n            };\n          }\n          scrollTopLeftCache.set(element, scrollTopLeft || null);\n        }\n        if (scrollTopLeft) {\n          newTransformElements.add(element);\n          if (!transformElements.has(element)) {\n            element.addEventListener(\"scroll\", this._addTransformOffsets);\n          }\n          scrollTop += scrollTopLeft.scrollTop;\n          scrollLeft += scrollTopLeft.scrollLeft;\n        }\n      }\n      for (const el of transformElements) {\n        if (!newTransformElements.has(el)) {\n          el.removeEventListener(\"scroll\", this._addTransformOffsets);\n        }\n      }\n      this._transformElements = newTransformElements;\n      return () => {\n        var _a, _b;\n        (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.setTopLeft(scrollTop, scrollLeft);\n        (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.setTopLeft(scrollTop, scrollLeft);\n      };\n    };\n    const el = element.get();\n    if (!el) {\n      throw new Error(\"No element\");\n    }\n    this._tabster = tabster;\n    this._getWindow = tabster.getWindow;\n    this._callForDefaultAction = callForDefaultAction;\n    const instance = el.__tabsterDummy;\n    (instance || this)._wrappers.push({\n      manager,\n      priority,\n      tabbable: true\n    });\n    if (instance) {\n      if (true) {\n        this._firstDummy && setDummyInputDebugValue(this._firstDummy, instance._wrappers);\n        this._lastDummy && setDummyInputDebugValue(this._lastDummy, instance._wrappers);\n      }\n      return instance;\n    }\n    el.__tabsterDummy = this;\n    // Some elements allow only specific types of direct descendants and we need to\n    // put our dummy inputs inside or outside of the element accordingly.\n    const forcedDummyPosition = sys === null || sys === void 0 ? void 0 : sys.dummyInputsPosition;\n    const tagName = el.tagName;\n    this._isOutside = !forcedDummyPosition ? (outsideByDefault || tagName === \"UL\" || tagName === \"OL\" || tagName === \"TABLE\") && !(tagName === \"LI\" || tagName === \"TD\" || tagName === \"TH\") : forcedDummyPosition === SysDummyInputsPositions.Outside;\n    this._firstDummy = new DummyInput(this._getWindow, this._isOutside, {\n      isFirst: true\n    }, element);\n    this._lastDummy = new DummyInput(this._getWindow, this._isOutside, {\n      isFirst: false\n    }, element);\n    // We will be checking dummy input parents to see if their child list have changed.\n    // So, it is enough to have just one of the inputs observed, because\n    // both dummy inputs always have the same parent.\n    const dummyElement = this._firstDummy.input;\n    dummyElement && tabster._dummyObserver.add(dummyElement, this._addDummyInputs);\n    this._firstDummy.onFocusIn = this._onFocusIn;\n    this._firstDummy.onFocusOut = this._onFocusOut;\n    this._lastDummy.onFocusIn = this._onFocusIn;\n    this._lastDummy.onFocusOut = this._onFocusOut;\n    this._element = element;\n    this._addDummyInputs();\n  }\n  dispose(manager, force) {\n    var _a, _b, _c, _d;\n    const wrappers = this._wrappers = this._wrappers.filter(w => w.manager !== manager && !force);\n    if (true) {\n      this._firstDummy && setDummyInputDebugValue(this._firstDummy, wrappers);\n      this._lastDummy && setDummyInputDebugValue(this._lastDummy, wrappers);\n    }\n    if (wrappers.length === 0) {\n      delete ((_a = this._element) === null || _a === void 0 ? void 0 : _a.get()).__tabsterDummy;\n      for (const el of this._transformElements) {\n        el.removeEventListener(\"scroll\", this._addTransformOffsets);\n      }\n      this._transformElements.clear();\n      const win = this._getWindow();\n      if (this._addTimer) {\n        win.clearTimeout(this._addTimer);\n        delete this._addTimer;\n      }\n      const dummyElement = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;\n      dummyElement && this._tabster._dummyObserver.remove(dummyElement);\n      (_c = this._firstDummy) === null || _c === void 0 ? void 0 : _c.dispose();\n      (_d = this._lastDummy) === null || _d === void 0 ? void 0 : _d.dispose();\n    }\n  }\n  _onFocus(isIn, dummyInput, isBackward, relatedTarget) {\n    var _a;\n    const wrapper = this._getCurrent();\n    if (wrapper && (!dummyInput.useDefaultAction || this._callForDefaultAction)) {\n      (_a = wrapper.manager.getHandler(isIn)) === null || _a === void 0 ? void 0 : _a(dummyInput, isBackward, relatedTarget);\n    }\n  }\n  _getCurrent() {\n    this._wrappers.sort((a, b) => {\n      if (a.tabbable !== b.tabbable) {\n        return a.tabbable ? -1 : 1;\n      }\n      return a.priority - b.priority;\n    });\n    return this._wrappers[0];\n  }\n  _ensurePosition() {\n    var _a, _b, _c;\n    const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n    const firstDummyInput = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;\n    const lastDummyInput = (_c = this._lastDummy) === null || _c === void 0 ? void 0 : _c.input;\n    if (!element || !firstDummyInput || !lastDummyInput) {\n      return;\n    }\n    if (this._isOutside) {\n      const elementParent = dom.getParentNode(element);\n      if (elementParent) {\n        const nextSibling = dom.getNextSibling(element);\n        if (nextSibling !== lastDummyInput) {\n          dom.insertBefore(elementParent, lastDummyInput, nextSibling);\n        }\n        if (dom.getPreviousElementSibling(element) !== firstDummyInput) {\n          dom.insertBefore(elementParent, firstDummyInput, element);\n        }\n      }\n    } else {\n      if (dom.getLastElementChild(element) !== lastDummyInput) {\n        dom.appendChild(element, lastDummyInput);\n      }\n      const firstElementChild = dom.getFirstElementChild(element);\n      if (firstElementChild && firstElementChild !== firstDummyInput && firstElementChild.parentNode) {\n        dom.insertBefore(firstElementChild.parentNode, firstDummyInput, firstElementChild);\n      }\n    }\n  }\n}\nfunction getLastChild$2(container) {\n  let lastChild = null;\n  for (let i = dom.getLastElementChild(container); i; i = dom.getLastElementChild(i)) {\n    lastChild = i;\n  }\n  return lastChild || undefined;\n}\nfunction getAdjacentElement(from, prev) {\n  let cur = from;\n  let adjacent = null;\n  while (cur && !adjacent) {\n    adjacent = prev ? dom.getPreviousElementSibling(cur) : dom.getNextElementSibling(cur);\n    cur = dom.getParentElement(cur);\n  }\n  return adjacent || undefined;\n}\nfunction augmentAttribute(tabster, element, name, value // Restore original value when undefined.\n) {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const entry = tabster.storageEntry(element, true);\n  let ret = false;\n  if (!entry.aug) {\n    if (value === undefined) {\n      return ret;\n    }\n    entry.aug = {};\n  }\n  if (value === undefined) {\n    if (name in entry.aug) {\n      const origVal = entry.aug[name];\n      delete entry.aug[name];\n      if (origVal === null) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, origVal);\n      }\n      ret = true;\n    }\n  } else {\n    let origValue;\n    if (!(name in entry.aug)) {\n      origValue = element.getAttribute(name);\n    }\n    if (origValue !== undefined && origValue !== value) {\n      entry.aug[name] = origValue;\n      if (value === null) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value);\n      }\n      ret = true;\n    }\n  }\n  if (value === undefined && Object.keys(entry.aug).length === 0) {\n    delete entry.aug;\n    tabster.storageEntry(element, false);\n  }\n  return ret;\n}\nfunction isDisplayNone(element) {\n  var _a, _b;\n  const elementDocument = element.ownerDocument;\n  const computedStyle = (_a = elementDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getComputedStyle(element);\n  // offsetParent is null for elements with display:none, display:fixed and for <body>.\n  if (element.offsetParent === null && elementDocument.body !== element && (computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.position) !== \"fixed\") {\n    return true;\n  }\n  // For our purposes of looking for focusable elements, visibility:hidden has the same\n  // effect as display:none.\n  if ((computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.visibility) === \"hidden\") {\n    return true;\n  }\n  // if an element has display: fixed, we need to check if it is also hidden with CSS,\n  // or within a parent hidden with CSS\n  if ((computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.position) === \"fixed\") {\n    if (computedStyle.display === \"none\") {\n      return true;\n    }\n    if (((_b = element.parentElement) === null || _b === void 0 ? void 0 : _b.offsetParent) === null && elementDocument.body !== element.parentElement) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isRadio(element) {\n  return element.tagName === \"INPUT\" && !!element.name && element.type === \"radio\";\n}\nfunction getRadioButtonGroup(element) {\n  if (!isRadio(element)) {\n    return;\n  }\n  const name = element.name;\n  let radioButtons = Array.from(dom.getElementsByName(element, name));\n  let checked;\n  radioButtons = radioButtons.filter(el => {\n    if (isRadio(el)) {\n      if (el.checked) {\n        checked = el;\n      }\n      return true;\n    }\n    return false;\n  });\n  return {\n    name,\n    buttons: new Set(radioButtons),\n    checked\n  };\n}\n/**\n * If the passed element is Tabster dummy input, returns the container element this dummy input belongs to.\n * @param element Element to check for being dummy input.\n * @returns Dummy input container element (if the passed element is a dummy input) or null.\n */\nfunction getDummyInputContainer(element) {\n  var _a;\n  return ((_a = element === null || element === void 0 ? void 0 : element.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) || null;\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction getTabsterAttribute(props, plain) {\n  const attr = JSON.stringify(props);\n  if (plain === true) {\n    return attr;\n  }\n  return {\n    [TABSTER_ATTRIBUTE_NAME]: attr\n  };\n}\n/**\n * Updates Tabster props object with new props.\n * @param element an element to set data-tabster attribute on.\n * @param props current Tabster props to update.\n * @param newProps new Tabster props to add.\n *  When the value of a property in newProps is undefined, the property\n *  will be removed from the attribute.\n */\nfunction mergeTabsterProps(props, newProps) {\n  for (const key of Object.keys(newProps)) {\n    const value = newProps[key];\n    if (value) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      props[key] = value;\n    } else {\n      delete props[key];\n    }\n  }\n}\n/**\n * Sets or updates Tabster attribute of the element.\n * @param element an element to set data-tabster attribute on.\n * @param newProps new Tabster props to set.\n * @param update if true, newProps will be merged with the existing props.\n *  When true and the value of a property in newProps is undefined, the property\n *  will be removed from the attribute.\n */\nfunction setTabsterAttribute(element, newProps, update) {\n  let props;\n  if (update) {\n    const attr = element.getAttribute(TABSTER_ATTRIBUTE_NAME);\n    if (attr) {\n      try {\n        props = JSON.parse(attr);\n      } catch (e) {\n        if (true) {\n          console.error(`data-tabster attribute error: ${e}`, element);\n        }\n      }\n    }\n  }\n  if (!props) {\n    props = {};\n  }\n  mergeTabsterProps(props, newProps);\n  if (Object.keys(props).length > 0) {\n    element.setAttribute(TABSTER_ATTRIBUTE_NAME, getTabsterAttribute(props, true));\n  } else {\n    element.removeAttribute(TABSTER_ATTRIBUTE_NAME);\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction _setInformativeStyle$3(weakElement, remove, id) {\n  if (true) {\n    const element = weakElement.get();\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-root\");\n      } else {\n        element.style.setProperty(\"--tabster-root\", id + \",\");\n      }\n    }\n  }\n}\nclass RootDummyManager extends DummyInputManager {\n  constructor(tabster, element, setFocused, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Root, sys, undefined, true);\n    this._onDummyInputFocus = dummyInput => {\n      var _a;\n      if (dummyInput.useDefaultAction) {\n        // When we've reached the last focusable element, we want to let the browser\n        // to move the focus outside of the page. In order to do that we're synchronously\n        // calling focus() of the dummy input from the Tab key handler and allowing\n        // the default action to move the focus out.\n        this._setFocused(false);\n      } else {\n        // The only way a dummy input gets focused is during the keyboard navigation.\n        this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);\n        const element = this._element.get();\n        if (element) {\n          this._setFocused(true);\n          const toFocus = this._tabster.focusedElement.getFirstOrLastTabbable(dummyInput.isFirst, {\n            container: element,\n            ignoreAccessibility: true\n          });\n          if (toFocus) {\n            (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(toFocus);\n            return;\n          }\n        }\n        (_a = dummyInput.input) === null || _a === void 0 ? void 0 : _a.blur();\n      }\n    };\n    this._setHandlers(this._onDummyInputFocus);\n    this._tabster = tabster;\n    this._setFocused = setFocused;\n  }\n}\nclass Root extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    super(tabster, element, props);\n    this._isFocused = false;\n    this._setFocused = hasFocused => {\n      var _a;\n      if (this._setFocusedTimer) {\n        this._tabster.getWindow().clearTimeout(this._setFocusedTimer);\n        delete this._setFocusedTimer;\n      }\n      if (this._isFocused === hasFocused) {\n        return;\n      }\n      const element = this._element.get();\n      if (element) {\n        if (hasFocused) {\n          this._isFocused = true;\n          (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(false);\n          element.dispatchEvent(new RootFocusEvent({\n            element\n          }));\n        } else {\n          this._setFocusedTimer = this._tabster.getWindow().setTimeout(() => {\n            var _a;\n            delete this._setFocusedTimer;\n            this._isFocused = false;\n            (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(true);\n            element.dispatchEvent(new RootBlurEvent({\n              element\n            }));\n          }, 0);\n        }\n      }\n    };\n    this._onFocusIn = event => {\n      const getParent = this._tabster.getParent;\n      const rootElement = this._element.get();\n      let curElement = event.composedPath()[0];\n      do {\n        if (curElement === rootElement) {\n          this._setFocused(true);\n          return;\n        }\n        curElement = curElement && getParent(curElement);\n      } while (curElement);\n    };\n    this._onFocusOut = () => {\n      this._setFocused(false);\n    };\n    this._onDispose = onDispose;\n    const win = tabster.getWindow;\n    this.uid = getElementUId(win, element);\n    this._sys = sys;\n    if (tabster.controlTab || tabster.rootDummyInputs) {\n      this.addDummyInputs();\n    }\n    const w = win();\n    const doc = w.document;\n    doc.addEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.KEYBORG_FOCUSIN, this._onFocusIn);\n    doc.addEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.KEYBORG_FOCUSOUT, this._onFocusOut);\n    this._add();\n  }\n  addDummyInputs() {\n    if (!this._dummyManager) {\n      this._dummyManager = new RootDummyManager(this._tabster, this._element, this._setFocused, this._sys);\n    }\n  }\n  dispose() {\n    var _a;\n    this._onDispose(this);\n    const win = this._tabster.getWindow();\n    const doc = win.document;\n    doc.removeEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.KEYBORG_FOCUSIN, this._onFocusIn);\n    doc.removeEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.KEYBORG_FOCUSOUT, this._onFocusOut);\n    if (this._setFocusedTimer) {\n      win.clearTimeout(this._setFocusedTimer);\n      delete this._setFocusedTimer;\n    }\n    (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._remove();\n  }\n  moveOutWithDefaultAction(isBackward, relatedEvent) {\n    const dummyManager = this._dummyManager;\n    if (dummyManager) {\n      dummyManager.moveOutWithDefaultAction(isBackward, relatedEvent);\n    } else {\n      const el = this.getElement();\n      if (el) {\n        RootDummyManager.moveWithPhantomDummy(this._tabster, el, true, isBackward, relatedEvent);\n      }\n    }\n  }\n  _add() {\n    if (true) {\n      _setInformativeStyle$3(this._element, false, this.uid);\n    }\n  }\n  _remove() {\n    if (true) {\n      _setInformativeStyle$3(this._element, true);\n    }\n  }\n}\nclass RootAPI {\n  constructor(tabster, autoRoot) {\n    this._autoRootWaiting = false;\n    this._roots = {};\n    this._forceDummy = false;\n    this.rootById = {};\n    this._autoRootCreate = () => {\n      var _a;\n      const doc = this._win().document;\n      const body = doc.body;\n      if (body) {\n        this._autoRootUnwait(doc);\n        const props = this._autoRoot;\n        if (props) {\n          setTabsterAttribute(body, {\n            root: props\n          }, true);\n          updateTabsterByAttribute(this._tabster, body);\n          return (_a = getTabsterOnElement(this._tabster, body)) === null || _a === void 0 ? void 0 : _a.root;\n        }\n      } else if (!this._autoRootWaiting) {\n        this._autoRootWaiting = true;\n        doc.addEventListener(\"readystatechange\", this._autoRootCreate);\n      }\n      return undefined;\n    };\n    this._onRootDispose = root => {\n      delete this._roots[root.id];\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._autoRoot = autoRoot;\n    tabster.queueInit(() => {\n      if (this._autoRoot) {\n        this._autoRootCreate();\n      }\n    });\n  }\n  _autoRootUnwait(doc) {\n    doc.removeEventListener(\"readystatechange\", this._autoRootCreate);\n    this._autoRootWaiting = false;\n  }\n  dispose() {\n    const win = this._win();\n    this._autoRootUnwait(win.document);\n    delete this._autoRoot;\n    Object.keys(this._roots).forEach(rootId => {\n      if (this._roots[rootId]) {\n        this._roots[rootId].dispose();\n        delete this._roots[rootId];\n      }\n    });\n    this.rootById = {};\n  }\n  createRoot(element, props, sys) {\n    if (true) ;\n    const newRoot = new Root(this._tabster, element, this._onRootDispose, props, sys);\n    this._roots[newRoot.id] = newRoot;\n    if (this._forceDummy) {\n      newRoot.addDummyInputs();\n    }\n    return newRoot;\n  }\n  addDummyInputs() {\n    this._forceDummy = true;\n    const roots = this._roots;\n    for (const id of Object.keys(roots)) {\n      roots[id].addDummyInputs();\n    }\n  }\n  static getRootByUId(getWindow, id) {\n    const tabster = getWindow().__tabsterInstance;\n    return tabster && tabster.root.rootById[id];\n  }\n  /**\n   * Fetches the tabster context for an element walking up its ancestors\n   *\n   * @param tabster Tabster instance\n   * @param element The element the tabster context should represent\n   * @param options Additional options\n   * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations\n   */\n  static getTabsterContext(tabster, element, options = {}) {\n    var _a, _b, _c, _d;\n    if (!element.ownerDocument) {\n      return undefined;\n    }\n    const {\n      checkRtl,\n      referenceElement\n    } = options;\n    const getParent = tabster.getParent;\n    // Normally, the initialization starts on the next tick after the tabster\n    // instance creation. However, if the application starts using it before\n    // the next tick, we need to make sure the initialization is done.\n    tabster.drainInitQueue();\n    let root;\n    let modalizer;\n    let groupper;\n    let mover;\n    let excludedFromMover = false;\n    let groupperBeforeMover;\n    let modalizerInGroupper;\n    let dirRightToLeft;\n    let uncontrolled;\n    let curElement = referenceElement || element;\n    const ignoreKeydown = {};\n    while (curElement && (!root || checkRtl)) {\n      const tabsterOnElement = getTabsterOnElement(tabster, curElement);\n      if (checkRtl && dirRightToLeft === undefined) {\n        const dir = curElement.dir;\n        if (dir) {\n          dirRightToLeft = dir.toLowerCase() === \"rtl\";\n        }\n      }\n      if (!tabsterOnElement) {\n        curElement = getParent(curElement);\n        continue;\n      }\n      const tagName = curElement.tagName;\n      if ((tabsterOnElement.uncontrolled || tagName === \"IFRAME\" || tagName === \"WEBVIEW\") && tabster.focusable.isVisible(curElement)) {\n        uncontrolled = curElement;\n      }\n      if (!mover && ((_a = tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.excludeFromMover) && !groupper) {\n        excludedFromMover = true;\n      }\n      const curModalizer = tabsterOnElement.modalizer;\n      const curGroupper = tabsterOnElement.groupper;\n      const curMover = tabsterOnElement.mover;\n      if (!modalizer && curModalizer) {\n        modalizer = curModalizer;\n      }\n      if (!groupper && curGroupper && (!modalizer || curModalizer)) {\n        if (modalizer) {\n          // Modalizer dominates the groupper when they are on the same node and the groupper is active.\n          if (!curGroupper.isActive() && curGroupper.getProps().tabbability && modalizer.userId !== ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n            modalizer = undefined;\n            groupper = curGroupper;\n          }\n          modalizerInGroupper = curGroupper;\n        } else {\n          groupper = curGroupper;\n        }\n      }\n      if (!mover && curMover && (!modalizer || curModalizer) && (!curGroupper || curElement !== element) && curElement.contains(element) // Mover makes sense only for really inside elements, not for virutal out of the DOM order children.\n      ) {\n        mover = curMover;\n        groupperBeforeMover = !!groupper && groupper !== curGroupper;\n      }\n      if (tabsterOnElement.root) {\n        root = tabsterOnElement.root;\n      }\n      if ((_c = tabsterOnElement.focusable) === null || _c === void 0 ? void 0 : _c.ignoreKeydown) {\n        Object.assign(ignoreKeydown, tabsterOnElement.focusable.ignoreKeydown);\n      }\n      curElement = getParent(curElement);\n    }\n    // No root element could be found, try to get an auto root\n    if (!root) {\n      const rootAPI = tabster.root;\n      const autoRoot = rootAPI._autoRoot;\n      if (autoRoot) {\n        if ((_d = element.ownerDocument) === null || _d === void 0 ? void 0 : _d.body) {\n          root = rootAPI._autoRootCreate();\n        }\n      }\n    }\n    if (groupper && !mover) {\n      groupperBeforeMover = true;\n    }\n    if ( true && !root) {\n      if (modalizer || groupper || mover) {\n        console.error(\"Tabster Root is required for Mover, Groupper and Modalizer to work.\");\n      }\n    }\n    const shouldIgnoreKeydown = event => !!ignoreKeydown[event.key];\n    return root ? {\n      root,\n      modalizer,\n      groupper,\n      mover,\n      groupperBeforeMover,\n      modalizerInGroupper,\n      rtl: checkRtl ? !!dirRightToLeft : undefined,\n      uncontrolled,\n      excludedFromMover,\n      ignoreKeydown: shouldIgnoreKeydown\n    } : undefined;\n  }\n  static getRoot(tabster, element) {\n    var _a;\n    const getParent = tabster.getParent;\n    for (let el = element; el; el = getParent(el)) {\n      const root = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.root;\n      if (root) {\n        return root;\n      }\n    }\n    return undefined;\n  }\n  onRoot(root, removed) {\n    if (removed) {\n      delete this.rootById[root.uid];\n    } else {\n      this.rootById[root.uid] = root;\n    }\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst _containerHistoryLength = 10;\nclass DeloserItemBase {}\nclass DeloserItem extends DeloserItemBase {\n  constructor(tabster, deloser) {\n    super();\n    this.uid = deloser.uid;\n    this._tabster = tabster;\n    this._deloser = deloser;\n  }\n  belongsTo(deloser) {\n    return deloser === this._deloser;\n  }\n  unshift(element) {\n    this._deloser.unshift(element);\n  }\n  async focusAvailable() {\n    const available = this._deloser.findAvailable();\n    const deloserElement = this._deloser.getElement();\n    if (available && deloserElement) {\n      if (!deloserElement.dispatchEvent(new TabsterMoveFocusEvent({\n        by: \"deloser\",\n        owner: deloserElement,\n        next: available\n      }))) {\n        // Default action is prevented, don't look further.\n        return null;\n      }\n      return this._tabster.focusedElement.focus(available);\n    }\n    return false;\n  }\n  async resetFocus() {\n    const getWindow = this._tabster.getWindow;\n    return getPromise(getWindow).resolve(this._deloser.resetFocus());\n  }\n}\nclass DeloserHistoryByRootBase {\n  constructor(tabster, rootUId) {\n    this._history = [];\n    this._tabster = tabster;\n    this.rootUId = rootUId;\n  }\n  getLength() {\n    return this._history.length;\n  }\n  removeDeloser(deloser) {\n    this._history = this._history.filter(c => !c.belongsTo(deloser));\n  }\n  hasDeloser(deloser) {\n    return this._history.some(d => d.belongsTo(deloser));\n  }\n}\nclass DeloserHistoryByRoot extends DeloserHistoryByRootBase {\n  unshiftToDeloser(deloser, element) {\n    let item;\n    for (let i = 0; i < this._history.length; i++) {\n      if (this._history[i].belongsTo(deloser)) {\n        item = this._history[i];\n        this._history.splice(i, 1);\n        break;\n      }\n    }\n    if (!item) {\n      item = new DeloserItem(this._tabster, deloser);\n    }\n    item.unshift(element);\n    this._history.unshift(item);\n    this._history.splice(_containerHistoryLength, this._history.length - _containerHistoryLength);\n  }\n  async focusAvailable(from) {\n    let skip = !!from;\n    for (const i of this._history) {\n      if (from && i.belongsTo(from)) {\n        skip = false;\n      }\n      if (!skip) {\n        const result = await i.focusAvailable();\n        // Result is null when the default action is prevented by the application\n        // and we don't need to look further.\n        if (result || result === null) {\n          return result;\n        }\n      }\n    }\n    return false;\n  }\n  async resetFocus(from) {\n    let skip = !!from;\n    const resetQueue = {};\n    for (const i of this._history) {\n      if (from && i.belongsTo(from)) {\n        skip = false;\n      }\n      if (!skip && !resetQueue[i.uid]) {\n        resetQueue[i.uid] = i;\n      }\n    }\n    // Nothing is found, at least try to reset.\n    for (const id of Object.keys(resetQueue)) {\n      if (await resetQueue[id].resetFocus()) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nclass DeloserHistory {\n  constructor(tabster) {\n    this._history = [];\n    this._tabster = tabster;\n  }\n  dispose() {\n    this._history = [];\n  }\n  process(element) {\n    var _a;\n    const ctx = RootAPI.getTabsterContext(this._tabster, element);\n    const rootUId = ctx && ctx.root.uid;\n    const deloser = DeloserAPI.getDeloser(this._tabster, element);\n    if (!rootUId || !deloser) {\n      return undefined;\n    }\n    const historyByRoot = this.make(rootUId, () => new DeloserHistoryByRoot(this._tabster, rootUId));\n    if (!ctx || !ctx.modalizer || ((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.isActive())) {\n      historyByRoot.unshiftToDeloser(deloser, element);\n    }\n    return deloser;\n  }\n  make(rootUId, createInstance) {\n    let historyByRoot;\n    for (let i = 0; i < this._history.length; i++) {\n      const hbr = this._history[i];\n      if (hbr.rootUId === rootUId) {\n        historyByRoot = hbr;\n        this._history.splice(i, 1);\n        break;\n      }\n    }\n    if (!historyByRoot) {\n      historyByRoot = createInstance();\n    }\n    this._history.unshift(historyByRoot);\n    this._history.splice(_containerHistoryLength, this._history.length - _containerHistoryLength);\n    return historyByRoot;\n  }\n  removeDeloser(deloser) {\n    this._history.forEach(i => {\n      i.removeDeloser(deloser);\n    });\n    this._history = this._history.filter(i => i.getLength() > 0);\n  }\n  async focusAvailable(from) {\n    let skip = !!from;\n    for (const h of this._history) {\n      if (from && h.hasDeloser(from)) {\n        skip = false;\n      }\n      if (!skip) {\n        const result = await h.focusAvailable(from);\n        // Result is null when the default action is prevented by the application\n        // and we don't need to look further.\n        if (result || result === null) {\n          return result;\n        }\n      }\n    }\n    return false;\n  }\n  async resetFocus(from) {\n    let skip = !!from;\n    for (const h of this._history) {\n      if (from && h.hasDeloser(from)) {\n        skip = false;\n      }\n      if (!skip && (await h.resetFocus(from))) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction _setInformativeStyle$2(weakElement, remove, isActive, snapshotIndex) {\n  if (true) {\n    const element = weakElement.get();\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-deloser\");\n      } else {\n        element.style.setProperty(\"--tabster-deloser\", (isActive ? \"active\" : \"inactive\") + \",\" + (\"snapshot-\" + snapshotIndex));\n      }\n    }\n  }\n}\nfunction buildElementSelector(element, withClass, withIndex) {\n  const selector = [];\n  const escapeRegExp = /(:|\\.|\\[|\\]|,|=|@)/g;\n  const escapeReplaceValue = \"\\\\$1\";\n  const elementId = element.getAttribute(\"id\");\n  if (elementId) {\n    selector.push(\"#\" + elementId.replace(escapeRegExp, escapeReplaceValue));\n  }\n  if (withClass !== false && element.className) {\n    element.className.split(\" \").forEach(cls => {\n      cls = cls.trim();\n      if (cls) {\n        selector.push(\".\" + cls.replace(escapeRegExp, escapeReplaceValue));\n      }\n    });\n  }\n  let index = 0;\n  let el;\n  if (withIndex !== false && selector.length === 0) {\n    el = element;\n    while (el) {\n      index++;\n      el = el.previousElementSibling;\n    }\n    selector.unshift(\":nth-child(\" + index + \")\");\n  }\n  selector.unshift(element.tagName.toLowerCase());\n  return selector.join(\"\");\n}\nfunction buildSelector(element) {\n  if (!documentContains(element.ownerDocument, element)) {\n    return undefined;\n  }\n  const selector = [buildElementSelector(element)];\n  let node = dom.getParentNode(element);\n  while (node && node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n    // Stop at the shadow root as cross shadow selectors won't work.\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const isBody = node.tagName === \"BODY\";\n      selector.unshift(buildElementSelector(node, false, !isBody));\n      if (isBody) {\n        break;\n      }\n    }\n    node = dom.getParentNode(node);\n  }\n  return selector.join(\" \");\n}\nclass Deloser extends TabsterPart {\n  constructor(tabster, element, onDispose, props) {\n    super(tabster, element, props);\n    this._isActive = false;\n    this._history = [[]];\n    this._snapshotIndex = 0;\n    this.isActive = () => {\n      return this._isActive;\n    };\n    this.setSnapshot = index => {\n      this._snapshotIndex = index;\n      if (this._history.length > index + 1) {\n        this._history.splice(index + 1, this._history.length - index - 1);\n      }\n      if (!this._history[index]) {\n        this._history[index] = [];\n      }\n      if (true) {\n        _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n      }\n    };\n    this.focusFirst = () => {\n      const e = this._element.get();\n      return !!e && this._tabster.focusedElement.focusFirst({\n        container: e\n      });\n    };\n    this.focusDefault = () => {\n      const e = this._element.get();\n      return !!e && this._tabster.focusedElement.focusDefault(e);\n    };\n    this.resetFocus = () => {\n      const e = this._element.get();\n      return !!e && this._tabster.focusedElement.resetFocus(e);\n    };\n    this.clearHistory = preserveExisting => {\n      const element = this._element.get();\n      if (!element) {\n        this._history[this._snapshotIndex] = [];\n        return;\n      }\n      this._history[this._snapshotIndex] = this._history[this._snapshotIndex].filter(we => {\n        const e = we.get();\n        return e && preserveExisting ? dom.nodeContains(element, e) : false;\n      });\n    };\n    this.uid = getElementUId(tabster.getWindow, element);\n    this.strategy = props.strategy || DeloserStrategies.Auto;\n    this._onDispose = onDispose;\n    if (true) {\n      _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n    }\n  }\n  dispose() {\n    this._remove();\n    this._onDispose(this);\n    this._isActive = false;\n    this._snapshotIndex = 0;\n    this._props = {};\n    this._history = [];\n  }\n  setActive(active) {\n    this._isActive = active;\n    if (true) {\n      _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n    }\n  }\n  getActions() {\n    return {\n      focusDefault: this.focusDefault,\n      focusFirst: this.focusFirst,\n      resetFocus: this.resetFocus,\n      clearHistory: this.clearHistory,\n      setSnapshot: this.setSnapshot,\n      isActive: this.isActive\n    };\n  }\n  unshift(element) {\n    let cur = this._history[this._snapshotIndex];\n    cur = this._history[this._snapshotIndex] = cur.filter(we => {\n      const e = we.get();\n      return e && e !== element;\n    });\n    cur.unshift(new WeakHTMLElement(this._tabster.getWindow, element, buildSelector(element)));\n    while (cur.length > _containerHistoryLength) {\n      cur.pop();\n    }\n  }\n  findAvailable() {\n    const element = this._element.get();\n    if (!element || !this._tabster.focusable.isVisible(element)) {\n      return null;\n    }\n    let restoreFocusOrder = this._props.restoreFocusOrder;\n    let available = null;\n    const ctx = RootAPI.getTabsterContext(this._tabster, element);\n    if (!ctx) {\n      return null;\n    }\n    const root = ctx.root;\n    const rootElement = root.getElement();\n    if (!rootElement) {\n      return null;\n    }\n    if (restoreFocusOrder === undefined) {\n      restoreFocusOrder = root.getProps().restoreFocusOrder;\n    }\n    if (restoreFocusOrder === RestoreFocusOrders.RootDefault) {\n      available = this._tabster.focusable.findDefault({\n        container: rootElement\n      });\n    }\n    if (!available && restoreFocusOrder === RestoreFocusOrders.RootFirst) {\n      available = this._findFirst(rootElement);\n    }\n    if (available) {\n      return available;\n    }\n    const availableInHistory = this._findInHistory();\n    if (availableInHistory && restoreFocusOrder === RestoreFocusOrders.History) {\n      return availableInHistory;\n    }\n    const availableDefault = this._tabster.focusable.findDefault({\n      container: element\n    });\n    if (availableDefault && restoreFocusOrder === RestoreFocusOrders.DeloserDefault) {\n      return availableDefault;\n    }\n    const availableFirst = this._findFirst(element);\n    if (availableFirst && restoreFocusOrder === RestoreFocusOrders.DeloserFirst) {\n      return availableFirst;\n    }\n    return availableDefault || availableInHistory || availableFirst || null;\n  }\n  customFocusLostHandler(element) {\n    return element.dispatchEvent(new DeloserFocusLostEvent(this.getActions()));\n  }\n  _findInHistory() {\n    const cur = this._history[this._snapshotIndex].slice(0);\n    this.clearHistory(true);\n    for (let i = 0; i < cur.length; i++) {\n      const we = cur[i];\n      const e = we.get();\n      const element = this._element.get();\n      if (e && element && dom.nodeContains(element, e)) {\n        if (this._tabster.focusable.isFocusable(e)) {\n          return e;\n        }\n      } else if (!this._props.noSelectorCheck) {\n        // Element is not in the DOM, try to locate the node by it's\n        // selector. This might return not exactly the right node,\n        // but it would be easily fixable by having more detailed selectors.\n        const selector = we.getData();\n        if (selector && element) {\n          let els;\n          try {\n            els = dom.querySelectorAll(element.ownerDocument, selector);\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          } catch (e) {\n            if (true) {\n              // This should never happen, unless there is some bug in buildElementSelector().\n              console.error(`Failed to querySelectorAll('${selector}')`);\n            }\n            continue;\n          }\n          for (let i = 0; i < els.length; i++) {\n            const el = els[i];\n            if (el && this._tabster.focusable.isFocusable(el)) {\n              return el;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n  _findFirst(element) {\n    if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n      const first = this._tabster.focusable.findFirst({\n        container: element,\n        useActiveModalizer: true\n      });\n      if (first) {\n        return first;\n      }\n    }\n    return null;\n  }\n  _remove() {\n    if (true) {\n      _setInformativeStyle$2(this._element, true);\n    }\n  }\n}\nclass DeloserAPI {\n  constructor(tabster, props) {\n    /**\n     * Tracks if focus is inside a deloser\n     */\n    this._inDeloser = false;\n    this._isRestoringFocus = false;\n    this._isPaused = false;\n    this._onRestoreFocus = event => {\n      var _a;\n      const target = event.composedPath()[0];\n      if (target) {\n        const available = (_a = DeloserAPI.getDeloser(this._tabster, target)) === null || _a === void 0 ? void 0 : _a.findAvailable();\n        if (available) {\n          this._tabster.focusedElement.focus(available);\n        }\n        event.stopImmediatePropagation();\n      }\n    };\n    this._onFocus = e => {\n      if (this._restoreFocusTimer) {\n        this._win().clearTimeout(this._restoreFocusTimer);\n        this._restoreFocusTimer = undefined;\n      }\n      if (!e) {\n        this._scheduleRestoreFocus();\n        return;\n      }\n      const deloser = this._history.process(e);\n      if (deloser) {\n        this._activate(deloser);\n      } else {\n        this._deactivate();\n      }\n    };\n    this._onDeloserDispose = deloser => {\n      this._history.removeDeloser(deloser);\n      if (deloser.isActive()) {\n        this._scheduleRestoreFocus();\n      }\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._history = new DeloserHistory(tabster);\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n      const doc = this._win().document;\n      doc.addEventListener(DeloserRestoreFocusEventName, this._onRestoreFocus);\n      const activeElement = dom.getActiveElement(doc);\n      if (activeElement && activeElement !== doc.body) {\n        // Adding currently focused element to the deloser history.\n        this._onFocus(activeElement);\n      }\n    });\n    const autoDeloser = props === null || props === void 0 ? void 0 : props.autoDeloser;\n    if (autoDeloser) {\n      this._autoDeloser = autoDeloser;\n    }\n  }\n  dispose() {\n    const win = this._win();\n    if (this._restoreFocusTimer) {\n      win.clearTimeout(this._restoreFocusTimer);\n      this._restoreFocusTimer = undefined;\n    }\n    if (this._autoDeloserInstance) {\n      this._autoDeloserInstance.dispose();\n      delete this._autoDeloserInstance;\n      delete this._autoDeloser;\n    }\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n    win.document.removeEventListener(DeloserRestoreFocusEventName, this._onRestoreFocus);\n    this._history.dispose();\n    delete this._curDeloser;\n  }\n  createDeloser(element, props) {\n    var _a;\n    if (true) ;\n    const deloser = new Deloser(this._tabster, element, this._onDeloserDispose, props);\n    if (dom.nodeContains(element, (_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null)) {\n      this._activate(deloser);\n    }\n    return deloser;\n  }\n  getActions(element) {\n    for (let e = element; e; e = dom.getParentElement(e)) {\n      const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n      if (tabsterOnElement && tabsterOnElement.deloser) {\n        return tabsterOnElement.deloser.getActions();\n      }\n    }\n    return undefined;\n  }\n  pause() {\n    this._isPaused = true;\n    if (this._restoreFocusTimer) {\n      this._win().clearTimeout(this._restoreFocusTimer);\n      this._restoreFocusTimer = undefined;\n    }\n  }\n  resume(restore) {\n    this._isPaused = false;\n    if (restore) {\n      this._scheduleRestoreFocus();\n    }\n  }\n  /**\n   * Activates and sets the current deloser\n   */\n  _activate(deloser) {\n    const curDeloser = this._curDeloser;\n    if (curDeloser !== deloser) {\n      this._inDeloser = true;\n      curDeloser === null || curDeloser === void 0 ? void 0 : curDeloser.setActive(false);\n      deloser.setActive(true);\n      this._curDeloser = deloser;\n    }\n  }\n  /**\n   * Called when focus should no longer be in a deloser\n   */\n  _deactivate() {\n    var _a;\n    this._inDeloser = false;\n    (_a = this._curDeloser) === null || _a === void 0 ? void 0 : _a.setActive(false);\n    this._curDeloser = undefined;\n  }\n  _scheduleRestoreFocus(force) {\n    if (this._isPaused || this._isRestoringFocus) {\n      return;\n    }\n    const restoreFocus = async () => {\n      this._restoreFocusTimer = undefined;\n      const lastFocused = this._tabster.focusedElement.getLastFocusedElement();\n      if (!force && (this._isRestoringFocus || !this._inDeloser || lastFocused && !isDisplayNone(lastFocused))) {\n        return;\n      }\n      const curDeloser = this._curDeloser;\n      let isManual = false;\n      if (curDeloser) {\n        if (lastFocused && curDeloser.customFocusLostHandler(lastFocused)) {\n          return;\n        }\n        if (curDeloser.strategy === DeloserStrategies.Manual) {\n          isManual = true;\n        } else {\n          const curDeloserElement = curDeloser.getElement();\n          const el = curDeloser.findAvailable();\n          if (el && (!(curDeloserElement === null || curDeloserElement === void 0 ? void 0 : curDeloserElement.dispatchEvent(new TabsterMoveFocusEvent({\n            by: \"deloser\",\n            owner: curDeloserElement,\n            next: el\n          }))) || this._tabster.focusedElement.focus(el))) {\n            return;\n          }\n        }\n      }\n      this._deactivate();\n      if (isManual) {\n        return;\n      }\n      this._isRestoringFocus = true;\n      // focusAvailable returns null when the default action is prevented by the application, false\n      // when nothing was focused and true when something was focused.\n      if ((await this._history.focusAvailable(null)) === false) {\n        await this._history.resetFocus(null);\n      }\n      this._isRestoringFocus = false;\n    };\n    if (force) {\n      restoreFocus();\n    } else {\n      this._restoreFocusTimer = this._win().setTimeout(restoreFocus, 100);\n    }\n  }\n  static getDeloser(tabster, element) {\n    var _a;\n    let root;\n    for (let e = element; e; e = dom.getParentElement(e)) {\n      const tabsterOnElement = getTabsterOnElement(tabster, e);\n      if (tabsterOnElement) {\n        if (!root) {\n          root = tabsterOnElement.root;\n        }\n        const deloser = tabsterOnElement.deloser;\n        if (deloser) {\n          return deloser;\n        }\n      }\n    }\n    const deloserAPI = tabster.deloser && tabster.deloser;\n    if (deloserAPI) {\n      if (deloserAPI._autoDeloserInstance) {\n        return deloserAPI._autoDeloserInstance;\n      }\n      const autoDeloserProps = deloserAPI._autoDeloser;\n      if (root && !deloserAPI._autoDeloserInstance && autoDeloserProps) {\n        const body = (_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.body;\n        if (body) {\n          deloserAPI._autoDeloserInstance = new Deloser(tabster, body, tabster.deloser._onDeloserDispose, autoDeloserProps);\n        }\n      }\n      return deloserAPI._autoDeloserInstance;\n    }\n    return undefined;\n  }\n  static getHistory(instance) {\n    return instance._history;\n  }\n  static forceRestoreFocus(instance) {\n    instance._scheduleRestoreFocus(true);\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass Subscribable {\n  constructor() {\n    this._callbacks = [];\n  }\n  dispose() {\n    this._callbacks = [];\n    delete this._val;\n  }\n  subscribe(callback) {\n    const callbacks = this._callbacks;\n    const index = callbacks.indexOf(callback);\n    if (index < 0) {\n      callbacks.push(callback);\n    }\n  }\n  subscribeFirst(callback) {\n    const callbacks = this._callbacks;\n    const index = callbacks.indexOf(callback);\n    if (index >= 0) {\n      callbacks.splice(index, 1);\n    }\n    callbacks.unshift(callback);\n  }\n  unsubscribe(callback) {\n    const index = this._callbacks.indexOf(callback);\n    if (index >= 0) {\n      this._callbacks.splice(index, 1);\n    }\n  }\n  setVal(val, detail) {\n    if (this._val === val) {\n      return;\n    }\n    this._val = val;\n    this._callCallbacks(val, detail);\n  }\n  getVal() {\n    return this._val;\n  }\n  trigger(val, detail) {\n    this._callCallbacks(val, detail);\n  }\n  _callCallbacks(val, detail) {\n    this._callbacks.forEach(callback => callback(val, detail));\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst _transactionTimeout = 1500;\nconst _pingTimeout = 3000;\nconst _targetIdUp = \"up\";\nconst CrossOriginTransactionTypes = {\n  Bootstrap: 1,\n  FocusElement: 2,\n  State: 3,\n  GetElement: 4,\n  RestoreFocusInDeloser: 5,\n  Ping: 6\n};\nclass CrossOriginDeloserItem extends DeloserItemBase {\n  constructor(tabster, deloser, trasactions) {\n    super();\n    this._deloser = deloser;\n    this._transactions = trasactions;\n  }\n  belongsTo(deloser) {\n    return deloser.deloserUId === this._deloser.deloserUId;\n  }\n  async focusAvailable() {\n    const data = {\n      ...this._deloser,\n      reset: false\n    };\n    return this._transactions.beginTransaction(RestoreFocusInDeloserTransaction, data).then(value => !!value);\n  }\n  async resetFocus() {\n    const data = {\n      ...this._deloser,\n      reset: true\n    };\n    return this._transactions.beginTransaction(RestoreFocusInDeloserTransaction, data).then(value => !!value);\n  }\n}\nclass CrossOriginDeloserHistoryByRoot extends DeloserHistoryByRootBase {\n  constructor(tabster, rootUId, transactions) {\n    super(tabster, rootUId);\n    this._transactions = transactions;\n  }\n  unshift(deloser) {\n    let item;\n    for (let i = 0; i < this._history.length; i++) {\n      if (this._history[i].belongsTo(deloser)) {\n        item = this._history[i];\n        this._history.splice(i, 1);\n        break;\n      }\n    }\n    if (!item) {\n      item = new CrossOriginDeloserItem(this._tabster, deloser, this._transactions);\n    }\n    this._history.unshift(item);\n    this._history.splice(10, this._history.length - 10);\n  }\n  async focusAvailable() {\n    for (const i of this._history) {\n      if (await i.focusAvailable()) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async resetFocus() {\n    for (const i of this._history) {\n      if (await i.resetFocus()) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\nclass CrossOriginTransaction {\n  constructor(tabster, getOwner, knownTargets, value, timeout, sentTo, targetId, sendUp) {\n    this._inProgress = {};\n    this._isDone = false;\n    this._isSelfResponding = false;\n    this._sentCount = 0;\n    this.tabster = tabster;\n    this.owner = getOwner;\n    this.ownerId = getWindowUId(getOwner());\n    this.id = getUId(getOwner());\n    this.beginData = value;\n    this._knownTargets = knownTargets;\n    this._sentTo = sentTo || {\n      [this.ownerId]: true\n    };\n    this.targetId = targetId;\n    this.sendUp = sendUp;\n    this.timeout = timeout;\n    this._promise = new (getPromise(getOwner))((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n  getTargets(knownTargets) {\n    return this.targetId === _targetIdUp ? this.sendUp ? {\n      [_targetIdUp]: {\n        send: this.sendUp\n      }\n    } : null : this.targetId ? knownTargets[this.targetId] ? {\n      [this.targetId]: {\n        send: knownTargets[this.targetId].send\n      }\n    } : null : Object.keys(knownTargets).length === 0 && this.sendUp ? {\n      [_targetIdUp]: {\n        send: this.sendUp\n      }\n    } : Object.keys(knownTargets).length > 0 ? knownTargets : null;\n  }\n  begin(selfResponse) {\n    const targets = this.getTargets(this._knownTargets);\n    const sentTo = {\n      ...this._sentTo\n    };\n    if (targets) {\n      for (const id of Object.keys(targets)) {\n        sentTo[id] = true;\n      }\n    }\n    const data = {\n      transaction: this.id,\n      type: this.type,\n      isResponse: false,\n      timestamp: Date.now(),\n      owner: this.ownerId,\n      sentto: sentTo,\n      timeout: this.timeout,\n      beginData: this.beginData\n    };\n    if (this.targetId) {\n      data.target = this.targetId;\n    }\n    if (selfResponse) {\n      this._isSelfResponding = true;\n      selfResponse(data).then(value => {\n        this._isSelfResponding = false;\n        if (value !== undefined) {\n          if (!this.endData) {\n            this.endData = value;\n          }\n        }\n        if (this.endData || this._sentCount === 0) {\n          this.end();\n        }\n      });\n    }\n    if (targets) {\n      for (const id of Object.keys(targets)) {\n        if (!(id in this._sentTo)) {\n          this._send(targets[id].send, id, data);\n        }\n      }\n    }\n    if (this._sentCount === 0 && !this._isSelfResponding) {\n      this.end();\n    }\n    return this._promise;\n  }\n  _send(send, targetId, data) {\n    if (this._inProgress[targetId] === undefined) {\n      this._inProgress[targetId] = true;\n      this._sentCount++;\n      send(data);\n    }\n  }\n  end(error) {\n    if (this._isDone) {\n      return;\n    }\n    this._isDone = true;\n    if (this.endData === undefined && error) {\n      if (this._reject) {\n        this._reject(error);\n      }\n    } else if (this._resolve) {\n      this._resolve(this.endData);\n    }\n  }\n  onResponse(data) {\n    const endData = data.endData;\n    if (endData !== undefined && !this.endData) {\n      this.endData = endData;\n    }\n    const inProgressId = data.target === _targetIdUp ? _targetIdUp : data.owner;\n    if (this._inProgress[inProgressId]) {\n      this._inProgress[inProgressId] = false;\n      this._sentCount--;\n      if (this.endData || this._sentCount === 0 && !this._isSelfResponding) {\n        this.end();\n      }\n    }\n  }\n}\nclass BootstrapTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.Bootstrap;\n  }\n  static shouldForward() {\n    return false;\n  }\n  static async makeResponse(tabster) {\n    return {\n      isNavigatingWithKeyboard: tabster.keyboardNavigation.isNavigatingWithKeyboard()\n    };\n  }\n}\nclass FocusElementTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.FocusElement;\n  }\n  static shouldSelfRespond() {\n    return true;\n  }\n  static shouldForward(tabster, data, getOwner) {\n    const el = GetElementTransaction.findElement(tabster, getOwner, data.beginData);\n    return !el || !tabster.focusable.isFocusable(el);\n  }\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult) {\n    const el = GetElementTransaction.findElement(tabster, getOwner, data.beginData);\n    return !!el && tabster.focusedElement.focus(el, true) || !!(await forwardResult);\n  }\n}\nconst CrossOriginStates = {\n  Focused: 1,\n  Blurred: 2,\n  Observed: 3,\n  DeadWindow: 4,\n  KeyboardNavigation: 5,\n  Outline: 6\n};\nclass StateTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.State;\n  }\n  static shouldSelfRespond(tabster, data) {\n    return data.state !== CrossOriginStates.DeadWindow && data.state !== CrossOriginStates.KeyboardNavigation;\n  }\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult, isSelfResponse) {\n    const timestamp = data.timestamp;\n    const beginData = data.beginData;\n    if (timestamp && beginData) {\n      switch (beginData.state) {\n        case CrossOriginStates.Focused:\n          return StateTransaction._makeFocusedResponse(tabster, timestamp, beginData, transactions, isSelfResponse);\n        case CrossOriginStates.Blurred:\n          return StateTransaction._makeBlurredResponse(tabster, timestamp, beginData, transactions.ctx);\n        case CrossOriginStates.Observed:\n          return StateTransaction._makeObservedResponse(tabster, beginData);\n        case CrossOriginStates.DeadWindow:\n          return StateTransaction._makeDeadWindowResponse(tabster, beginData, transactions, forwardResult);\n        case CrossOriginStates.KeyboardNavigation:\n          return StateTransaction._makeKeyboardNavigationResponse(tabster, transactions.ctx, beginData.isNavigatingWithKeyboard);\n        case CrossOriginStates.Outline:\n          return StateTransaction._makeOutlineResponse(tabster, transactions.ctx, beginData.outline);\n      }\n    }\n    return true;\n  }\n  static createElement(tabster, beginData) {\n    return beginData.uid ? new CrossOriginElement(tabster, beginData.uid, beginData.ownerUId, beginData.id, beginData.rootUId, beginData.observedName, beginData.observedDetails) : null;\n  }\n  static async _makeFocusedResponse(tabster, timestamp, beginData, transactions, isSelfResponse) {\n    const element = StateTransaction.createElement(tabster, beginData);\n    if (beginData && beginData.ownerUId && element) {\n      transactions.ctx.focusOwner = beginData.ownerUId;\n      transactions.ctx.focusOwnerTimestamp = timestamp;\n      if (!isSelfResponse && beginData.rootUId && beginData.deloserUId) {\n        const deloserAPI = tabster.deloser;\n        if (deloserAPI) {\n          const history = DeloserAPI.getHistory(deloserAPI);\n          const deloser = {\n            ownerUId: beginData.ownerUId,\n            deloserUId: beginData.deloserUId,\n            rootUId: beginData.rootUId\n          };\n          const historyItem = history.make(beginData.rootUId, () => new CrossOriginDeloserHistoryByRoot(tabster, deloser.rootUId, transactions));\n          historyItem.unshift(deloser);\n        }\n      }\n      CrossOriginFocusedElementState.setVal(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.focusedElement, element, {\n        isFocusedProgrammatically: beginData.isFocusedProgrammatically\n      });\n    }\n    return true;\n  }\n  static async _makeBlurredResponse(tabster, timestamp, beginData, context) {\n    if (beginData && (beginData.ownerUId === context.focusOwner || beginData.force) && (!context.focusOwnerTimestamp || context.focusOwnerTimestamp < timestamp)) {\n      CrossOriginFocusedElementState.setVal(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.focusedElement, undefined, {});\n    }\n    return true;\n  }\n  static async _makeObservedResponse(tabster, beginData) {\n    const name = beginData.observedName;\n    const element = StateTransaction.createElement(tabster, beginData);\n    if (name && element) {\n      CrossOriginObservedElementState.trigger(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.observedElement, element, {\n        names: [name],\n        details: beginData.observedDetails\n      });\n    }\n    return true;\n  }\n  static async _makeDeadWindowResponse(tabster, beginData, transactions, forwardResult) {\n    const deadUId = beginData && beginData.ownerUId;\n    if (deadUId) {\n      transactions.removeTarget(deadUId);\n    }\n    return forwardResult.then(() => {\n      if (deadUId === transactions.ctx.focusOwner) {\n        const deloserAPI = tabster.deloser;\n        if (deloserAPI) {\n          DeloserAPI.forceRestoreFocus(deloserAPI);\n        }\n      }\n      return true;\n    });\n  }\n  static async _makeKeyboardNavigationResponse(tabster, context, isNavigatingWithKeyboard) {\n    if (isNavigatingWithKeyboard !== undefined && tabster.keyboardNavigation.isNavigatingWithKeyboard() !== isNavigatingWithKeyboard) {\n      context.ignoreKeyboardNavigationStateUpdate = true;\n      tabster.keyboardNavigation.setNavigatingWithKeyboard(isNavigatingWithKeyboard);\n      context.ignoreKeyboardNavigationStateUpdate = false;\n    }\n    return true;\n  }\n  static async _makeOutlineResponse(tabster, context, props) {\n    if (context.origOutlineSetup) {\n      context.origOutlineSetup.call(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.outline, props);\n    }\n    return true;\n  }\n}\nclass GetElementTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.GetElement;\n  }\n  static shouldSelfRespond() {\n    return true;\n  }\n  static findElement(tabster, getOwner, data) {\n    let element;\n    if (data && (!data.ownerId || data.ownerId === getWindowUId(getOwner()))) {\n      if (data.id) {\n        element = dom.getElementById(getOwner().document, data.id);\n        if (element && data.rootId) {\n          const ctx = RootAPI.getTabsterContext(tabster, element);\n          if (!ctx || ctx.root.uid !== data.rootId) {\n            return null;\n          }\n        }\n      } else if (data.uid) {\n        const ref = getInstanceContext(getOwner).elementByUId[data.uid];\n        element = ref && ref.get();\n      } else if (data.observedName) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        element = tabster.observedElement.getElement(data.observedName, data.accessibility);\n      }\n    }\n    return element || null;\n  }\n  static getElementData(tabster, element, getOwner, context, ownerUId) {\n    const deloser = DeloserAPI.getDeloser(tabster, element);\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    const tabsterOnElement = getTabsterOnElement(tabster, element);\n    const observed = tabsterOnElement && tabsterOnElement.observed;\n    return {\n      uid: getElementUId(getOwner, element),\n      ownerUId,\n      id: element.id || undefined,\n      rootUId: ctx ? ctx.root.uid : undefined,\n      deloserUId: deloser ? getDeloserUID(getOwner, context, deloser) : undefined,\n      observedName: observed && observed.names && observed.names[0],\n      observedDetails: observed && observed.details\n    };\n  }\n  static async makeResponse(tabster, data, getOwner, ownerUId, transactions, forwardResult) {\n    const beginData = data.beginData;\n    let element;\n    let dataOut;\n    if (beginData === undefined) {\n      element = tabster.focusedElement.getFocusedElement();\n    } else if (beginData) {\n      element = GetElementTransaction.findElement(tabster, getOwner, beginData) || undefined;\n    }\n    if (!element && beginData) {\n      const name = beginData.observedName;\n      const timeout = data.timeout;\n      const accessibility = beginData.accessibility;\n      if (name && timeout) {\n        const e = await new (getPromise(getOwner))(resolve => {\n          let isWaitElementResolved = false;\n          let isForwardResolved = false;\n          let isResolved = false;\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          tabster.observedElement.waitElement(name, timeout, accessibility).result.then(value => {\n            isWaitElementResolved = true;\n            if (!isResolved && (value || isForwardResolved)) {\n              isResolved = true;\n              resolve({\n                element: value\n              });\n            }\n          });\n          forwardResult.then(value => {\n            isForwardResolved = true;\n            if (!isResolved && (value || isWaitElementResolved)) {\n              isResolved = true;\n              resolve({\n                crossOrigin: value\n              });\n            }\n          });\n        });\n        if (e.element) {\n          element = e.element;\n        } else if (e.crossOrigin) {\n          dataOut = e.crossOrigin;\n        }\n      }\n    }\n    return element ? GetElementTransaction.getElementData(tabster, element, getOwner, transactions.ctx, ownerUId) : dataOut;\n  }\n}\nclass RestoreFocusInDeloserTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.RestoreFocusInDeloser;\n  }\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult) {\n    const forwardRet = await forwardResult;\n    const begin = !forwardRet && data.beginData;\n    const uid = begin && begin.deloserUId;\n    const deloser = uid && transactions.ctx.deloserByUId[uid];\n    const deloserAPI = tabster.deloser;\n    if (begin && deloser && deloserAPI) {\n      const history = DeloserAPI.getHistory(deloserAPI);\n      return begin.reset ? history.resetFocus(deloser) : history.focusAvailable(deloser);\n    }\n    return !!forwardRet;\n  }\n}\nclass PingTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.Ping;\n  }\n  static shouldForward() {\n    return false;\n  }\n  static async makeResponse() {\n    return true;\n  }\n}\nclass CrossOriginTransactions {\n  constructor(tabster, getOwner, context) {\n    this._knownTargets = {};\n    this._transactions = {};\n    this._isDefaultSendUp = false;\n    this.isSetUp = false;\n    this._onMessage = e => {\n      if (e.data.owner === this._ownerUId || !this._tabster) {\n        return;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const data = e.data;\n      let transactionId;\n      if (!data || !(transactionId = data.transaction) || !data.type || !data.timestamp || !data.owner || !data.sentto) {\n        return;\n      }\n      let knownTarget = this._knownTargets[data.owner];\n      if (!knownTarget && e.send && data.owner !== this._ownerUId) {\n        knownTarget = this._knownTargets[data.owner] = {\n          send: e.send\n        };\n      }\n      if (knownTarget) {\n        knownTarget.last = Date.now();\n      }\n      if (data.isResponse) {\n        const t = this._transactions[transactionId];\n        if (t && t.transaction && t.transaction.type === data.type) {\n          t.transaction.onResponse(data);\n        }\n      } else {\n        const Transaction = this._getTransactionClass(data.type);\n        const forwardResult = this.forwardTransaction(data);\n        if (Transaction && e.send) {\n          Transaction.makeResponse(this._tabster, data, this._owner, this._ownerUId, this, forwardResult, false).then(r => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const response = {\n              transaction: data.transaction,\n              type: data.type,\n              isResponse: true,\n              timestamp: Date.now(),\n              owner: this._ownerUId,\n              timeout: data.timeout,\n              sentto: {},\n              target: data.target === _targetIdUp ? _targetIdUp : data.owner,\n              endData: r\n            };\n            e.send(response);\n          });\n        }\n      }\n    };\n    this._onPageHide = () => {\n      this._dead();\n    };\n    this._onBrowserMessage = e => {\n      if (e.source === this._owner()) {\n        return;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const send = data => {\n        if (e.source && e.source.postMessage) {\n          e.source.postMessage(JSON.stringify(data), \"*\");\n        }\n      };\n      try {\n        this._onMessage({\n          data: JSON.parse(e.data),\n          send\n        });\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      } catch (e) {\n        /* Ignore */\n      }\n    };\n    this._tabster = tabster;\n    this._owner = getOwner;\n    this._ownerUId = getWindowUId(getOwner());\n    this.ctx = context;\n  }\n  setup(sendUp) {\n    if (this.isSetUp) {\n      if (true) {\n        console.error(\"CrossOrigin is already set up.\");\n      }\n    } else {\n      this.isSetUp = true;\n      this.setSendUp(sendUp);\n      this._owner().addEventListener(\"pagehide\", this._onPageHide);\n      this._ping();\n    }\n    return this._onMessage;\n  }\n  setSendUp(sendUp) {\n    if (!this.isSetUp) {\n      throw new Error(\"CrossOrigin is not set up.\");\n    }\n    this.sendUp = sendUp || undefined;\n    const owner = this._owner();\n    if (sendUp === undefined) {\n      if (!this._isDefaultSendUp) {\n        if (owner.document) {\n          this._isDefaultSendUp = true;\n          if (owner.parent && owner.parent !== owner && owner.parent.postMessage) {\n            this.sendUp = (\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            data) => {\n              owner.parent.postMessage(JSON.stringify(data), \"*\");\n            };\n          }\n          owner.addEventListener(\"message\", this._onBrowserMessage);\n        }\n      }\n    } else if (this._isDefaultSendUp) {\n      owner.removeEventListener(\"message\", this._onBrowserMessage);\n      this._isDefaultSendUp = false;\n    }\n    return this._onMessage;\n  }\n  async dispose() {\n    const owner = this._owner();\n    if (this._pingTimer) {\n      owner.clearTimeout(this._pingTimer);\n      this._pingTimer = undefined;\n    }\n    owner.removeEventListener(\"message\", this._onBrowserMessage);\n    owner.removeEventListener(\"pagehide\", this._onPageHide);\n    await this._dead();\n    delete this._deadPromise;\n    for (const id of Object.keys(this._transactions)) {\n      const t = this._transactions[id];\n      if (t.timer) {\n        owner.clearTimeout(t.timer);\n        delete t.timer;\n      }\n      t.transaction.end();\n    }\n    this._knownTargets = {};\n    delete this.sendUp;\n  }\n  beginTransaction(Transaction, value, timeout, sentTo, targetId, withReject) {\n    if (!this._owner) {\n      return getPromise(this._owner).reject();\n    }\n    const transaction = new Transaction(this._tabster, this._owner, this._knownTargets, value, timeout, sentTo, targetId, this.sendUp);\n    let selfResponse;\n    if (Transaction.shouldSelfRespond && Transaction.shouldSelfRespond(this._tabster, value, this._owner, this._ownerUId)) {\n      selfResponse = data => {\n        return Transaction.makeResponse(this._tabster, data, this._owner, this._ownerUId, this, getPromise(this._owner).resolve(undefined), true);\n      };\n    }\n    return this._beginTransaction(transaction, timeout, selfResponse, withReject);\n  }\n  removeTarget(uid) {\n    delete this._knownTargets[uid];\n  }\n  _beginTransaction(transaction, timeout, selfResponse, withReject) {\n    const owner = this._owner();\n    const wrapper = {\n      transaction,\n      timer: owner.setTimeout(() => {\n        delete wrapper.timer;\n        transaction.end(\"Cross origin transaction timed out.\");\n      }, _transactionTimeout + (timeout || 0))\n    };\n    this._transactions[transaction.id] = wrapper;\n    const ret = transaction.begin(selfResponse);\n    ret.catch(() => {\n      /**/\n    }).finally(() => {\n      if (wrapper.timer) {\n        owner.clearTimeout(wrapper.timer);\n      }\n      delete this._transactions[transaction.id];\n    });\n    return ret.then(value => value, withReject ? undefined : () => undefined);\n  }\n  forwardTransaction(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    const owner = this._owner;\n    let targetId = data.target;\n    if (targetId === this._ownerUId) {\n      return getPromise(owner).resolve();\n    }\n    const Transaction = this._getTransactionClass(data.type);\n    if (Transaction) {\n      if (Transaction.shouldForward === undefined || Transaction.shouldForward(this._tabster, data, owner, this._ownerUId)) {\n        const sentTo = data.sentto;\n        if (targetId === _targetIdUp) {\n          targetId = undefined;\n          sentTo[this._ownerUId] = true;\n        }\n        delete sentTo[_targetIdUp];\n        return this._beginTransaction(new Transaction(this._tabster, owner, this._knownTargets, data.beginData, data.timeout, sentTo, targetId, this.sendUp), data.timeout);\n      } else {\n        return getPromise(owner).resolve();\n      }\n    }\n    return getPromise(owner).reject(`Unknown transaction type ${data.type}`);\n  }\n  _getTransactionClass(type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    switch (type) {\n      case CrossOriginTransactionTypes.Bootstrap:\n        return BootstrapTransaction;\n      case CrossOriginTransactionTypes.FocusElement:\n        return FocusElementTransaction;\n      case CrossOriginTransactionTypes.State:\n        return StateTransaction;\n      case CrossOriginTransactionTypes.GetElement:\n        return GetElementTransaction;\n      case CrossOriginTransactionTypes.RestoreFocusInDeloser:\n        return RestoreFocusInDeloserTransaction;\n      case CrossOriginTransactionTypes.Ping:\n        return PingTransaction;\n      default:\n        return null;\n    }\n  }\n  async _dead() {\n    if (!this._deadPromise && this.ctx.focusOwner === this._ownerUId) {\n      this._deadPromise = this.beginTransaction(StateTransaction, {\n        ownerUId: this._ownerUId,\n        state: CrossOriginStates.DeadWindow\n      });\n    }\n    if (this._deadPromise) {\n      await this._deadPromise;\n    }\n  }\n  async _ping() {\n    if (this._pingTimer) {\n      return;\n    }\n    let deadWindows;\n    const now = Date.now();\n    const targets = Object.keys(this._knownTargets).filter(uid => now - (this._knownTargets[uid].last || 0) > _pingTimeout);\n    if (this.sendUp) {\n      targets.push(_targetIdUp);\n    }\n    if (targets.length) {\n      await getPromise(this._owner).all(targets.map(uid => this.beginTransaction(PingTransaction, undefined, undefined, undefined, uid, true).then(() => true, () => {\n        if (uid !== _targetIdUp) {\n          if (!deadWindows) {\n            deadWindows = {};\n          }\n          deadWindows[uid] = true;\n          delete this._knownTargets[uid];\n        }\n        return false;\n      })));\n    }\n    if (deadWindows) {\n      const focused = await this.beginTransaction(GetElementTransaction, undefined);\n      if (!focused && this.ctx.focusOwner && this.ctx.focusOwner in deadWindows) {\n        await this.beginTransaction(StateTransaction, {\n          ownerUId: this._ownerUId,\n          state: CrossOriginStates.Blurred,\n          force: true\n        });\n        const deloserAPI = this._tabster.deloser;\n        if (deloserAPI) {\n          DeloserAPI.forceRestoreFocus(deloserAPI);\n        }\n      }\n    }\n    this._pingTimer = this._owner().setTimeout(() => {\n      this._pingTimer = undefined;\n      this._ping();\n    }, _pingTimeout);\n  }\n}\nclass CrossOriginElement {\n  constructor(tabster, uid, ownerId, id, rootId, observedName, observedDetails) {\n    this._tabster = tabster;\n    this.uid = uid;\n    this.ownerId = ownerId;\n    this.id = id;\n    this.rootId = rootId;\n    this.observedName = observedName;\n    this.observedDetails = observedDetails;\n  }\n  focus(noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._tabster.crossOrigin.focusedElement.focus(this, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n}\nclass CrossOriginFocusedElementState extends Subscribable {\n  constructor(transactions) {\n    super();\n    this._transactions = transactions;\n  }\n  async focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      uid: element.uid,\n      id: element.id,\n      rootId: element.rootId,\n      ownerId: element.ownerId,\n      observedName: element.observedName\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n  async focusById(elementId, rootId, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      id: elementId,\n      rootId\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n  async focusByObservedName(observedName, timeout, rootId, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      observedName,\n      rootId\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck, timeout);\n  }\n  async _focus(elementData, noFocusedProgrammaticallyFlag, noAccessibleCheck, timeout) {\n    return this._transactions.beginTransaction(FocusElementTransaction, {\n      ...elementData,\n      noFocusedProgrammaticallyFlag,\n      noAccessibleCheck\n    }, timeout).then(value => !!value);\n  }\n  static setVal(instance, val, detail) {\n    instance.setVal(val, detail);\n  }\n}\nclass CrossOriginObservedElementState extends Subscribable {\n  constructor(tabster, transactions) {\n    super();\n    this._lastRequestFocusId = 0;\n    this._tabster = tabster;\n    this._transactions = transactions;\n  }\n  async getElement(observedName, accessibility) {\n    return this.waitElement(observedName, 0, accessibility);\n  }\n  async waitElement(observedName, timeout, accessibility) {\n    return this._transactions.beginTransaction(GetElementTransaction, {\n      observedName,\n      accessibility\n    }, timeout).then(value => value ? StateTransaction.createElement(this._tabster, value) : null);\n  }\n  async requestFocus(observedName, timeout) {\n    const requestId = ++this._lastRequestFocusId;\n    return this.waitElement(observedName, timeout, ObservedElementAccessibilities.Focusable).then(element => this._lastRequestFocusId === requestId && element ?\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this._tabster.crossOrigin.focusedElement.focus(element, true) : false);\n  }\n  static trigger(instance, element, details) {\n    instance.trigger(element, details);\n  }\n}\nclass CrossOriginAPI {\n  constructor(tabster) {\n    this._init = () => {\n      const tabster = this._tabster;\n      tabster.keyboardNavigation.subscribe(this._onKeyboardNavigationStateChanged);\n      tabster.focusedElement.subscribe(this._onFocus);\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.observedElement.subscribe(this._onObserved);\n      if (!this._ctx.origOutlineSetup) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this._ctx.origOutlineSetup = tabster.outline.setup;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        tabster.outline.setup = this._outlineSetup;\n      }\n      this._transactions.beginTransaction(BootstrapTransaction, undefined, undefined, undefined, _targetIdUp).then(data => {\n        if (data && this._tabster.keyboardNavigation.isNavigatingWithKeyboard() !== data.isNavigatingWithKeyboard) {\n          this._ctx.ignoreKeyboardNavigationStateUpdate = true;\n          this._tabster.keyboardNavigation.setNavigatingWithKeyboard(data.isNavigatingWithKeyboard);\n          this._ctx.ignoreKeyboardNavigationStateUpdate = false;\n        }\n      });\n    };\n    this._onKeyboardNavigationStateChanged = value => {\n      if (!this._ctx.ignoreKeyboardNavigationStateUpdate) {\n        this._transactions.beginTransaction(StateTransaction, {\n          state: CrossOriginStates.KeyboardNavigation,\n          ownerUId: getWindowUId(this._win()),\n          isNavigatingWithKeyboard: value\n        });\n      }\n    };\n    this._onFocus = element => {\n      const win = this._win();\n      const ownerUId = getWindowUId(win);\n      if (this._blurTimer) {\n        win.clearTimeout(this._blurTimer);\n        this._blurTimer = undefined;\n      }\n      if (element) {\n        this._transactions.beginTransaction(StateTransaction, {\n          ...GetElementTransaction.getElementData(this._tabster, element, this._win, this._ctx, ownerUId),\n          state: CrossOriginStates.Focused\n        });\n      } else {\n        this._blurTimer = win.setTimeout(() => {\n          this._blurTimer = undefined;\n          if (this._ctx.focusOwner && this._ctx.focusOwner === ownerUId) {\n            this._transactions.beginTransaction(GetElementTransaction, undefined).then(value => {\n              if (!value && this._ctx.focusOwner === ownerUId) {\n                this._transactions.beginTransaction(StateTransaction, {\n                  ownerUId,\n                  state: CrossOriginStates.Blurred,\n                  force: false\n                });\n              }\n            });\n          }\n        }, 0);\n      }\n    };\n    this._onObserved = (element, details) => {\n      var _a;\n      const d = GetElementTransaction.getElementData(this._tabster, element, this._win, this._ctx, getWindowUId(this._win()));\n      d.state = CrossOriginStates.Observed;\n      d.observedName = (_a = details.names) === null || _a === void 0 ? void 0 : _a[0];\n      d.observedDetails = details.details;\n      this._transactions.beginTransaction(StateTransaction, d);\n    };\n    this._outlineSetup = props => {\n      this._transactions.beginTransaction(StateTransaction, {\n        state: CrossOriginStates.Outline,\n        ownerUId: getWindowUId(this._win()),\n        outline: props\n      });\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._ctx = {\n      ignoreKeyboardNavigationStateUpdate: false,\n      deloserByUId: {}\n    };\n    this._transactions = new CrossOriginTransactions(tabster, this._win, this._ctx);\n    this.focusedElement = new CrossOriginFocusedElementState(this._transactions);\n    this.observedElement = new CrossOriginObservedElementState(tabster, this._transactions);\n  }\n  setup(sendUp) {\n    if (this.isSetUp()) {\n      return this._transactions.setSendUp(sendUp);\n    } else {\n      this._tabster.queueInit(this._init);\n      return this._transactions.setup(sendUp);\n    }\n  }\n  isSetUp() {\n    return this._transactions.isSetUp;\n  }\n  dispose() {\n    var _a;\n    const tabster = this._tabster;\n    tabster.keyboardNavigation.unsubscribe(this._onKeyboardNavigationStateChanged);\n    tabster.focusedElement.unsubscribe(this._onFocus);\n    (_a = tabster.observedElement) === null || _a === void 0 ? void 0 : _a.unsubscribe(this._onObserved);\n    this._transactions.dispose();\n    this.focusedElement.dispose();\n    this.observedElement.dispose();\n    this._ctx.deloserByUId = {};\n  }\n}\nfunction getDeloserUID(getWindow, context, deloser) {\n  const deloserElement = deloser.getElement();\n  if (deloserElement) {\n    const uid = getElementUId(getWindow, deloserElement);\n    if (!context.deloserByUId[uid]) {\n      context.deloserByUId[uid] = deloser;\n    }\n    return uid;\n  }\n  return undefined;\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass FocusableAPI {\n  constructor(tabster) {\n    this._tabster = tabster;\n  }\n  dispose() {\n    /**/\n  }\n  getProps(element) {\n    const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n    return tabsterOnElement && tabsterOnElement.focusable || {};\n  }\n  isFocusable(el, includeProgrammaticallyFocusable, noVisibleCheck, noAccessibleCheck) {\n    if (matchesSelector(el, FOCUSABLE_SELECTOR) && (includeProgrammaticallyFocusable || el.tabIndex !== -1)) {\n      return (noVisibleCheck || this.isVisible(el)) && (noAccessibleCheck || this.isAccessible(el));\n    }\n    return false;\n  }\n  isVisible(el) {\n    if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {\n      return false;\n    }\n    if (isDisplayNone(el)) {\n      return false;\n    }\n    const rect = el.ownerDocument.body.getBoundingClientRect();\n    if (rect.width === 0 && rect.height === 0) {\n      // This might happen, for example, if our <body> is in hidden <iframe>.\n      return false;\n    }\n    return true;\n  }\n  isAccessible(el) {\n    var _a;\n    for (let e = el; e; e = dom.getParentElement(e)) {\n      const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n      if (this._isHidden(e)) {\n        return false;\n      }\n      const ignoreDisabled = (_a = tabsterOnElement === null || tabsterOnElement === void 0 ? void 0 : tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.ignoreAriaDisabled;\n      if (!ignoreDisabled && this._isDisabled(e)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _isDisabled(el) {\n    return el.hasAttribute(\"disabled\");\n  }\n  _isHidden(el) {\n    var _a;\n    const attrVal = el.getAttribute(\"aria-hidden\");\n    if (attrVal && attrVal.toLowerCase() === \"true\") {\n      if (!((_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.isAugmented(el))) {\n        return true;\n      }\n    }\n    return false;\n  }\n  findFirst(options, out) {\n    return this.findElement({\n      ...options\n    }, out);\n  }\n  findLast(options, out) {\n    return this.findElement({\n      isBackward: true,\n      ...options\n    }, out);\n  }\n  findNext(options, out) {\n    return this.findElement({\n      ...options\n    }, out);\n  }\n  findPrev(options, out) {\n    return this.findElement({\n      ...options,\n      isBackward: true\n    }, out);\n  }\n  findDefault(options, out) {\n    return this.findElement({\n      ...options,\n      acceptCondition: el => this.isFocusable(el, options.includeProgrammaticallyFocusable) && !!this.getProps(el).isDefault\n    }, out) || null;\n  }\n  findAll(options) {\n    return this._findElements(true, options) || [];\n  }\n  findElement(options, out) {\n    const found = this._findElements(false, options, out);\n    return found ? found[0] : found;\n  }\n  _findElements(isFindAll, options, out) {\n    var _a, _b, _c;\n    const {\n      container,\n      currentElement = null,\n      includeProgrammaticallyFocusable,\n      useActiveModalizer,\n      ignoreAccessibility,\n      modalizerId,\n      isBackward,\n      onElement\n    } = options;\n    if (!out) {\n      out = {};\n    }\n    const elements = [];\n    let {\n      acceptCondition\n    } = options;\n    const hasCustomCondition = !!acceptCondition;\n    if (!container) {\n      return null;\n    }\n    if (!acceptCondition) {\n      acceptCondition = el => this.isFocusable(el, includeProgrammaticallyFocusable, false, ignoreAccessibility);\n    }\n    const acceptElementState = {\n      container,\n      modalizerUserId: modalizerId === undefined && useActiveModalizer ? (_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.activeId : modalizerId || ((_c = (_b = RootAPI.getTabsterContext(this._tabster, container)) === null || _b === void 0 ? void 0 : _b.modalizer) === null || _c === void 0 ? void 0 : _c.userId),\n      from: currentElement || container,\n      isBackward,\n      isFindAll,\n      acceptCondition,\n      hasCustomCondition,\n      includeProgrammaticallyFocusable,\n      ignoreAccessibility,\n      cachedGrouppers: {},\n      cachedRadioGroups: {}\n    };\n    const walker = createElementTreeWalker(container.ownerDocument, container, node => this._acceptElement(node, acceptElementState));\n    if (!walker) {\n      return null;\n    }\n    const prepareForNextElement = shouldContinueIfNotFound => {\n      var _a, _b;\n      const foundElement = (_a = acceptElementState.foundElement) !== null && _a !== void 0 ? _a : acceptElementState.foundBackward;\n      if (foundElement) {\n        elements.push(foundElement);\n      }\n      if (isFindAll) {\n        if (foundElement) {\n          acceptElementState.found = false;\n          delete acceptElementState.foundElement;\n          delete acceptElementState.foundBackward;\n          delete acceptElementState.fromCtx;\n          acceptElementState.from = foundElement;\n          if (onElement && !onElement(foundElement)) {\n            return false;\n          }\n        }\n        return !!(foundElement || shouldContinueIfNotFound);\n      } else {\n        if (foundElement && out) {\n          out.uncontrolled = (_b = RootAPI.getTabsterContext(this._tabster, foundElement)) === null || _b === void 0 ? void 0 : _b.uncontrolled;\n        }\n        return !!(shouldContinueIfNotFound && !foundElement);\n      }\n    };\n    if (!currentElement) {\n      out.outOfDOMOrder = true;\n    }\n    if (currentElement && dom.nodeContains(container, currentElement)) {\n      walker.currentNode = currentElement;\n    } else if (isBackward) {\n      const lastChild = getLastChild$2(container);\n      if (!lastChild) {\n        return null;\n      }\n      if (this._acceptElement(lastChild, acceptElementState) === NodeFilter.FILTER_ACCEPT && !prepareForNextElement(true)) {\n        if (acceptElementState.skippedFocusable) {\n          out.outOfDOMOrder = true;\n        }\n        return elements;\n      }\n      walker.currentNode = lastChild;\n    }\n    do {\n      if (isBackward) {\n        walker.previousNode();\n      } else {\n        walker.nextNode();\n      }\n    } while (prepareForNextElement());\n    if (acceptElementState.skippedFocusable) {\n      out.outOfDOMOrder = true;\n    }\n    return elements.length ? elements : null;\n  }\n  _acceptElement(element, state) {\n    var _a, _b, _c;\n    if (state.found) {\n      return NodeFilter.FILTER_ACCEPT;\n    }\n    const foundBackward = state.foundBackward;\n    if (foundBackward && (element === foundBackward || !dom.nodeContains(foundBackward, element))) {\n      state.found = true;\n      state.foundElement = foundBackward;\n      return NodeFilter.FILTER_ACCEPT;\n    }\n    const container = state.container;\n    if (element === container) {\n      return NodeFilter.FILTER_SKIP;\n    }\n    if (!dom.nodeContains(container, element)) {\n      return NodeFilter.FILTER_REJECT;\n    }\n    if (getDummyInputContainer(element)) {\n      return NodeFilter.FILTER_REJECT;\n    }\n    if (dom.nodeContains(state.rejectElementsFrom, element)) {\n      return NodeFilter.FILTER_REJECT;\n    }\n    const ctx = state.currentCtx = RootAPI.getTabsterContext(this._tabster, element);\n    // Tabster is opt in, if it is not managed, don't try and get do anything special\n    if (!ctx) {\n      return NodeFilter.FILTER_SKIP;\n    }\n    if (shouldIgnoreFocus(element)) {\n      if (this.isFocusable(element, undefined, true, true)) {\n        state.skippedFocusable = true;\n      }\n      return NodeFilter.FILTER_SKIP;\n    }\n    // We assume iframes are focusable because native tab behaviour would tab inside.\n    // But we do it only during the standard search when there is no custom accept\n    // element condition.\n    if (!state.hasCustomCondition && (element.tagName === \"IFRAME\" || element.tagName === \"WEBVIEW\")) {\n      if (this.isVisible(element) && ((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.userId) === ((_b = this._tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n        state.found = true;\n        state.rejectElementsFrom = state.foundElement = element;\n        return NodeFilter.FILTER_ACCEPT;\n      } else {\n        return NodeFilter.FILTER_REJECT;\n      }\n    }\n    if (!state.ignoreAccessibility && !this.isAccessible(element)) {\n      if (this.isFocusable(element, false, true, true)) {\n        state.skippedFocusable = true;\n      }\n      return NodeFilter.FILTER_REJECT;\n    }\n    let result;\n    let fromCtx = state.fromCtx;\n    if (!fromCtx) {\n      fromCtx = state.fromCtx = RootAPI.getTabsterContext(this._tabster, state.from);\n    }\n    const fromMover = fromCtx === null || fromCtx === void 0 ? void 0 : fromCtx.mover;\n    let groupper = ctx.groupper;\n    let mover = ctx.mover;\n    result = (_c = this._tabster.modalizer) === null || _c === void 0 ? void 0 : _c.acceptElement(element, state);\n    if (result !== undefined) {\n      state.skippedFocusable = true;\n    }\n    if (result === undefined && (groupper || mover || fromMover)) {\n      const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();\n      const fromMoverElement = fromMover === null || fromMover === void 0 ? void 0 : fromMover.getElement();\n      let moverElement = mover === null || mover === void 0 ? void 0 : mover.getElement();\n      if (moverElement && dom.nodeContains(fromMoverElement, moverElement) && dom.nodeContains(container, fromMoverElement) && (!groupperElement || !mover || dom.nodeContains(fromMoverElement, groupperElement))) {\n        mover = fromMover;\n        moverElement = fromMoverElement;\n      }\n      if (groupperElement) {\n        if (groupperElement === container || !dom.nodeContains(container, groupperElement)) {\n          groupper = undefined;\n        } else if (!dom.nodeContains(groupperElement, element)) {\n          // _acceptElement() callback is called during the tree walking.\n          // Given the potentiality of virtual parents (driven by the custom getParent() function),\n          // we need to make sure that the groupper from the current element's context is not,\n          // portaling us out of the DOM order.\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n      if (moverElement) {\n        if (!dom.nodeContains(container, moverElement)) {\n          mover = undefined;\n        } else if (!dom.nodeContains(moverElement, element)) {\n          // _acceptElement() callback is called during the tree walking.\n          // Given the potentiality of virtual parents (driven by the custom getParent() function),\n          // we need to make sure that the mover from the current element's context is not,\n          // portaling us out of the DOM order.\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n      if (groupper && mover) {\n        if (moverElement && groupperElement && !dom.nodeContains(groupperElement, moverElement)) {\n          mover = undefined;\n        } else {\n          groupper = undefined;\n        }\n      }\n      if (groupper) {\n        result = groupper.acceptElement(element, state);\n      }\n      if (mover) {\n        result = mover.acceptElement(element, state);\n      }\n    }\n    if (result === undefined) {\n      result = state.acceptCondition(element) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n      if (result === NodeFilter.FILTER_SKIP && this.isFocusable(element, false, true, true)) {\n        state.skippedFocusable = true;\n      }\n    }\n    if (result === NodeFilter.FILTER_ACCEPT && !state.found) {\n      if (!state.isFindAll && isRadio(element) && !element.checked) {\n        // We need to mimic the browser's behaviour to skip unchecked radio buttons.\n        const radioGroupName = element.name;\n        let radioGroup = state.cachedRadioGroups[radioGroupName];\n        if (!radioGroup) {\n          radioGroup = getRadioButtonGroup(element);\n          if (radioGroup) {\n            state.cachedRadioGroups[radioGroupName] = radioGroup;\n          }\n        }\n        if ((radioGroup === null || radioGroup === void 0 ? void 0 : radioGroup.checked) && radioGroup.checked !== element) {\n          // Currently found element is a radio button in a group that has another radio button checked.\n          return NodeFilter.FILTER_SKIP;\n        }\n      }\n      if (state.isBackward) {\n        // When TreeWalker goes backwards, it visits the container first,\n        // then it goes inside. So, if the container is accepted, we remember it,\n        // but allowing the TreeWalker to check inside.\n        state.foundBackward = element;\n        result = NodeFilter.FILTER_SKIP;\n      } else {\n        state.found = true;\n        state.foundElement = element;\n      }\n    }\n    return result;\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst Keys = {\n  Tab: \"Tab\",\n  Enter: \"Enter\",\n  Escape: \"Escape\",\n  PageUp: \"PageUp\",\n  PageDown: \"PageDown\",\n  End: \"End\",\n  Home: \"Home\",\n  ArrowLeft: \"ArrowLeft\",\n  ArrowUp: \"ArrowUp\",\n  ArrowRight: \"ArrowRight\",\n  ArrowDown: \"ArrowDown\"\n};\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction getUncontrolledCompletelyContainer(tabster, element) {\n  var _a;\n  const getParent = tabster.getParent;\n  let el = element;\n  do {\n    const uncontrolledOnElement = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.uncontrolled;\n    if (uncontrolledOnElement && tabster.uncontrolled.isUncontrolledCompletely(el, !!uncontrolledOnElement.completely)) {\n      return el;\n    }\n    el = getParent(el);\n  } while (el);\n  return undefined;\n}\nconst AsyncFocusIntentPriorityBySource = {\n  [AsyncFocusSources.Restorer]: 0,\n  [AsyncFocusSources.Deloser]: 1,\n  [AsyncFocusSources.EscapeGroupper]: 2\n};\nclass FocusedElementState extends Subscribable {\n  constructor(tabster, getWindow) {\n    super();\n    this._init = () => {\n      const win = this._win();\n      const doc = win.document;\n      // Add these event listeners as capture - we want Tabster to run before user event handlers\n      doc.addEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.KEYBORG_FOCUSIN, this._onFocusIn, true);\n      doc.addEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.KEYBORG_FOCUSOUT, this._onFocusOut, true);\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n      const activeElement = dom.getActiveElement(doc);\n      if (activeElement && activeElement !== doc.body) {\n        this._setFocusedElement(activeElement);\n      }\n      this.subscribe(this._onChanged);\n    };\n    this._onFocusIn = e => {\n      const target = e.composedPath()[0];\n      if (target) {\n        this._setFocusedElement(target, e.detail.relatedTarget, e.detail.isFocusedProgrammatically);\n      }\n    };\n    this._onFocusOut = e => {\n      var _a;\n      this._setFocusedElement(undefined, (_a = e.detail) === null || _a === void 0 ? void 0 : _a.originalEvent.relatedTarget);\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._validateFocusedElement = element => {\n      // TODO: Make sure this is not needed anymore and write tests.\n    };\n    this._onKeyDown = event => {\n      if (event.key !== Keys.Tab || event.ctrlKey) {\n        return;\n      }\n      const currentElement = this.getVal();\n      if (!currentElement || !currentElement.ownerDocument || currentElement.contentEditable === \"true\") {\n        return;\n      }\n      const tabster = this._tabster;\n      const controlTab = tabster.controlTab;\n      const ctx = RootAPI.getTabsterContext(tabster, currentElement);\n      if (!ctx || ctx.ignoreKeydown(event)) {\n        return;\n      }\n      const isBackward = event.shiftKey;\n      const next = FocusedElementState.findNextTabbable(tabster, ctx, undefined, currentElement, undefined, isBackward, true);\n      const rootElement = ctx.root.getElement();\n      if (!rootElement) {\n        return;\n      }\n      const nextElement = next === null || next === void 0 ? void 0 : next.element;\n      const uncontrolledCompletelyContainer = getUncontrolledCompletelyContainer(tabster, currentElement);\n      if (nextElement) {\n        const nextUncontrolled = next.uncontrolled;\n        if (ctx.uncontrolled || dom.nodeContains(nextUncontrolled, currentElement)) {\n          if (!next.outOfDOMOrder && nextUncontrolled === ctx.uncontrolled || uncontrolledCompletelyContainer && !dom.nodeContains(uncontrolledCompletelyContainer, nextElement)) {\n            // Nothing to do, everything will be done by the browser or something\n            // that controls the uncontrolled area.\n            return;\n          }\n          // We are in uncontrolled area. We allow whatever controls it to move\n          // focus, but we add a phantom dummy to make sure the focus is moved\n          // to the correct place if the uncontrolled area allows default action.\n          // We only need that in the controlled mode, because in uncontrolled\n          // mode we have dummy inputs around everything that redirects focus.\n          DummyInputManager.addPhantomDummyWithTarget(tabster, currentElement, isBackward, nextElement);\n          return;\n        }\n        if (nextUncontrolled && tabster.focusable.isVisible(nextUncontrolled) || nextElement.tagName === \"IFRAME\" && tabster.focusable.isVisible(nextElement)) {\n          // For iframes and uncontrolled areas we always want to use default action to\n          // move focus into.\n          if (rootElement.dispatchEvent(new TabsterMoveFocusEvent({\n            by: \"root\",\n            owner: rootElement,\n            next: nextElement,\n            relatedEvent: event\n          }))) {\n            DummyInputManager.moveWithPhantomDummy(tabster, nextUncontrolled !== null && nextUncontrolled !== void 0 ? nextUncontrolled : nextElement, false, isBackward, event);\n          }\n          return;\n        }\n        if (controlTab || (next === null || next === void 0 ? void 0 : next.outOfDOMOrder)) {\n          if (rootElement.dispatchEvent(new TabsterMoveFocusEvent({\n            by: \"root\",\n            owner: rootElement,\n            next: nextElement,\n            relatedEvent: event\n          }))) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n            (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(nextElement);\n          }\n        }\n      } else {\n        if (!uncontrolledCompletelyContainer && rootElement.dispatchEvent(new TabsterMoveFocusEvent({\n          by: \"root\",\n          owner: rootElement,\n          next: null,\n          relatedEvent: event\n        }))) {\n          ctx.root.moveOutWithDefaultAction(isBackward, event);\n        }\n      }\n    };\n    this._onChanged = (element, detail) => {\n      var _a, _b;\n      if (element) {\n        element.dispatchEvent(new TabsterFocusInEvent(detail));\n      } else {\n        const last = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();\n        if (last) {\n          const d = {\n            ...detail\n          };\n          const lastCtx = RootAPI.getTabsterContext(this._tabster, last);\n          const modalizerId = (_b = lastCtx === null || lastCtx === void 0 ? void 0 : lastCtx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;\n          if (modalizerId) {\n            d.modalizerId = modalizerId;\n          }\n          last.dispatchEvent(new TabsterFocusOutEvent(d));\n        }\n      }\n    };\n    this._tabster = tabster;\n    this._win = getWindow;\n    tabster.queueInit(this._init);\n  }\n  dispose() {\n    super.dispose();\n    const win = this._win();\n    const doc = win.document;\n    doc.removeEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.KEYBORG_FOCUSIN, this._onFocusIn, true);\n    doc.removeEventListener(keyborg__WEBPACK_IMPORTED_MODULE_0__.KEYBORG_FOCUSOUT, this._onFocusOut, true);\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    this.unsubscribe(this._onChanged);\n    const asyncFocus = this._asyncFocus;\n    if (asyncFocus) {\n      win.clearTimeout(asyncFocus.timeout);\n      delete this._asyncFocus;\n    }\n    delete FocusedElementState._lastResetElement;\n    delete this._nextVal;\n    delete this._lastVal;\n  }\n  static forgetMemorized(instance, parent) {\n    var _a, _b;\n    let wel = FocusedElementState._lastResetElement;\n    let el = wel && wel.get();\n    if (el && dom.nodeContains(parent, el)) {\n      delete FocusedElementState._lastResetElement;\n    }\n    el = (_b = (_a = instance._nextVal) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.get();\n    if (el && dom.nodeContains(parent, el)) {\n      delete instance._nextVal;\n    }\n    wel = instance._lastVal;\n    el = wel && wel.get();\n    if (el && dom.nodeContains(parent, el)) {\n      delete instance._lastVal;\n    }\n  }\n  getFocusedElement() {\n    return this.getVal();\n  }\n  getLastFocusedElement() {\n    var _a;\n    let el = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();\n    if (!el || el && !documentContains(el.ownerDocument, el)) {\n      this._lastVal = el = undefined;\n    }\n    return el;\n  }\n  focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck, preventScroll) {\n    if (!this._tabster.focusable.isFocusable(element, noFocusedProgrammaticallyFlag, false, noAccessibleCheck)) {\n      return false;\n    }\n    element.focus({\n      preventScroll\n    });\n    return true;\n  }\n  focusDefault(container) {\n    const el = this._tabster.focusable.findDefault({\n      container\n    });\n    if (el) {\n      this._tabster.focusedElement.focus(el);\n      return true;\n    }\n    return false;\n  }\n  getFirstOrLastTabbable(isFirst, props) {\n    var _a;\n    const {\n      container,\n      ignoreAccessibility\n    } = props;\n    let toFocus;\n    if (container) {\n      const ctx = RootAPI.getTabsterContext(this._tabster, container);\n      if (ctx) {\n        toFocus = (_a = FocusedElementState.findNextTabbable(this._tabster, ctx, container, undefined, undefined, !isFirst, ignoreAccessibility)) === null || _a === void 0 ? void 0 : _a.element;\n      }\n    }\n    if (toFocus && !dom.nodeContains(container, toFocus)) {\n      toFocus = undefined;\n    }\n    return toFocus || undefined;\n  }\n  _focusFirstOrLast(isFirst, props) {\n    const toFocus = this.getFirstOrLastTabbable(isFirst, props);\n    if (toFocus) {\n      this.focus(toFocus, false, true);\n      return true;\n    }\n    return false;\n  }\n  focusFirst(props) {\n    return this._focusFirstOrLast(true, props);\n  }\n  focusLast(props) {\n    return this._focusFirstOrLast(false, props);\n  }\n  resetFocus(container) {\n    if (!this._tabster.focusable.isVisible(container)) {\n      return false;\n    }\n    if (!this._tabster.focusable.isFocusable(container, true, true, true)) {\n      const prevTabIndex = container.getAttribute(\"tabindex\");\n      const prevAriaHidden = container.getAttribute(\"aria-hidden\");\n      container.tabIndex = -1;\n      container.setAttribute(\"aria-hidden\", \"true\");\n      FocusedElementState._lastResetElement = new WeakHTMLElement(this._win, container);\n      this.focus(container, true, true);\n      this._setOrRemoveAttribute(container, \"tabindex\", prevTabIndex);\n      this._setOrRemoveAttribute(container, \"aria-hidden\", prevAriaHidden);\n    } else {\n      this.focus(container);\n    }\n    return true;\n  }\n  requestAsyncFocus(source, callback, delay) {\n    const win = this._tabster.getWindow();\n    const currentAsyncFocus = this._asyncFocus;\n    if (currentAsyncFocus) {\n      if (AsyncFocusIntentPriorityBySource[source] > AsyncFocusIntentPriorityBySource[currentAsyncFocus.source]) {\n        // Previously registered intent has higher priority.\n        return;\n      }\n      // New intent has higher priority.\n      win.clearTimeout(currentAsyncFocus.timeout);\n    }\n    this._asyncFocus = {\n      source,\n      callback,\n      timeout: win.setTimeout(() => {\n        this._asyncFocus = undefined;\n        callback();\n      }, delay)\n    };\n  }\n  cancelAsyncFocus(source) {\n    const asyncFocus = this._asyncFocus;\n    if ((asyncFocus === null || asyncFocus === void 0 ? void 0 : asyncFocus.source) === source) {\n      this._tabster.getWindow().clearTimeout(asyncFocus.timeout);\n      this._asyncFocus = undefined;\n    }\n  }\n  _setOrRemoveAttribute(element, name, value) {\n    if (value === null) {\n      element.removeAttribute(name);\n    } else {\n      element.setAttribute(name, value);\n    }\n  }\n  _setFocusedElement(element, relatedTarget, isFocusedProgrammatically) {\n    var _a, _b;\n    if (this._tabster._noop) {\n      return;\n    }\n    const detail = {\n      relatedTarget\n    };\n    if (element) {\n      const lastResetElement = (_a = FocusedElementState._lastResetElement) === null || _a === void 0 ? void 0 : _a.get();\n      FocusedElementState._lastResetElement = undefined;\n      if (lastResetElement === element || shouldIgnoreFocus(element)) {\n        return;\n      }\n      detail.isFocusedProgrammatically = isFocusedProgrammatically;\n      const ctx = RootAPI.getTabsterContext(this._tabster, element);\n      const modalizerId = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;\n      if (modalizerId) {\n        detail.modalizerId = modalizerId;\n      }\n    }\n    const nextVal = this._nextVal = {\n      element: element ? new WeakHTMLElement(this._win, element) : undefined,\n      detail\n    };\n    if (element && element !== this._val) {\n      this._validateFocusedElement(element);\n    }\n    // _validateFocusedElement() might cause the refocus which will trigger\n    // another call to this function. Making sure that the value is correct.\n    if (this._nextVal === nextVal) {\n      this.setVal(element, detail);\n    }\n    this._nextVal = undefined;\n  }\n  setVal(val, detail) {\n    super.setVal(val, detail);\n    if (val) {\n      this._lastVal = new WeakHTMLElement(this._win, val);\n    }\n  }\n  static findNextTabbable(tabster, ctx, container, currentElement, referenceElement, isBackward, ignoreAccessibility) {\n    const actualContainer = container || ctx.root.getElement();\n    if (!actualContainer) {\n      return null;\n    }\n    let next = null;\n    const isTabbingTimer = FocusedElementState._isTabbingTimer;\n    const win = tabster.getWindow();\n    if (isTabbingTimer) {\n      win.clearTimeout(isTabbingTimer);\n    }\n    FocusedElementState.isTabbing = true;\n    FocusedElementState._isTabbingTimer = win.setTimeout(() => {\n      delete FocusedElementState._isTabbingTimer;\n      FocusedElementState.isTabbing = false;\n    }, 0);\n    const modalizer = ctx.modalizer;\n    const groupper = ctx.groupper;\n    const mover = ctx.mover;\n    const callFindNext = what => {\n      next = what.findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility);\n      if (currentElement && !(next === null || next === void 0 ? void 0 : next.element)) {\n        const parentElement = what !== modalizer && dom.getParentElement(what.getElement());\n        if (parentElement) {\n          const parentCtx = RootAPI.getTabsterContext(tabster, currentElement, {\n            referenceElement: parentElement\n          });\n          if (parentCtx) {\n            const currentScopeElement = what.getElement();\n            const newCurrent = isBackward ? currentScopeElement : currentScopeElement && getLastChild$2(currentScopeElement) || currentScopeElement;\n            if (newCurrent) {\n              next = FocusedElementState.findNextTabbable(tabster, parentCtx, container, newCurrent, parentElement, isBackward, ignoreAccessibility);\n              if (next) {\n                next.outOfDOMOrder = true;\n              }\n            }\n          }\n        }\n      }\n    };\n    if (groupper && mover) {\n      callFindNext(ctx.groupperBeforeMover ? groupper : mover);\n    } else if (groupper) {\n      callFindNext(groupper);\n    } else if (mover) {\n      callFindNext(mover);\n    } else if (modalizer) {\n      callFindNext(modalizer);\n    } else {\n      const findProps = {\n        container: actualContainer,\n        currentElement,\n        referenceElement,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      };\n      const findPropsOut = {};\n      const nextElement = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](findProps, findPropsOut);\n      next = {\n        element: nextElement,\n        outOfDOMOrder: findPropsOut.outOfDOMOrder,\n        uncontrolled: findPropsOut.uncontrolled\n      };\n    }\n    return next;\n  }\n}\nFocusedElementState.isTabbing = false;\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass GroupperDummyManager extends DummyInputManager {\n  constructor(element, groupper, tabster, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Groupper, sys, true);\n    this._setHandlers((dummyInput, isBackward, relatedTarget) => {\n      var _a, _b;\n      const container = element.get();\n      const input = dummyInput.input;\n      if (container && input) {\n        const ctx = RootAPI.getTabsterContext(tabster, input);\n        if (ctx) {\n          let next;\n          next = (_a = groupper.findNextTabbable(relatedTarget || undefined, undefined, isBackward, true)) === null || _a === void 0 ? void 0 : _a.element;\n          if (!next) {\n            next = (_b = FocusedElementState.findNextTabbable(tabster, ctx, undefined, dummyInput.isOutside ? input : getAdjacentElement(container, !isBackward), undefined, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;\n          }\n          if (next) {\n            (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(next);\n          }\n        }\n      }\n    });\n  }\n}\nclass Groupper extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    super(tabster, element, props);\n    this._shouldTabInside = false;\n    this.makeTabbable(false);\n    this._onDispose = onDispose;\n    if (!tabster.controlTab) {\n      this.dummyManager = new GroupperDummyManager(this._element, this, tabster, sys);\n    }\n  }\n  dispose() {\n    var _a;\n    this._onDispose(this);\n    const element = this._element.get();\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    delete this.dummyManager;\n    if (element) {\n      if (true) {\n        _setInformativeStyle$1(this._element, true);\n      }\n    }\n    delete this._first;\n  }\n  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {\n    const groupperElement = this.getElement();\n    if (!groupperElement) {\n      return null;\n    }\n    const currentIsDummy = getDummyInputContainer(currentElement) === groupperElement;\n    if (!this._shouldTabInside && currentElement && dom.nodeContains(groupperElement, currentElement) && !currentIsDummy) {\n      return {\n        element: undefined,\n        outOfDOMOrder: true\n      };\n    }\n    const groupperFirstFocusable = this.getFirst(true);\n    if (!currentElement || !dom.nodeContains(groupperElement, currentElement) || currentIsDummy) {\n      return {\n        element: groupperFirstFocusable,\n        outOfDOMOrder: true\n      };\n    }\n    const tabster = this._tabster;\n    let next = null;\n    let outOfDOMOrder = false;\n    let uncontrolled;\n    if (this._shouldTabInside && groupperFirstFocusable) {\n      const findProps = {\n        container: groupperElement,\n        currentElement,\n        referenceElement,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      };\n      const findPropsOut = {};\n      next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](findProps, findPropsOut);\n      outOfDOMOrder = !!findPropsOut.outOfDOMOrder;\n      if (!next && this._props.tabbability === GroupperTabbabilities.LimitedTrapFocus) {\n        next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"]({\n          container: groupperElement,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        }, findPropsOut);\n        outOfDOMOrder = true;\n      }\n      uncontrolled = findPropsOut.uncontrolled;\n    }\n    return {\n      element: next,\n      uncontrolled,\n      outOfDOMOrder\n    };\n  }\n  makeTabbable(isTabbable) {\n    this._shouldTabInside = isTabbable || !this._props.tabbability;\n    if (true) {\n      _setInformativeStyle$1(this._element, !this._shouldTabInside);\n    }\n  }\n  isActive(noIfFirstIsFocused) {\n    var _a;\n    const element = this.getElement() || null;\n    let isParentActive = true;\n    for (let e = dom.getParentElement(element); e; e = dom.getParentElement(e)) {\n      const g = (_a = getTabsterOnElement(this._tabster, e)) === null || _a === void 0 ? void 0 : _a.groupper;\n      if (g) {\n        if (!g._shouldTabInside) {\n          isParentActive = false;\n        }\n      }\n    }\n    let ret = isParentActive ? this._props.tabbability ? this._shouldTabInside : false : undefined;\n    if (ret && noIfFirstIsFocused) {\n      const focused = this._tabster.focusedElement.getFocusedElement();\n      if (focused) {\n        ret = focused !== this.getFirst(true);\n      }\n    }\n    return ret;\n  }\n  getFirst(orContainer) {\n    var _a;\n    const groupperElement = this.getElement();\n    let first;\n    if (groupperElement) {\n      if (orContainer && this._tabster.focusable.isFocusable(groupperElement)) {\n        return groupperElement;\n      }\n      first = (_a = this._first) === null || _a === void 0 ? void 0 : _a.get();\n      if (!first) {\n        first = this._tabster.focusable.findFirst({\n          container: groupperElement,\n          useActiveModalizer: true\n        }) || undefined;\n        if (first) {\n          this.setFirst(first);\n        }\n      }\n    }\n    return first;\n  }\n  setFirst(element) {\n    if (element) {\n      this._first = new WeakHTMLElement(this._tabster.getWindow, element);\n    } else {\n      delete this._first;\n    }\n  }\n  acceptElement(element, state) {\n    const cachedGrouppers = state.cachedGrouppers;\n    const parentElement = dom.getParentElement(this.getElement());\n    const parentCtx = parentElement && RootAPI.getTabsterContext(this._tabster, parentElement);\n    const parentCtxGroupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;\n    const parentGroupper = (parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupperBeforeMover) ? parentCtxGroupper : undefined;\n    let parentGroupperElement;\n    const getIsActive = groupper => {\n      let cached = cachedGrouppers[groupper.id];\n      let isActive;\n      if (cached) {\n        isActive = cached.isActive;\n      } else {\n        isActive = this.isActive(true);\n        cached = cachedGrouppers[groupper.id] = {\n          isActive\n        };\n      }\n      return isActive;\n    };\n    if (parentGroupper) {\n      parentGroupperElement = parentGroupper.getElement();\n      if (!getIsActive(parentGroupper) && parentGroupperElement && state.container !== parentGroupperElement && dom.nodeContains(state.container, parentGroupperElement)) {\n        // Do not fall into a child groupper of inactive parent groupper if it's in the scope of the search.\n        state.skippedFocusable = true;\n        return NodeFilter.FILTER_REJECT;\n      }\n    }\n    const isActive = getIsActive(this);\n    const groupperElement = this.getElement();\n    if (groupperElement) {\n      if (isActive !== true) {\n        if (groupperElement === element && parentCtxGroupper) {\n          if (!parentGroupperElement) {\n            parentGroupperElement = parentCtxGroupper.getElement();\n          }\n          if (parentGroupperElement && !getIsActive(parentCtxGroupper) && dom.nodeContains(state.container, parentGroupperElement) && parentGroupperElement !== state.container) {\n            state.skippedFocusable = true;\n            return NodeFilter.FILTER_REJECT;\n          }\n        }\n        if (groupperElement !== element && dom.nodeContains(groupperElement, element)) {\n          state.skippedFocusable = true;\n          return NodeFilter.FILTER_REJECT;\n        }\n        const cached = cachedGrouppers[this.id];\n        let first;\n        if (\"first\" in cached) {\n          first = cached.first;\n        } else {\n          first = cached.first = this.getFirst(true);\n        }\n        if (first && state.acceptCondition(first)) {\n          state.rejectElementsFrom = groupperElement;\n          state.skippedFocusable = true;\n          if (first !== state.from) {\n            state.found = true;\n            state.foundElement = first;\n            return NodeFilter.FILTER_ACCEPT;\n          } else {\n            return NodeFilter.FILTER_REJECT;\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n}\nclass GroupperAPI {\n  constructor(tabster, getWindow) {\n    this._current = {};\n    this._grouppers = {};\n    this._init = () => {\n      const win = this._win();\n      // Making sure groupper's onFocus is called before modalizer's onFocus.\n      this._tabster.focusedElement.subscribeFirst(this._onFocus);\n      const doc = win.document;\n      const activeElement = dom.getActiveElement(doc);\n      if (activeElement) {\n        this._onFocus(activeElement);\n      }\n      doc.addEventListener(\"mousedown\", this._onMouseDown, true);\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n      win.addEventListener(GroupperMoveFocusEventName, this._onMoveFocus);\n    };\n    this._onGroupperDispose = groupper => {\n      delete this._grouppers[groupper.id];\n    };\n    this._onFocus = element => {\n      if (element) {\n        this._updateCurrent(element);\n      }\n    };\n    this._onMouseDown = e => {\n      let target = e.target;\n      while (target && !this._tabster.focusable.isFocusable(target)) {\n        target = this._tabster.getParent(target);\n      }\n      if (target) {\n        this._updateCurrent(target);\n      }\n    };\n    this._onKeyDown = event => {\n      if (event.key !== Keys.Enter && event.key !== Keys.Escape) {\n        return;\n      }\n      // Give a chance to other listeners to handle the event.\n      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n        return;\n      }\n      const element = this._tabster.focusedElement.getFocusedElement();\n      if (element) {\n        this.handleKeyPress(element, event);\n      }\n    };\n    this._onMoveFocus = e => {\n      var _a;\n      const element = e.composedPath()[0];\n      const action = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.action;\n      if (element && action !== undefined && !e.defaultPrevented) {\n        if (action === GroupperMoveFocusActions.Enter) {\n          this._enterGroupper(element);\n        } else {\n          this._escapeGroupper(element);\n        }\n        e.stopImmediatePropagation();\n      }\n    };\n    this._tabster = tabster;\n    this._win = getWindow;\n    tabster.queueInit(this._init);\n  }\n  dispose() {\n    const win = this._win();\n    this._tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources.EscapeGroupper);\n    this._current = {};\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n    win.document.removeEventListener(\"mousedown\", this._onMouseDown, true);\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    win.removeEventListener(GroupperMoveFocusEventName, this._onMoveFocus);\n    Object.keys(this._grouppers).forEach(groupperId => {\n      if (this._grouppers[groupperId]) {\n        this._grouppers[groupperId].dispose();\n        delete this._grouppers[groupperId];\n      }\n    });\n  }\n  createGroupper(element, props, sys) {\n    if (true) ;\n    const tabster = this._tabster;\n    const newGroupper = new Groupper(tabster, element, this._onGroupperDispose, props, sys);\n    this._grouppers[newGroupper.id] = newGroupper;\n    const focusedElement = tabster.focusedElement.getFocusedElement();\n    // Newly created groupper contains currently focused element, update the state on the next tick (to\n    // make sure all grouppers are processed).\n    if (focusedElement && dom.nodeContains(element, focusedElement) && !this._updateTimer) {\n      this._updateTimer = this._win().setTimeout(() => {\n        delete this._updateTimer;\n        // Making sure the focused element hasn't changed.\n        if (focusedElement === tabster.focusedElement.getFocusedElement()) {\n          this._updateCurrent(focusedElement);\n        }\n      }, 0);\n    }\n    return newGroupper;\n  }\n  forgetCurrentGrouppers() {\n    this._current = {};\n  }\n  _updateCurrent(element) {\n    var _a;\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n    const tabster = this._tabster;\n    const newIds = {};\n    for (let el = tabster.getParent(element); el; el = tabster.getParent(el)) {\n      const groupper = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;\n      if (groupper) {\n        newIds[groupper.id] = true;\n        this._current[groupper.id] = groupper;\n        const isTabbable = groupper.isActive() || element !== el && (!groupper.getProps().delegated || groupper.getFirst(false) !== element);\n        groupper.makeTabbable(isTabbable);\n      }\n    }\n    for (const id of Object.keys(this._current)) {\n      const groupper = this._current[id];\n      if (!(groupper.id in newIds)) {\n        groupper.makeTabbable(false);\n        groupper.setFirst(undefined);\n        delete this._current[id];\n      }\n    }\n  }\n  _enterGroupper(element, relatedEvent) {\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    const groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper);\n    const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();\n    if (groupper && groupperElement && (element === groupperElement || groupper.getProps().delegated && element === groupper.getFirst(false))) {\n      const next = tabster.focusable.findNext({\n        container: groupperElement,\n        currentElement: element,\n        useActiveModalizer: true\n      });\n      if (next && (!relatedEvent || relatedEvent && groupperElement.dispatchEvent(new TabsterMoveFocusEvent({\n        by: \"groupper\",\n        owner: groupperElement,\n        next,\n        relatedEvent\n      })))) {\n        if (relatedEvent) {\n          // When the application hasn't prevented default,\n          // we consider the event completely handled, hence we\n          // prevent the initial event's default action and stop\n          // propagation.\n          relatedEvent.preventDefault();\n          relatedEvent.stopImmediatePropagation();\n        }\n        next.focus();\n        return next;\n      }\n    }\n    return null;\n  }\n  _escapeGroupper(element, relatedEvent, fromModalizer) {\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    let groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper);\n    const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();\n    if (groupper && groupperElement && dom.nodeContains(groupperElement, element)) {\n      let next;\n      if (element !== groupperElement || fromModalizer) {\n        next = groupper.getFirst(true);\n      } else {\n        const parentElement = dom.getParentElement(groupperElement);\n        const parentCtx = parentElement ? RootAPI.getTabsterContext(tabster, parentElement) : undefined;\n        groupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;\n        next = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);\n      }\n      if (next && (!relatedEvent || relatedEvent && groupperElement.dispatchEvent(new TabsterMoveFocusEvent({\n        by: \"groupper\",\n        owner: groupperElement,\n        next,\n        relatedEvent\n      })))) {\n        if (groupper) {\n          groupper.makeTabbable(false);\n        }\n        // This part happens asynchronously inside setTimeout,\n        // so no need to prevent default or stop propagation.\n        next.focus();\n        return next;\n      }\n    }\n    return null;\n  }\n  moveFocus(element, action) {\n    return action === GroupperMoveFocusActions.Enter ? this._enterGroupper(element) : this._escapeGroupper(element);\n  }\n  handleKeyPress(element, event, fromModalizer) {\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    if (ctx && ((ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper))) {\n      tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources.EscapeGroupper);\n      if (ctx.ignoreKeydown(event)) {\n        return;\n      }\n      if (event.key === Keys.Enter) {\n        this._enterGroupper(element, event);\n      } else if (event.key === Keys.Escape) {\n        // We will handle Esc asynchronously, if something in the application will\n        // move focus during the keypress handling, we will not interfere.\n        const focusedElement = tabster.focusedElement.getFocusedElement();\n        tabster.focusedElement.requestAsyncFocus(AsyncFocusSources.EscapeGroupper, () => {\n          if (focusedElement !== tabster.focusedElement.getFocusedElement() && (\n          // A part of Modalizer that has called this handler to escape the active groupper\n          // might have been removed from DOM, if the focus is on body, we still want to handle Esc.\n          fromModalizer && !focusedElement || !fromModalizer)) {\n            // Something else in the application has moved focus, we will not handle Esc.\n            return;\n          }\n          this._escapeGroupper(element, event, fromModalizer);\n        }, 0);\n      }\n    }\n  }\n}\nfunction _setInformativeStyle$1(weakElement, remove) {\n  if (true) {\n    const element = weakElement.get();\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-groupper\");\n      } else {\n        element.style.setProperty(\"--tabster-groupper\", \"unlimited\");\n      }\n    }\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass KeyboardNavigationState extends Subscribable {\n  constructor(getWindow) {\n    super();\n    this._onChange = isNavigatingWithKeyboard => {\n      this.setVal(isNavigatingWithKeyboard, undefined);\n    };\n    this._keyborg = (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.createKeyborg)(getWindow());\n    this._keyborg.subscribe(this._onChange);\n  }\n  dispose() {\n    super.dispose();\n    if (this._keyborg) {\n      this._keyborg.unsubscribe(this._onChange);\n      (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.disposeKeyborg)(this._keyborg);\n      delete this._keyborg;\n    }\n  }\n  setNavigatingWithKeyboard(isNavigatingWithKeyboard) {\n    var _a;\n    (_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.setVal(isNavigatingWithKeyboard);\n  }\n  isNavigatingWithKeyboard() {\n    var _a;\n    return !!((_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.isNavigatingWithKeyboard());\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nlet _wasFocusedCounter = 0;\nconst _ariaHidden = \"aria-hidden\";\nfunction _setInformativeStyle(weakElement, remove, internalId, userId, isActive, wasFocused) {\n  if (true) {\n    const element = weakElement.get();\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-modalizer\");\n      } else {\n        element.style.setProperty(\"--tabster-modalizer\", internalId + \",\" + userId + \",\" + (isActive ? \"active\" : \"inactive\") + \",\" + \",\" + (wasFocused ? `focused(${wasFocused})` : \"not-focused\"));\n      }\n    }\n  }\n}\n/**\n * Manages the dummy inputs for the Modalizer.\n */\nclass ModalizerDummyManager extends DummyInputManager {\n  constructor(element, tabster, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);\n    this._setHandlers((dummyInput, isBackward) => {\n      var _a, _b;\n      const el = element.get();\n      const container = el && ((_a = RootAPI.getRoot(tabster, el)) === null || _a === void 0 ? void 0 : _a.getElement());\n      const input = dummyInput.input;\n      let toFocus;\n      if (container && input) {\n        const dummyContainer = getDummyInputContainer(input);\n        const ctx = RootAPI.getTabsterContext(tabster, dummyContainer || input);\n        if (ctx) {\n          toFocus = (_b = FocusedElementState.findNextTabbable(tabster, ctx, container, input, undefined, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;\n        }\n        if (toFocus) {\n          (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(toFocus);\n        }\n      }\n    });\n  }\n}\nclass Modalizer extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys, activeElements) {\n    super(tabster, element, props);\n    this._wasFocused = 0;\n    this.userId = props.id;\n    this._onDispose = onDispose;\n    this._activeElements = activeElements;\n    if (!tabster.controlTab) {\n      this.dummyManager = new ModalizerDummyManager(this._element, tabster, sys);\n    }\n    if (true) {\n      _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);\n    }\n  }\n  makeActive(isActive) {\n    if (this._isActive !== isActive) {\n      this._isActive = isActive;\n      const element = this.getElement();\n      if (element) {\n        const activeElements = this._activeElements;\n        const index = activeElements.map(e => e.get()).indexOf(element);\n        if (isActive) {\n          if (index < 0) {\n            activeElements.push(new WeakHTMLElement(this._tabster.getWindow, element));\n          }\n        } else {\n          if (index >= 0) {\n            activeElements.splice(index, 1);\n          }\n        }\n      }\n      if (true) {\n        _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);\n      }\n      this._dispatchEvent(isActive);\n    }\n  }\n  focused(noIncrement) {\n    if (!noIncrement) {\n      this._wasFocused = ++_wasFocusedCounter;\n    }\n    return this._wasFocused;\n  }\n  setProps(props) {\n    if (props.id) {\n      this.userId = props.id;\n    }\n    this._props = {\n      ...props\n    };\n  }\n  dispose() {\n    var _a;\n    this.makeActive(false);\n    this._onDispose(this);\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    delete this.dummyManager;\n    this._activeElements = [];\n    this._remove();\n  }\n  isActive() {\n    return !!this._isActive;\n  }\n  contains(element) {\n    return dom.nodeContains(this.getElement(), element);\n  }\n  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {\n    var _a, _b;\n    const modalizerElement = this.getElement();\n    if (!modalizerElement) {\n      return null;\n    }\n    const tabster = this._tabster;\n    let next = null;\n    let outOfDOMOrder = false;\n    let uncontrolled;\n    const container = currentElement && ((_a = RootAPI.getRoot(tabster, currentElement)) === null || _a === void 0 ? void 0 : _a.getElement());\n    if (container) {\n      const findProps = {\n        container,\n        currentElement,\n        referenceElement,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      };\n      const findPropsOut = {};\n      next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](findProps, findPropsOut);\n      if (!next && this._props.isTrapped && ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n        next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"]({\n          container,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        }, findPropsOut);\n        if (next === null) {\n          next = currentElement;\n        }\n        outOfDOMOrder = true;\n      } else {\n        outOfDOMOrder = !!findPropsOut.outOfDOMOrder;\n      }\n      uncontrolled = findPropsOut.uncontrolled;\n    }\n    return {\n      element: next,\n      uncontrolled,\n      outOfDOMOrder\n    };\n  }\n  _dispatchEvent(isActive, allElements) {\n    const element = this.getElement();\n    let defaultPrevented = false;\n    if (element) {\n      const elements = allElements ? this._activeElements.map(e => e.get()) : [element];\n      for (const el of elements) {\n        if (el) {\n          const eventDetail = {\n            id: this.userId,\n            element\n          };\n          const event = isActive ? new ModalizerActiveEvent(eventDetail) : new ModalizerInactiveEvent(eventDetail);\n          el.dispatchEvent(event);\n          if (event.defaultPrevented) {\n            defaultPrevented = true;\n          }\n        }\n      }\n    }\n    return defaultPrevented;\n  }\n  _remove() {\n    if (true) {\n      _setInformativeStyle(this._element, true);\n    }\n  }\n}\nclass ModalizerAPI {\n  constructor(tabster,\n  // @deprecated use accessibleCheck.\n  alwaysAccessibleSelector, accessibleCheck) {\n    this._onModalizerDispose = modalizer => {\n      const id = modalizer.id;\n      const userId = modalizer.userId;\n      const part = this._parts[userId];\n      delete this._modalizers[id];\n      if (part) {\n        delete part[id];\n        if (Object.keys(part).length === 0) {\n          delete this._parts[userId];\n          const activationHistory = this._activationHistory;\n          const cleanActivationHistory = [];\n          let prevHistoryItem;\n          // The history order is from most recent to oldest.\n          for (let i = activationHistory.length; i--;) {\n            // Remove from activation history, making sure there are no duplicates\n            // for cases like [modal2, modal1, modal2, modal1]: just removing modal2\n            // will result in [modal1, modal1] and we want just [modal1]. Otherwise,\n            // there is a chance for this array to grow forever in a narrow case of\n            // a modalizer that stays in DOM forever and is being activated/deactivated\n            // switching between other modalizers that come and go.\n            const modalizerUserIdFromHistory = activationHistory[i];\n            if (modalizerUserIdFromHistory === userId) {\n              continue;\n            }\n            if (modalizerUserIdFromHistory !== prevHistoryItem) {\n              prevHistoryItem = modalizerUserIdFromHistory;\n              if (modalizerUserIdFromHistory || cleanActivationHistory.length > 0) {\n                cleanActivationHistory.unshift(modalizerUserIdFromHistory);\n              }\n            }\n          }\n          this._activationHistory = cleanActivationHistory;\n          if (this.activeId === userId) {\n            const prevActiveId = cleanActivationHistory[0];\n            const prevActive = prevActiveId ? Object.values(this._parts[prevActiveId])[0] : undefined;\n            this.setActive(prevActive);\n          }\n        }\n      }\n    };\n    this._onKeyDown = event => {\n      var _a;\n      if (event.key !== Keys.Escape) {\n        return;\n      }\n      const tabster = this._tabster;\n      const element = tabster.focusedElement.getFocusedElement();\n      if (element) {\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n        if (ctx && !ctx.groupper && (modalizer === null || modalizer === void 0 ? void 0 : modalizer.isActive()) && !ctx.ignoreKeydown(event)) {\n          const activeId = modalizer.userId;\n          if (activeId) {\n            const part = this._parts[activeId];\n            if (part) {\n              const focusedSince = Object.keys(part).map(id => {\n                var _a;\n                const m = part[id];\n                const el = m.getElement();\n                let groupper;\n                if (el) {\n                  groupper = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;\n                }\n                return m && el && groupper ? {\n                  el,\n                  focusedSince: m.focused(true)\n                } : {\n                  focusedSince: 0\n                };\n              }).filter(f => f.focusedSince > 0).sort((a, b) => a.focusedSince > b.focusedSince ? -1 : a.focusedSince < b.focusedSince ? 1 : 0);\n              if (focusedSince.length) {\n                const groupperElement = focusedSince[0].el;\n                if (groupperElement) {\n                  (_a = tabster.groupper) === null || _a === void 0 ? void 0 : _a.handleKeyPress(groupperElement, event, true);\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n    /**\n     * Subscribes to the focus state and handles modalizer related focus events\n     * @param focusedElement - Element that is focused\n     * @param detail - Additional data about the focus event\n     */\n    this._onFocus = (focusedElement, detail) => {\n      var _a;\n      const tabster = this._tabster;\n      const ctx = focusedElement && RootAPI.getTabsterContext(tabster, focusedElement);\n      // Modalizer behaviour is opt in, only apply to elements that have a tabster context\n      if (!ctx || !focusedElement) {\n        return;\n      }\n      const augmentedMap = this._augMap;\n      for (let e = focusedElement; e; e = dom.getParentElement(e)) {\n        // If the newly focused element is inside some of the hidden containers,\n        // remove aria-hidden from those synchronously for the screen readers\n        // to be able to read the element. The rest of aria-hiddens, will be removed\n        // acynchronously for the sake of performance.\n        if (augmentedMap.has(e)) {\n          augmentedMap.delete(e);\n          augmentAttribute(tabster, e, _ariaHidden);\n        }\n      }\n      let modalizer = ctx.modalizer;\n      const tabsterOnFocusedElement = getTabsterOnElement(tabster, focusedElement);\n      const modalizerOnFocusedElement = tabsterOnFocusedElement === null || tabsterOnFocusedElement === void 0 ? void 0 : tabsterOnFocusedElement.modalizer;\n      if (modalizerOnFocusedElement) {\n        modalizerOnFocusedElement.focused();\n        if (modalizerOnFocusedElement.userId === this.activeId && tabsterOnFocusedElement.groupper) {\n          const parentElement = tabster.getParent(focusedElement);\n          const parentModalizer = parentElement && ((_a = RootAPI.getTabsterContext(tabster, parentElement)) === null || _a === void 0 ? void 0 : _a.modalizer);\n          if (parentModalizer) {\n            modalizer = parentModalizer;\n          } else {\n            this.setActive(undefined);\n            return;\n          }\n        }\n      }\n      // An inactive groupper with the modalizer on the same node will not give the modalizer\n      // in the context, yet we still want to track that the modalizer's container was focused.\n      modalizer === null || modalizer === void 0 ? void 0 : modalizer.focused();\n      if ((modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId) === this.activeId) {\n        this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;\n        return;\n      }\n      // Developers calling `element.focus()` should change/deactivate active modalizer\n      if (detail.isFocusedProgrammatically || this.currentIsOthersAccessible || (modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isAlwaysAccessible)) {\n        this.setActive(modalizer);\n      } else {\n        // Focused outside of the active modalizer, try pull focus back to current modalizer\n        const win = this._win();\n        win.clearTimeout(this._restoreModalizerFocusTimer);\n        // TODO some rendering frameworks (i.e. React) might async rerender the DOM so we need to wait for a duration\n        // Figure out a better way of doing this rather than a 100ms timeout\n        this._restoreModalizerFocusTimer = win.setTimeout(() => this._restoreModalizerFocus(focusedElement), 100);\n      }\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._modalizers = {};\n    this._parts = {};\n    this._augMap = new WeakMap();\n    this._aug = [];\n    this._alwaysAccessibleSelector = alwaysAccessibleSelector;\n    this._accessibleCheck = accessibleCheck;\n    this._activationHistory = [];\n    this.activeElements = [];\n    if (!tabster.controlTab) {\n      tabster.root.addDummyInputs();\n    }\n    const win = this._win();\n    win.addEventListener(\"keydown\", this._onKeyDown, true);\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    });\n  }\n  dispose() {\n    const win = this._win();\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    // Dispose all modalizers managed by the API\n    Object.keys(this._modalizers).forEach(modalizerId => {\n      if (this._modalizers[modalizerId]) {\n        this._modalizers[modalizerId].dispose();\n        delete this._modalizers[modalizerId];\n      }\n    });\n    win.clearTimeout(this._restoreModalizerFocusTimer);\n    win.clearTimeout(this._hiddenUpdateTimer);\n    this._parts = {};\n    delete this.activeId;\n    this.activeElements = [];\n    this._augMap = new WeakMap();\n    this._aug = [];\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n  }\n  createModalizer(element, props, sys) {\n    var _a;\n    if (true) ;\n    const modalizer = new Modalizer(this._tabster, element, this._onModalizerDispose, props, sys, this.activeElements);\n    const id = modalizer.id;\n    const userId = props.id;\n    this._modalizers[id] = modalizer;\n    let part = this._parts[userId];\n    if (!part) {\n      part = this._parts[userId] = {};\n    }\n    part[id] = modalizer;\n    const focusedElement = (_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null;\n    // Adding a modalizer which is already focused, activate it\n    if (element !== focusedElement && dom.nodeContains(element, focusedElement)) {\n      if (userId !== this.activeId) {\n        this.setActive(modalizer);\n      } else {\n        modalizer.makeActive(true);\n      }\n    }\n    return modalizer;\n  }\n  isAugmented(element) {\n    return this._augMap.has(element);\n  }\n  hiddenUpdate() {\n    if (this._hiddenUpdateTimer) {\n      return;\n    }\n    this._hiddenUpdateTimer = this._win().setTimeout(() => {\n      delete this._hiddenUpdateTimer;\n      this._hiddenUpdate();\n    }, 250);\n  }\n  setActive(modalizer) {\n    const userId = modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId;\n    const activeId = this.activeId;\n    if (activeId === userId) {\n      return;\n    }\n    this.activeId = userId;\n    if (activeId) {\n      const part = this._parts[activeId];\n      if (part) {\n        for (const id of Object.keys(part)) {\n          part[id].makeActive(false);\n        }\n      }\n    }\n    if (userId) {\n      const part = this._parts[userId];\n      if (part) {\n        for (const id of Object.keys(part)) {\n          part[id].makeActive(true);\n        }\n      }\n    }\n    this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;\n    this.hiddenUpdate();\n    const activationHistory = this._activationHistory;\n    if (activationHistory[0] !== userId && (userId !== undefined || activationHistory.length > 0)) {\n      activationHistory.unshift(userId);\n    }\n  }\n  focus(elementFromModalizer, noFocusFirst, noFocusDefault) {\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, elementFromModalizer);\n    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n    if (modalizer) {\n      this.setActive(modalizer);\n      const props = modalizer.getProps();\n      const modalizerRoot = modalizer.getElement();\n      if (modalizerRoot) {\n        if (noFocusFirst === undefined) {\n          noFocusFirst = props.isNoFocusFirst;\n        }\n        if (!noFocusFirst && tabster.keyboardNavigation.isNavigatingWithKeyboard() && tabster.focusedElement.focusFirst({\n          container: modalizerRoot\n        })) {\n          return true;\n        }\n        if (noFocusDefault === undefined) {\n          noFocusDefault = props.isNoFocusDefault;\n        }\n        if (!noFocusDefault && tabster.focusedElement.focusDefault(modalizerRoot)) {\n          return true;\n        }\n        tabster.focusedElement.resetFocus(modalizerRoot);\n      }\n    } else if (true) {\n      console.error(\"Element is not in Modalizer.\", elementFromModalizer);\n    }\n    return false;\n  }\n  activate(modalizerElementOrContainer) {\n    var _a;\n    const modalizerToActivate = modalizerElementOrContainer ? (_a = RootAPI.getTabsterContext(this._tabster, modalizerElementOrContainer)) === null || _a === void 0 ? void 0 : _a.modalizer : undefined;\n    if (!modalizerElementOrContainer || modalizerToActivate) {\n      this.setActive(modalizerToActivate);\n      return true;\n    }\n    return false;\n  }\n  acceptElement(element, state) {\n    var _a;\n    const modalizerUserId = state.modalizerUserId;\n    const currentModalizer = (_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.modalizer;\n    if (modalizerUserId) {\n      for (const e of this.activeElements) {\n        const el = e.get();\n        if (el && (dom.nodeContains(element, el) || el === element)) {\n          // We have a part of currently active modalizer somewhere deeper in the DOM,\n          // skipping all other checks.\n          return NodeFilter.FILTER_SKIP;\n        }\n      }\n    }\n    const ret = modalizerUserId === (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.userId) || !modalizerUserId && (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.getProps().isAlwaysAccessible) ? undefined : NodeFilter.FILTER_SKIP;\n    if (ret !== undefined) {\n      state.skippedFocusable = true;\n    }\n    return ret;\n  }\n  _hiddenUpdate() {\n    var _a;\n    const tabster = this._tabster;\n    const body = tabster.getWindow().document.body;\n    const activeId = this.activeId;\n    const parts = this._parts;\n    const visibleElements = [];\n    const hiddenElements = [];\n    const alwaysAccessibleSelector = this._alwaysAccessibleSelector;\n    const alwaysAccessibleElements = alwaysAccessibleSelector ? Array.from(dom.querySelectorAll(body, alwaysAccessibleSelector)) : [];\n    const activeModalizerElements = [];\n    for (const userId of Object.keys(parts)) {\n      const modalizerParts = parts[userId];\n      for (const id of Object.keys(modalizerParts)) {\n        const modalizer = modalizerParts[id];\n        const el = modalizer.getElement();\n        const props = modalizer.getProps();\n        const isAlwaysAccessible = props.isAlwaysAccessible;\n        if (el) {\n          if (userId === activeId) {\n            activeModalizerElements.push(el);\n            if (!this.currentIsOthersAccessible) {\n              visibleElements.push(el);\n            }\n          } else if (isAlwaysAccessible) {\n            alwaysAccessibleElements.push(el);\n          } else {\n            hiddenElements.push(el);\n          }\n        }\n      }\n    }\n    const augmentedMap = this._augMap;\n    const allVisibleElements = visibleElements.length > 0 ? [...visibleElements, ...alwaysAccessibleElements] : undefined;\n    const newAugmented = [];\n    const newAugmentedMap = new WeakMap();\n    const toggle = (element, hide) => {\n      var _a;\n      const tagName = element.tagName;\n      if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n        return;\n      }\n      let isAugmented = false;\n      if (augmentedMap.has(element)) {\n        if (hide) {\n          isAugmented = true;\n        } else {\n          augmentedMap.delete(element);\n          augmentAttribute(tabster, element, _ariaHidden);\n        }\n      } else if (hide && !((_a = this._accessibleCheck) === null || _a === void 0 ? void 0 : _a.call(this, element, activeModalizerElements)) && augmentAttribute(tabster, element, _ariaHidden, \"true\")) {\n        augmentedMap.set(element, true);\n        isAugmented = true;\n      }\n      if (isAugmented) {\n        newAugmented.push(new WeakHTMLElement(tabster.getWindow, element));\n        newAugmentedMap.set(element, true);\n      }\n    };\n    const walk = element => {\n      var _a;\n      for (let el = dom.getFirstElementChild(element); el; el = dom.getNextElementSibling(el)) {\n        let skip = false;\n        let containsModalizer = false;\n        let containedByModalizer = false;\n        if (allVisibleElements) {\n          const elParent = tabster.getParent(el);\n          for (const c of allVisibleElements) {\n            if (el === c) {\n              skip = true;\n              break;\n            }\n            if (dom.nodeContains(el, c)) {\n              containsModalizer = true;\n              break;\n            } else if (dom.nodeContains(c, elParent)) {\n              // tabster.getParent() could be provided by the application to\n              // handle, for example, virtual parents. Making sure, we are\n              // not setting aria-hidden on elements which are virtually\n              // inside modalizer.\n              containedByModalizer = true;\n            }\n          }\n          if (containsModalizer || ((_a = el.__tabsterElementFlags) === null || _a === void 0 ? void 0 : _a.noDirectAriaHidden)) {\n            walk(el);\n          } else if (!skip && !containedByModalizer) {\n            toggle(el, true);\n          }\n        } else {\n          toggle(el, false);\n        }\n      }\n    };\n    if (!allVisibleElements) {\n      alwaysAccessibleElements.forEach(e => toggle(e, false));\n    }\n    hiddenElements.forEach(e => toggle(e, true));\n    if (body) {\n      walk(body);\n    }\n    (_a = this._aug) === null || _a === void 0 ? void 0 : _a.map(e => e.get()).forEach(e => {\n      if (e && !newAugmentedMap.get(e)) {\n        toggle(e, false);\n      }\n    });\n    this._aug = newAugmented;\n    this._augMap = newAugmentedMap;\n  }\n  /**\n   * Called when an element is focused outside of an active modalizer.\n   * Attempts to pull focus back into the active modalizer\n   * @param outsideElement - An element being focused outside of the modalizer\n   */\n  _restoreModalizerFocus(outsideElement) {\n    var _a;\n    const ownerDocument = outsideElement === null || outsideElement === void 0 ? void 0 : outsideElement.ownerDocument;\n    if (!outsideElement || !ownerDocument) {\n      return;\n    }\n    const focusedElement = this._tabster.focusedElement.getFocusedElement();\n    const focusedElementModalizer = focusedElement && ((_a = RootAPI.getTabsterContext(this._tabster, focusedElement)) === null || _a === void 0 ? void 0 : _a.modalizer);\n    if (!focusedElement || focusedElement && (focusedElementModalizer === null || focusedElementModalizer === void 0 ? void 0 : focusedElementModalizer.userId) === this.activeId) {\n      // If there is no currently focused element, or the currently focused element\n      // is in the active modalizer, we don't need to do anything.\n      return;\n    }\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, outsideElement);\n    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n    const activeId = this.activeId;\n    if (!modalizer && !activeId || modalizer && activeId === modalizer.userId) {\n      return;\n    }\n    const container = ctx === null || ctx === void 0 ? void 0 : ctx.root.getElement();\n    if (container) {\n      let toFocus = tabster.focusable.findFirst({\n        container,\n        useActiveModalizer: true\n      });\n      if (toFocus) {\n        if (outsideElement.compareDocumentPosition(toFocus) & document.DOCUMENT_POSITION_PRECEDING) {\n          toFocus = tabster.focusable.findLast({\n            container,\n            useActiveModalizer: true\n          });\n          if (!toFocus) {\n            // This only might mean that findFirst/findLast are buggy and inconsistent.\n            throw new Error(\"Something went wrong.\");\n          }\n        }\n        tabster.focusedElement.focus(toFocus);\n        return;\n      }\n    }\n    // Current Modalizer doesn't seem to have focusable elements.\n    // Blurring the currently focused element which is outside of the current Modalizer.\n    outsideElement.blur();\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst _inputSelector = /*#__PURE__*/[\"input\", \"textarea\", \"*[contenteditable]\"].join(\", \");\nclass MoverDummyManager extends DummyInputManager {\n  constructor(element, tabster, getMemorized, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Mover, sys);\n    this._onFocusDummyInput = dummyInput => {\n      var _a, _b;\n      const container = this._element.get();\n      const input = dummyInput.input;\n      if (container && input) {\n        const ctx = RootAPI.getTabsterContext(this._tabster, container);\n        let toFocus;\n        if (ctx) {\n          toFocus = (_a = FocusedElementState.findNextTabbable(this._tabster, ctx, undefined, input, undefined, !dummyInput.isFirst, true)) === null || _a === void 0 ? void 0 : _a.element;\n        }\n        const memorized = (_b = this._getMemorized()) === null || _b === void 0 ? void 0 : _b.get();\n        if (memorized && this._tabster.focusable.isFocusable(memorized)) {\n          toFocus = memorized;\n        }\n        if (toFocus) {\n          (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(toFocus);\n        }\n      }\n    };\n    this._tabster = tabster;\n    this._getMemorized = getMemorized;\n    this._setHandlers(this._onFocusDummyInput);\n  }\n}\n// TypeScript enums produce depressing JavaScript code, so, we're just using\n// a few old style constants here.\nconst _moverUpdateAdd = 1;\nconst _moverUpdateAttr = 2;\nconst _moverUpdateRemove = 3;\nclass Mover extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    var _a;\n    super(tabster, element, props);\n    this._visible = {};\n    this._onIntersection = entries => {\n      for (const entry of entries) {\n        const el = entry.target;\n        const id = getElementUId(this._win, el);\n        let newVisibility;\n        let fullyVisible = this._fullyVisible;\n        if (entry.intersectionRatio >= 0.25) {\n          newVisibility = entry.intersectionRatio >= 0.75 ? Visibilities.Visible : Visibilities.PartiallyVisible;\n          if (newVisibility === Visibilities.Visible) {\n            fullyVisible = id;\n          }\n        } else {\n          newVisibility = Visibilities.Invisible;\n        }\n        if (this._visible[id] !== newVisibility) {\n          if (newVisibility === undefined) {\n            delete this._visible[id];\n            if (fullyVisible === id) {\n              delete this._fullyVisible;\n            }\n          } else {\n            this._visible[id] = newVisibility;\n            this._fullyVisible = fullyVisible;\n          }\n          const state = this.getState(el);\n          if (state) {\n            el.dispatchEvent(new MoverStateEvent(state));\n          }\n        }\n      }\n    };\n    this._win = tabster.getWindow;\n    this.visibilityTolerance = (_a = props.visibilityTolerance) !== null && _a !== void 0 ? _a : 0.8;\n    if (this._props.trackState || this._props.visibilityAware) {\n      this._intersectionObserver = new IntersectionObserver(this._onIntersection, {\n        threshold: [0, 0.25, 0.5, 0.75, 1]\n      });\n      this._observeState();\n    }\n    this._onDispose = onDispose;\n    const getMemorized = () => props.memorizeCurrent ? this._current : undefined;\n    if (!tabster.controlTab) {\n      this.dummyManager = new MoverDummyManager(this._element, tabster, getMemorized, sys);\n    }\n  }\n  dispose() {\n    var _a;\n    this._onDispose(this);\n    if (this._intersectionObserver) {\n      this._intersectionObserver.disconnect();\n      delete this._intersectionObserver;\n    }\n    delete this._current;\n    delete this._fullyVisible;\n    delete this._allElements;\n    delete this._updateQueue;\n    if (this._unobserve) {\n      this._unobserve();\n      delete this._unobserve;\n    }\n    const win = this._win();\n    if (this._setCurrentTimer) {\n      win.clearTimeout(this._setCurrentTimer);\n      delete this._setCurrentTimer;\n    }\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    delete this.dummyManager;\n  }\n  setCurrent(element) {\n    if (element) {\n      this._current = new WeakHTMLElement(this._win, element);\n    } else {\n      this._current = undefined;\n    }\n    if ((this._props.trackState || this._props.visibilityAware) && !this._setCurrentTimer) {\n      this._setCurrentTimer = this._win().setTimeout(() => {\n        var _a;\n        delete this._setCurrentTimer;\n        const changed = [];\n        if (this._current !== this._prevCurrent) {\n          changed.push(this._current);\n          changed.push(this._prevCurrent);\n          this._prevCurrent = this._current;\n        }\n        for (const weak of changed) {\n          const el = weak === null || weak === void 0 ? void 0 : weak.get();\n          if (el && ((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) === this) {\n            const props = this._props;\n            if (el && (props.visibilityAware !== undefined || props.trackState)) {\n              const state = this.getState(el);\n              if (state) {\n                el.dispatchEvent(new MoverStateEvent(state));\n              }\n            }\n          }\n        }\n      });\n    }\n  }\n  getCurrent() {\n    var _a;\n    return ((_a = this._current) === null || _a === void 0 ? void 0 : _a.get()) || null;\n  }\n  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {\n    const container = this.getElement();\n    const currentIsDummy = container && getDummyInputContainer(currentElement) === container;\n    if (!container) {\n      return null;\n    }\n    let next = null;\n    let outOfDOMOrder = false;\n    let uncontrolled;\n    if (this._props.tabbable || currentIsDummy || currentElement && !dom.nodeContains(container, currentElement)) {\n      const findProps = {\n        currentElement,\n        referenceElement,\n        container,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      };\n      const findPropsOut = {};\n      next = this._tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](findProps, findPropsOut);\n      outOfDOMOrder = !!findPropsOut.outOfDOMOrder;\n      uncontrolled = findPropsOut.uncontrolled;\n    }\n    return {\n      element: next,\n      uncontrolled,\n      outOfDOMOrder\n    };\n  }\n  acceptElement(element, state) {\n    var _a, _b;\n    if (!FocusedElementState.isTabbing) {\n      return ((_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.excludedFromMover) ? NodeFilter.FILTER_REJECT : undefined;\n    }\n    const {\n      memorizeCurrent,\n      visibilityAware,\n      hasDefault = true\n    } = this._props;\n    const moverElement = this.getElement();\n    if (moverElement && (memorizeCurrent || visibilityAware || hasDefault) && (!dom.nodeContains(moverElement, state.from) || getDummyInputContainer(state.from) === moverElement)) {\n      let found;\n      if (memorizeCurrent) {\n        const current = (_b = this._current) === null || _b === void 0 ? void 0 : _b.get();\n        if (current && state.acceptCondition(current)) {\n          found = current;\n        }\n      }\n      if (!found && hasDefault) {\n        found = this._tabster.focusable.findDefault({\n          container: moverElement,\n          useActiveModalizer: true\n        });\n      }\n      if (!found && visibilityAware) {\n        found = this._tabster.focusable.findElement({\n          container: moverElement,\n          useActiveModalizer: true,\n          isBackward: state.isBackward,\n          acceptCondition: el => {\n            var _a;\n            const id = getElementUId(this._win, el);\n            const visibility = this._visible[id];\n            return moverElement !== el && !!((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) && state.acceptCondition(el) && (visibility === Visibilities.Visible || visibility === Visibilities.PartiallyVisible && (visibilityAware === Visibilities.PartiallyVisible || !this._fullyVisible));\n          }\n        });\n      }\n      if (found) {\n        state.found = true;\n        state.foundElement = found;\n        state.rejectElementsFrom = moverElement;\n        state.skippedFocusable = true;\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }\n    return undefined;\n  }\n  _observeState() {\n    const element = this.getElement();\n    if (this._unobserve || !element || typeof MutationObserver === \"undefined\") {\n      return;\n    }\n    const win = this._win();\n    const allElements = this._allElements = new WeakMap();\n    const tabsterFocusable = this._tabster.focusable;\n    let updateQueue = this._updateQueue = [];\n    const observer = dom.createMutationObserver(mutations => {\n      for (const mutation of mutations) {\n        const target = mutation.target;\n        const removed = mutation.removedNodes;\n        const added = mutation.addedNodes;\n        if (mutation.type === \"attributes\") {\n          if (mutation.attributeName === \"tabindex\") {\n            updateQueue.push({\n              element: target,\n              type: _moverUpdateAttr\n            });\n          }\n        } else {\n          for (let i = 0; i < removed.length; i++) {\n            updateQueue.push({\n              element: removed[i],\n              type: _moverUpdateRemove\n            });\n          }\n          for (let i = 0; i < added.length; i++) {\n            updateQueue.push({\n              element: added[i],\n              type: _moverUpdateAdd\n            });\n          }\n        }\n      }\n      requestUpdate();\n    });\n    const setElement = (element, remove) => {\n      var _a, _b;\n      const current = allElements.get(element);\n      if (current && remove) {\n        (_a = this._intersectionObserver) === null || _a === void 0 ? void 0 : _a.unobserve(element);\n        allElements.delete(element);\n      }\n      if (!current && !remove) {\n        allElements.set(element, this);\n        (_b = this._intersectionObserver) === null || _b === void 0 ? void 0 : _b.observe(element);\n      }\n    };\n    const updateElement = element => {\n      const isFocusable = tabsterFocusable.isFocusable(element);\n      const current = allElements.get(element);\n      if (current) {\n        if (!isFocusable) {\n          setElement(element, true);\n        }\n      } else {\n        if (isFocusable) {\n          setElement(element);\n        }\n      }\n    };\n    const addNewElements = element => {\n      const {\n        mover\n      } = getMoverGroupper(element);\n      if (mover && mover !== this) {\n        if (mover.getElement() === element && tabsterFocusable.isFocusable(element)) {\n          setElement(element);\n        } else {\n          return;\n        }\n      }\n      const walker = createElementTreeWalker(win.document, element, node => {\n        const {\n          mover,\n          groupper\n        } = getMoverGroupper(node);\n        if (mover && mover !== this) {\n          return NodeFilter.FILTER_REJECT;\n        }\n        const groupperFirstFocusable = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);\n        if (groupper && groupper.getElement() !== node && groupperFirstFocusable && groupperFirstFocusable !== node) {\n          return NodeFilter.FILTER_REJECT;\n        }\n        if (tabsterFocusable.isFocusable(node)) {\n          setElement(node);\n        }\n        return NodeFilter.FILTER_SKIP;\n      });\n      if (walker) {\n        walker.currentNode = element;\n        while (walker.nextNode()) {\n          /* Iterating for the sake of calling processNode() callback. */\n        }\n      }\n    };\n    const removeWalk = element => {\n      const current = allElements.get(element);\n      if (current) {\n        setElement(element, true);\n      }\n      for (let el = dom.getFirstElementChild(element); el; el = dom.getNextElementSibling(el)) {\n        removeWalk(el);\n      }\n    };\n    const requestUpdate = () => {\n      if (!this._updateTimer && updateQueue.length) {\n        this._updateTimer = win.setTimeout(() => {\n          delete this._updateTimer;\n          for (const {\n            element,\n            type\n          } of updateQueue) {\n            switch (type) {\n              case _moverUpdateAttr:\n                updateElement(element);\n                break;\n              case _moverUpdateAdd:\n                addNewElements(element);\n                break;\n              case _moverUpdateRemove:\n                removeWalk(element);\n                break;\n            }\n          }\n          updateQueue = this._updateQueue = [];\n        }, 0);\n      }\n    };\n    const getMoverGroupper = element => {\n      const ret = {};\n      for (let el = element; el; el = dom.getParentElement(el)) {\n        const toe = getTabsterOnElement(this._tabster, el);\n        if (toe) {\n          if (toe.groupper && !ret.groupper) {\n            ret.groupper = toe.groupper;\n          }\n          if (toe.mover) {\n            ret.mover = toe.mover;\n            break;\n          }\n        }\n      }\n      return ret;\n    };\n    updateQueue.push({\n      element,\n      type: _moverUpdateAdd\n    });\n    requestUpdate();\n    observer.observe(element, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"tabindex\"]\n    });\n    this._unobserve = () => {\n      observer.disconnect();\n    };\n  }\n  getState(element) {\n    const id = getElementUId(this._win, element);\n    if (id in this._visible) {\n      const visibility = this._visible[id] || Visibilities.Invisible;\n      const isCurrent = this._current ? this._current.get() === element : undefined;\n      return {\n        isCurrent,\n        visibility\n      };\n    }\n    return undefined;\n  }\n}\n/**\n * Calculates distance between two rectangles.\n *\n * @param ax1 first rectangle left\n * @param ay1 first rectangle top\n * @param ax2 first rectangle right\n * @param ay2 first rectangle bottom\n * @param bx1 second rectangle left\n * @param by1 second rectangle top\n * @param bx2 second rectangle right\n * @param by2 second rectangle bottom\n * @returns number, shortest distance between the rectangles.\n */\nfunction getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n  const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;\n  const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;\n  return xDistance === 0 ? yDistance : yDistance === 0 ? xDistance : Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n}\nclass MoverAPI {\n  constructor(tabster, getWindow) {\n    this._init = () => {\n      const win = this._win();\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n      win.addEventListener(MoverMoveFocusEventName, this._onMoveFocus);\n      win.addEventListener(MoverMemorizedElementEventName, this._onMemorizedElement);\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    };\n    this._onMoverDispose = mover => {\n      delete this._movers[mover.id];\n    };\n    this._onFocus = element => {\n      var _a;\n      // When something in the app gets focused, we are making sure that\n      // the relevant context Mover is aware of it.\n      // Looking for the relevant context Mover from the currently\n      // focused element parent, not from the element itself, because the\n      // Mover element itself cannot be its own current (but might be\n      // current for its parent Mover).\n      let currentFocusableElement = element;\n      let deepestFocusableElement = element;\n      for (let el = dom.getParentElement(element); el; el = dom.getParentElement(el)) {\n        // We go through all Movers up from the focused element and\n        // set their current element to the deepest focusable of that\n        // Mover.\n        const mover = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.mover;\n        if (mover) {\n          mover.setCurrent(deepestFocusableElement);\n          currentFocusableElement = undefined;\n        }\n        if (!currentFocusableElement && this._tabster.focusable.isFocusable(el)) {\n          currentFocusableElement = deepestFocusableElement = el;\n        }\n      }\n    };\n    this._onKeyDown = async event => {\n      var _a;\n      if (this._ignoredInputTimer) {\n        this._win().clearTimeout(this._ignoredInputTimer);\n        delete this._ignoredInputTimer;\n      }\n      (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n      // Give a chance to other listeners to handle the event (for example,\n      // to scroll instead of moving focus).\n      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n        return;\n      }\n      const key = event.key;\n      let moverKey;\n      if (key === Keys.ArrowDown) {\n        moverKey = MoverKeys.ArrowDown;\n      } else if (key === Keys.ArrowRight) {\n        moverKey = MoverKeys.ArrowRight;\n      } else if (key === Keys.ArrowUp) {\n        moverKey = MoverKeys.ArrowUp;\n      } else if (key === Keys.ArrowLeft) {\n        moverKey = MoverKeys.ArrowLeft;\n      } else if (key === Keys.PageDown) {\n        moverKey = MoverKeys.PageDown;\n      } else if (key === Keys.PageUp) {\n        moverKey = MoverKeys.PageUp;\n      } else if (key === Keys.Home) {\n        moverKey = MoverKeys.Home;\n      } else if (key === Keys.End) {\n        moverKey = MoverKeys.End;\n      }\n      if (!moverKey) {\n        return;\n      }\n      const focused = this._tabster.focusedElement.getFocusedElement();\n      if (!focused || (await this._isIgnoredInput(focused, key))) {\n        return;\n      }\n      this._moveFocus(focused, moverKey, event);\n    };\n    this._onMoveFocus = e => {\n      var _a;\n      const element = e.composedPath()[0];\n      const key = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.key;\n      if (element && key !== undefined && !e.defaultPrevented) {\n        this._moveFocus(element, key);\n        e.stopImmediatePropagation();\n      }\n    };\n    this._onMemorizedElement = e => {\n      var _a;\n      const target = e.composedPath()[0];\n      let memorizedElement = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.memorizedElement;\n      if (target) {\n        const ctx = RootAPI.getTabsterContext(this._tabster, target);\n        const mover = ctx === null || ctx === void 0 ? void 0 : ctx.mover;\n        if (mover) {\n          if (memorizedElement && !dom.nodeContains(mover.getElement(), memorizedElement)) {\n            memorizedElement = undefined;\n          }\n          mover.setCurrent(memorizedElement);\n          e.stopImmediatePropagation();\n        }\n      }\n    };\n    this._tabster = tabster;\n    this._win = getWindow;\n    this._movers = {};\n    tabster.queueInit(this._init);\n  }\n  dispose() {\n    var _a;\n    const win = this._win();\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n    (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n    if (this._ignoredInputTimer) {\n      win.clearTimeout(this._ignoredInputTimer);\n      delete this._ignoredInputTimer;\n    }\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    win.removeEventListener(MoverMoveFocusEventName, this._onMoveFocus);\n    win.removeEventListener(MoverMemorizedElementEventName, this._onMemorizedElement);\n    Object.keys(this._movers).forEach(moverId => {\n      if (this._movers[moverId]) {\n        this._movers[moverId].dispose();\n        delete this._movers[moverId];\n      }\n    });\n  }\n  createMover(element, props, sys) {\n    if (true) ;\n    const newMover = new Mover(this._tabster, element, this._onMoverDispose, props, sys);\n    this._movers[newMover.id] = newMover;\n    return newMover;\n  }\n  moveFocus(fromElement, key) {\n    return this._moveFocus(fromElement, key);\n  }\n  _moveFocus(fromElement, key, relatedEvent) {\n    var _a, _b;\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, fromElement, {\n      checkRtl: true\n    });\n    if (!ctx || !ctx.mover || ctx.excludedFromMover || relatedEvent && ctx.ignoreKeydown(relatedEvent)) {\n      return null;\n    }\n    const mover = ctx.mover;\n    const container = mover.getElement();\n    if (ctx.groupperBeforeMover) {\n      const groupper = ctx.groupper;\n      if (groupper && !groupper.isActive(true)) {\n        // For the cases when we have Mover/Active Groupper/Inactive Groupper, we need to check\n        // the grouppers between the current element and the current mover.\n        for (let el = dom.getParentElement(groupper.getElement()); el && el !== container; el = dom.getParentElement(el)) {\n          if ((_b = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper) === null || _b === void 0 ? void 0 : _b.isActive(true)) {\n            return null;\n          }\n        }\n      } else {\n        return null;\n      }\n    }\n    if (!container) {\n      return null;\n    }\n    const focusable = tabster.focusable;\n    const moverProps = mover.getProps();\n    const direction = moverProps.direction || MoverDirections.Both;\n    const isBoth = direction === MoverDirections.Both;\n    const isVertical = isBoth || direction === MoverDirections.Vertical;\n    const isHorizontal = isBoth || direction === MoverDirections.Horizontal;\n    const isGridLinear = direction === MoverDirections.GridLinear;\n    const isGrid = isGridLinear || direction === MoverDirections.Grid;\n    const isCyclic = moverProps.cyclic;\n    let next;\n    let scrollIntoViewArg;\n    let focusedElementRect;\n    let focusedElementX1 = 0;\n    let focusedElementX2 = 0;\n    if (isGrid) {\n      focusedElementRect = fromElement.getBoundingClientRect();\n      focusedElementX1 = Math.ceil(focusedElementRect.left);\n      focusedElementX2 = Math.floor(focusedElementRect.right);\n    }\n    if (ctx.rtl) {\n      if (key === MoverKeys.ArrowRight) {\n        key = MoverKeys.ArrowLeft;\n      } else if (key === MoverKeys.ArrowLeft) {\n        key = MoverKeys.ArrowRight;\n      }\n    }\n    if (key === MoverKeys.ArrowDown && isVertical || key === MoverKeys.ArrowRight && (isHorizontal || isGrid)) {\n      next = focusable.findNext({\n        currentElement: fromElement,\n        container,\n        useActiveModalizer: true\n      });\n      if (next && isGrid) {\n        const nextElementX1 = Math.ceil(next.getBoundingClientRect().left);\n        if (!isGridLinear && focusedElementX2 > nextElementX1) {\n          next = undefined;\n        }\n      } else if (!next && isCyclic) {\n        next = focusable.findFirst({\n          container,\n          useActiveModalizer: true\n        });\n      }\n    } else if (key === MoverKeys.ArrowUp && isVertical || key === MoverKeys.ArrowLeft && (isHorizontal || isGrid)) {\n      next = focusable.findPrev({\n        currentElement: fromElement,\n        container,\n        useActiveModalizer: true\n      });\n      if (next && isGrid) {\n        const nextElementX2 = Math.floor(next.getBoundingClientRect().right);\n        if (!isGridLinear && nextElementX2 > focusedElementX1) {\n          next = undefined;\n        }\n      } else if (!next && isCyclic) {\n        next = focusable.findLast({\n          container,\n          useActiveModalizer: true\n        });\n      }\n    } else if (key === MoverKeys.Home) {\n      if (isGrid) {\n        focusable.findElement({\n          container,\n          currentElement: fromElement,\n          useActiveModalizer: true,\n          isBackward: true,\n          acceptCondition: el => {\n            var _a;\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n            const nextElementX1 = Math.ceil((_a = el.getBoundingClientRect().left) !== null && _a !== void 0 ? _a : 0);\n            if (el !== fromElement && focusedElementX1 <= nextElementX1) {\n              return true;\n            }\n            next = el;\n            return false;\n          }\n        });\n      } else {\n        next = focusable.findFirst({\n          container,\n          useActiveModalizer: true\n        });\n      }\n    } else if (key === MoverKeys.End) {\n      if (isGrid) {\n        focusable.findElement({\n          container,\n          currentElement: fromElement,\n          useActiveModalizer: true,\n          acceptCondition: el => {\n            var _a;\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n            const nextElementX1 = Math.ceil((_a = el.getBoundingClientRect().left) !== null && _a !== void 0 ? _a : 0);\n            if (el !== fromElement && focusedElementX1 >= nextElementX1) {\n              return true;\n            }\n            next = el;\n            return false;\n          }\n        });\n      } else {\n        next = focusable.findLast({\n          container,\n          useActiveModalizer: true\n        });\n      }\n    } else if (key === MoverKeys.PageUp) {\n      focusable.findElement({\n        currentElement: fromElement,\n        container,\n        useActiveModalizer: true,\n        isBackward: true,\n        acceptCondition: el => {\n          if (!focusable.isFocusable(el)) {\n            return false;\n          }\n          if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {\n            next = el;\n            return false;\n          }\n          return true;\n        }\n      });\n      // will be on the first column move forward and preserve previous column\n      if (isGrid && next) {\n        const firstColumnX1 = Math.ceil(next.getBoundingClientRect().left);\n        focusable.findElement({\n          currentElement: next,\n          container,\n          useActiveModalizer: true,\n          acceptCondition: el => {\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n            const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);\n            if (focusedElementX1 < nextElementX1 || firstColumnX1 >= nextElementX1) {\n              return true;\n            }\n            next = el;\n            return false;\n          }\n        });\n      }\n      scrollIntoViewArg = false;\n    } else if (key === MoverKeys.PageDown) {\n      focusable.findElement({\n        currentElement: fromElement,\n        container,\n        useActiveModalizer: true,\n        acceptCondition: el => {\n          if (!focusable.isFocusable(el)) {\n            return false;\n          }\n          if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {\n            next = el;\n            return false;\n          }\n          return true;\n        }\n      });\n      // will be on the last column move backwards and preserve previous column\n      if (isGrid && next) {\n        const lastColumnX1 = Math.ceil(next.getBoundingClientRect().left);\n        focusable.findElement({\n          currentElement: next,\n          container,\n          useActiveModalizer: true,\n          isBackward: true,\n          acceptCondition: el => {\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n            const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);\n            if (focusedElementX1 > nextElementX1 || lastColumnX1 <= nextElementX1) {\n              return true;\n            }\n            next = el;\n            return false;\n          }\n        });\n      }\n      scrollIntoViewArg = true;\n    } else if (isGrid) {\n      const isBackward = key === MoverKeys.ArrowUp;\n      const ax1 = focusedElementX1;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const ay1 = Math.ceil(focusedElementRect.top);\n      const ax2 = focusedElementX2;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const ay2 = Math.floor(focusedElementRect.bottom);\n      let targetElement;\n      let lastDistance;\n      let lastIntersection = 0;\n      focusable.findAll({\n        container,\n        currentElement: fromElement,\n        isBackward,\n        onElement: el => {\n          // Find element which has maximal intersection with the focused element horizontally,\n          // or the closest one.\n          const rect = el.getBoundingClientRect();\n          const bx1 = Math.ceil(rect.left);\n          const by1 = Math.ceil(rect.top);\n          const bx2 = Math.floor(rect.right);\n          const by2 = Math.floor(rect.bottom);\n          if (isBackward && ay1 < by2 || !isBackward && ay2 > by1) {\n            // Only consider elements which are below/above curretly focused.\n            return true;\n          }\n          const xIntersectionWidth = Math.ceil(Math.min(ax2, bx2)) - Math.floor(Math.max(ax1, bx1));\n          const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));\n          if (xIntersectionWidth > 0 && minWidth >= xIntersectionWidth) {\n            // Element intersects with the focused element on X axis.\n            const intersection = xIntersectionWidth / minWidth;\n            if (intersection > lastIntersection) {\n              targetElement = el;\n              lastIntersection = intersection;\n            }\n          } else if (lastIntersection === 0) {\n            // If we didn't have intersection, try just the closest one.\n            const distance = getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);\n            if (lastDistance === undefined || distance < lastDistance) {\n              lastDistance = distance;\n              targetElement = el;\n            }\n          } else if (lastIntersection > 0) {\n            // Element doesn't intersect, but we had intersection already, stop search.\n            return false;\n          }\n          return true;\n        }\n      });\n      next = targetElement;\n    }\n    if (next && (!relatedEvent || relatedEvent && container.dispatchEvent(new TabsterMoveFocusEvent({\n      by: \"mover\",\n      owner: container,\n      next,\n      relatedEvent\n    })))) {\n      if (scrollIntoViewArg !== undefined) {\n        scrollIntoView(this._win, next, scrollIntoViewArg);\n      }\n      if (relatedEvent) {\n        relatedEvent.preventDefault();\n        relatedEvent.stopImmediatePropagation();\n      }\n      (0,keyborg__WEBPACK_IMPORTED_MODULE_0__.nativeFocus)(next);\n      return next;\n    }\n    return null;\n  }\n  async _isIgnoredInput(element, key) {\n    if (element.getAttribute(\"aria-expanded\") === \"true\" && (element.hasAttribute(\"aria-activedescendant\") || element.getAttribute(\"role\") === \"combobox\")) {\n      // It is likely a combobox with expanded options and arrow keys are\n      // controlled by it.\n      return true;\n    }\n    if (matchesSelector(element, _inputSelector)) {\n      let selectionStart = 0;\n      let selectionEnd = 0;\n      let textLength = 0;\n      let asyncRet;\n      if (element.tagName === \"INPUT\" || element.tagName === \"TEXTAREA\") {\n        const type = element.type;\n        const value = element.value;\n        textLength = (value || \"\").length;\n        if (type === \"email\" || type === \"number\") {\n          // For these types Chromium doesn't provide selectionStart and selectionEnd.\n          // Hence the ugly workaround to find if the caret position is changed with\n          // the keypress.\n          // TODO: Have a look at range, week, time, time, date, datetime-local.\n          if (textLength) {\n            const selection = dom.getSelection(element);\n            if (selection) {\n              const initialLength = selection.toString().length;\n              const isBackward = key === Keys.ArrowLeft || key === Keys.ArrowUp;\n              selection.modify(\"extend\", isBackward ? \"backward\" : \"forward\", \"character\");\n              if (initialLength !== selection.toString().length) {\n                // The caret is moved, so, we're not on the edge of the value.\n                // Restore original selection.\n                selection.modify(\"extend\", isBackward ? \"forward\" : \"backward\", \"character\");\n                return true;\n              } else {\n                textLength = 0;\n              }\n            }\n          }\n        } else {\n          const selStart = element.selectionStart;\n          if (selStart === null) {\n            // Do not ignore not text editable inputs like checkboxes and radios (but ignore hidden).\n            return type === \"hidden\";\n          }\n          selectionStart = selStart || 0;\n          selectionEnd = element.selectionEnd || 0;\n        }\n      } else if (element.contentEditable === \"true\") {\n        asyncRet = new (getPromise(this._win))(resolve => {\n          this._ignoredInputResolve = value => {\n            delete this._ignoredInputResolve;\n            resolve(value);\n          };\n          const win = this._win();\n          if (this._ignoredInputTimer) {\n            win.clearTimeout(this._ignoredInputTimer);\n          }\n          const {\n            anchorNode: prevAnchorNode,\n            focusNode: prevFocusNode,\n            anchorOffset: prevAnchorOffset,\n            focusOffset: prevFocusOffset\n          } = dom.getSelection(element) || {};\n          // Get selection gives incorrect value if we call it syncronously onKeyDown.\n          this._ignoredInputTimer = win.setTimeout(() => {\n            var _a, _b, _c;\n            delete this._ignoredInputTimer;\n            const {\n              anchorNode,\n              focusNode,\n              anchorOffset,\n              focusOffset\n            } = dom.getSelection(element) || {};\n            if (anchorNode !== prevAnchorNode || focusNode !== prevFocusNode || anchorOffset !== prevAnchorOffset || focusOffset !== prevFocusOffset) {\n              (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n              return;\n            }\n            selectionStart = anchorOffset || 0;\n            selectionEnd = focusOffset || 0;\n            textLength = ((_b = element.textContent) === null || _b === void 0 ? void 0 : _b.length) || 0;\n            if (anchorNode && focusNode) {\n              if (dom.nodeContains(element, anchorNode) && dom.nodeContains(element, focusNode)) {\n                if (anchorNode !== element) {\n                  let anchorFound = false;\n                  const addOffsets = node => {\n                    if (node === anchorNode) {\n                      anchorFound = true;\n                    } else if (node === focusNode) {\n                      return true;\n                    }\n                    const nodeText = node.textContent;\n                    if (nodeText && !dom.getFirstChild(node)) {\n                      const len = nodeText.length;\n                      if (anchorFound) {\n                        if (focusNode !== anchorNode) {\n                          selectionEnd += len;\n                        }\n                      } else {\n                        selectionStart += len;\n                        selectionEnd += len;\n                      }\n                    }\n                    let stop = false;\n                    for (let e = dom.getFirstChild(node); e && !stop; e = e.nextSibling) {\n                      stop = addOffsets(e);\n                    }\n                    return stop;\n                  };\n                  addOffsets(element);\n                }\n              }\n            }\n            (_c = this._ignoredInputResolve) === null || _c === void 0 ? void 0 : _c.call(this, true);\n          }, 0);\n        });\n      }\n      if (asyncRet && !(await asyncRet)) {\n        return true;\n      }\n      if (selectionStart !== selectionEnd) {\n        return true;\n      }\n      if (selectionStart > 0 && (key === Keys.ArrowLeft || key === Keys.ArrowUp || key === Keys.Home)) {\n        return true;\n      }\n      if (selectionStart < textLength && (key === Keys.ArrowRight || key === Keys.ArrowDown || key === Keys.End)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction observeMutations(doc, tabster, updateTabsterByAttribute, syncState) {\n  if (typeof MutationObserver === \"undefined\") {\n    return () => {\n      /* Noop */\n    };\n  }\n  const getWindow = tabster.getWindow;\n  let elementByUId;\n  const onMutation = mutations => {\n    var _a, _b, _c, _d, _e;\n    const removedNodes = new Set();\n    for (const mutation of mutations) {\n      const target = mutation.target;\n      const removed = mutation.removedNodes;\n      const added = mutation.addedNodes;\n      if (mutation.type === \"attributes\") {\n        if (mutation.attributeName === TABSTER_ATTRIBUTE_NAME) {\n          // removedNodes helps to make sure we are not recreating things\n          // for the removed elements.\n          // For some reason, if we do removeChild() and setAttribute() on the\n          // removed child in the same tick, both the child removal and the attribute\n          // change will be present in the mutation records. And the attribute change\n          // will follow the child removal.\n          // So, we remember the removed nodes and ignore attribute changes for them.\n          if (!removedNodes.has(target)) {\n            updateTabsterByAttribute(tabster, target);\n          }\n        }\n      } else {\n        for (let i = 0; i < removed.length; i++) {\n          const removedNode = removed[i];\n          removedNodes.add(removedNode);\n          updateTabsterElements(removedNode, true);\n          (_b = (_a = tabster._dummyObserver).domChanged) === null || _b === void 0 ? void 0 : _b.call(_a, target);\n        }\n        for (let i = 0; i < added.length; i++) {\n          updateTabsterElements(added[i]);\n          (_d = (_c = tabster._dummyObserver).domChanged) === null || _d === void 0 ? void 0 : _d.call(_c, target);\n        }\n      }\n    }\n    removedNodes.clear();\n    (_e = tabster.modalizer) === null || _e === void 0 ? void 0 : _e.hiddenUpdate();\n  };\n  function updateTabsterElements(node, removed) {\n    if (!elementByUId) {\n      elementByUId = getInstanceContext(getWindow).elementByUId;\n    }\n    processNode(node, removed);\n    const walker = createElementTreeWalker(doc, node, element => {\n      return processNode(element, removed);\n    });\n    if (walker) {\n      while (walker.nextNode()) {\n        /* Iterating for the sake of calling processNode() callback. */\n      }\n    }\n  }\n  function processNode(element, removed) {\n    var _a;\n    if (!element.getAttribute) {\n      // It might actually be a text node.\n      return NodeFilter.FILTER_SKIP;\n    }\n    const uid = element.__tabsterElementUID;\n    if (uid && elementByUId) {\n      if (removed) {\n        delete elementByUId[uid];\n      } else {\n        (_a = elementByUId[uid]) !== null && _a !== void 0 ? _a : elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n      }\n    }\n    if (getTabsterOnElement(tabster, element) || element.hasAttribute(TABSTER_ATTRIBUTE_NAME)) {\n      updateTabsterByAttribute(tabster, element, removed);\n    }\n    return NodeFilter.FILTER_SKIP;\n  }\n  const observer = dom.createMutationObserver(onMutation);\n  if (syncState) {\n    updateTabsterElements(getWindow().document.body);\n  }\n  observer.observe(doc, {\n    childList: true,\n    subtree: true,\n    attributes: true,\n    attributeFilter: [TABSTER_ATTRIBUTE_NAME]\n  });\n  return () => {\n    observer.disconnect();\n  };\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst _conditionCheckTimeout = 100;\nclass ObservedElementAPI extends Subscribable {\n  constructor(tabster) {\n    super();\n    this._waiting = {};\n    this._lastRequestFocusId = 0;\n    this._observedById = {};\n    this._observedByName = {};\n    this._currentRequestTimestamp = 0;\n    this._onFocus = e => {\n      if (e) {\n        const current = this._currentRequest;\n        if (current) {\n          const delta = Date.now() - this._currentRequestTimestamp;\n          const settleTime = 300;\n          if (delta >= settleTime) {\n            // Giving some time for the focus to settle before\n            // automatically cancelling the current request on focus change.\n            delete this._currentRequest;\n            // Provide callback to access focused element using WeakRef to avoid memory leaks\n            const elementRef = new WeakRef(e);\n            current.diagnostics.getCancelTriggeringElement = () => {\n              var _a;\n              return (_a = elementRef.deref()) !== null && _a !== void 0 ? _a : null;\n            };\n            current.diagnostics.reason = ObservedElementFailureReasons.CanceledFocusChange;\n            current.cancel();\n          }\n        }\n      }\n    };\n    this.onObservedElementUpdate = element => {\n      var _a, _b;\n      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;\n      const uid = getElementUId(this._win, element);\n      let info = this._observedById[uid];\n      if (observed && documentContains(element.ownerDocument, element)) {\n        const isNewElement = !info;\n        if (!info) {\n          info = this._observedById[uid] = {\n            element: new WeakHTMLElement(this._win, element)\n          };\n        }\n        observed.names.sort();\n        const observedNames = observed.names;\n        const prevNames = info.prevNames; // prevNames are already sorted\n        if (this._isObservedNamesUpdated(observedNames, prevNames)) {\n          if (prevNames) {\n            prevNames.forEach(prevName => {\n              const obn = this._observedByName[prevName];\n              if (obn && obn[uid]) {\n                if (Object.keys(obn).length > 1) {\n                  delete obn[uid];\n                } else {\n                  delete this._observedByName[prevName];\n                }\n              }\n            });\n          }\n          info.prevNames = observedNames;\n          this._notifyObservedElementChange(element, observedNames, prevNames, isNewElement);\n        }\n        observedNames.forEach(observedName => {\n          let obn = this._observedByName[observedName];\n          if (!obn) {\n            obn = this._observedByName[observedName] = {};\n          }\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          obn[uid] = info;\n          this._waitConditional(observedName);\n        });\n      } else if (info) {\n        const prevNames = info.prevNames;\n        if (prevNames) {\n          prevNames.forEach(prevName => {\n            const obn = this._observedByName[prevName];\n            if (obn && obn[uid]) {\n              if (Object.keys(obn).length > 1) {\n                delete obn[uid];\n              } else {\n                delete this._observedByName[prevName];\n              }\n            }\n          });\n          (_b = this.onObservedElementChange) === null || _b === void 0 ? void 0 : _b.call(this, {\n            element,\n            type: \"removed\",\n            names: [],\n            removedNames: prevNames\n          });\n        }\n        delete this._observedById[uid];\n      }\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    });\n  }\n  dispose() {\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n    for (const key of Object.keys(this._waiting)) {\n      this._rejectWaiting(key);\n    }\n    this._observedById = {};\n    this._observedByName = {};\n    this.onObservedElementChange = undefined;\n  }\n  _rejectWaiting(key, shouldResolve) {\n    const w = this._waiting[key];\n    if (w) {\n      const win = this._win();\n      if (w.timer) {\n        win.clearTimeout(w.timer);\n      }\n      if (w.conditionTimer) {\n        win.clearTimeout(w.conditionTimer);\n      }\n      if (!shouldResolve && w.reject) {\n        w.reject();\n      } else if (shouldResolve && w.resolve) {\n        w.resolve(null);\n      }\n      delete this._waiting[key];\n    }\n  }\n  _populateTimeoutDiagnostics(request, observedName, timeout, startTime) {\n    const elementInDOM = this.getElement(observedName);\n    const inDOM = !!elementInDOM;\n    let isAccessible;\n    let isFocusable;\n    let reason;\n    if (!elementInDOM) {\n      reason = ObservedElementFailureReasons.TimeoutElementNotInDOM;\n    } else {\n      isAccessible = this._tabster.focusable.isAccessible(elementInDOM);\n      isFocusable = this._tabster.focusable.isFocusable(elementInDOM, true);\n      if (!isAccessible) {\n        reason = ObservedElementFailureReasons.TimeoutElementNotAccessible;\n      } else if (!isFocusable) {\n        reason = ObservedElementFailureReasons.TimeoutElementNotFocusable;\n      } else {\n        reason = ObservedElementFailureReasons.TimeoutElementNotReady;\n      }\n    }\n    request.diagnostics.reason = reason;\n    request.diagnostics.waitForElementDuration = Date.now() - startTime;\n    request.diagnostics.targetState = {\n      inDOM,\n      isAccessible,\n      isFocusable\n    };\n  }\n  _isObservedNamesUpdated(cur, prev) {\n    if (!prev || cur.length !== prev.length) {\n      return true;\n    }\n    for (let i = 0; i < cur.length; ++i) {\n      if (cur[i] !== prev[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _notifyObservedElementChange(element, observedNames, prevNames, isNewElement) {\n    if (!this.onObservedElementChange) {\n      return;\n    }\n    const addedNames = observedNames.filter(name => !prevNames || !prevNames.includes(name));\n    const removedNames = prevNames ? prevNames.filter(name => !observedNames.includes(name)) : [];\n    if (isNewElement) {\n      // Brand new element added\n      this.onObservedElementChange({\n        element,\n        type: \"added\",\n        names: observedNames,\n        addedNames: observedNames\n      });\n    } else if (addedNames.length > 0 || removedNames.length > 0) {\n      // Existing element with names updated\n      this.onObservedElementChange({\n        element,\n        type: \"updated\",\n        names: observedNames,\n        addedNames: addedNames.length > 0 ? addedNames : undefined,\n        removedNames: removedNames.length > 0 ? removedNames : undefined\n      });\n    }\n  }\n  /**\n   * Returns all registered observed names with their respective elements and full names arrays\n   *\n   * @returns Map<string, Array<{ element: HTMLElement; names: string[] }>> A map where keys are observed names\n   * and values are arrays of objects containing the element and its complete names array (in the order they were defined)\n   */\n  getAllObservedElements() {\n    const result = new Map();\n    for (const name of Object.keys(this._observedByName)) {\n      const elementsWithNames = [];\n      const observed = this._observedByName[name];\n      for (const uid of Object.keys(observed)) {\n        const el = observed[uid].element.get();\n        if (el) {\n          const info = this._observedById[uid];\n          elementsWithNames.push({\n            element: el,\n            names: (info === null || info === void 0 ? void 0 : info.prevNames) || []\n          });\n        }\n      }\n      if (elementsWithNames.length > 0) {\n        result.set(name, elementsWithNames);\n      }\n    }\n    return result;\n  }\n  /**\n   * Returns existing element by observed name\n   *\n   * @param observedName An observed name\n   * @param accessibility Optionally, return only if the element is accessible or focusable\n   * @returns HTMLElement | null\n   */\n  getElement(observedName, accessibility) {\n    const o = this._observedByName[observedName];\n    if (o) {\n      for (const uid of Object.keys(o)) {\n        let el = o[uid].element.get() || null;\n        if (el) {\n          if (accessibility === ObservedElementAccessibilities.Accessible && !this._tabster.focusable.isAccessible(el) || accessibility === ObservedElementAccessibilities.Focusable && !this._tabster.focusable.isFocusable(el, true)) {\n            el = null;\n          }\n        } else {\n          delete o[uid];\n          delete this._observedById[uid];\n        }\n        return el;\n      }\n    }\n    return null;\n  }\n  /**\n   * Waits for the element to appear in the DOM and returns it.\n   *\n   * @param observedName An observed name\n   * @param timeout Wait no longer than this timeout\n   * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it\n   * @returns Promise<HTMLElement | null>\n   */\n  waitElement(observedName, timeout, accessibility) {\n    const startTime = Date.now();\n    const el = this.getElement(observedName, accessibility);\n    if (el) {\n      return {\n        result: getPromise(this._win).resolve(el),\n        cancel: () => {\n          /**/\n        },\n        status: ObservedElementRequestStatuses.Succeeded,\n        diagnostics: {\n          waitForElementDuration: Date.now() - startTime\n        }\n      };\n    }\n    let prefix;\n    if (accessibility === ObservedElementAccessibilities.Accessible) {\n      prefix = \"a\";\n    } else if (accessibility === ObservedElementAccessibilities.Focusable) {\n      prefix = \"f\";\n    } else {\n      prefix = \"_\";\n    }\n    const key = prefix + observedName;\n    let w = this._waiting[key];\n    if (w && w.request) {\n      return w.request;\n    }\n    w = this._waiting[key] = {\n      timer: this._win().setTimeout(() => {\n        if (w.conditionTimer) {\n          this._win().clearTimeout(w.conditionTimer);\n        }\n        delete this._waiting[key];\n        if (w.request) {\n          w.request.status = ObservedElementRequestStatuses.TimedOut;\n          this._populateTimeoutDiagnostics(w.request, observedName, timeout, startTime);\n        }\n        if (w.resolve) {\n          w.resolve(null);\n        }\n      }, timeout)\n    };\n    const promise = new (getPromise(this._win))((resolve, reject) => {\n      w.resolve = resolve;\n      w.reject = reject;\n    }).catch(() => {\n      // Ignore the error, it is expected to be rejected when the request is canceled.\n      return null;\n    });\n    const request = {\n      result: promise,\n      cancel: () => {\n        if (request.status === ObservedElementRequestStatuses.Waiting) {\n          // cancel() function is callable by user, someone might call it after request is finished,\n          // we are making sure that status of a finished request is not overriden.\n          request.status = ObservedElementRequestStatuses.Canceled;\n          request.diagnostics.waitForElementDuration = Date.now() - startTime;\n        }\n        this._rejectWaiting(key, true);\n      },\n      status: ObservedElementRequestStatuses.Waiting,\n      diagnostics: {}\n    };\n    w.request = request;\n    if (accessibility && this.getElement(observedName)) {\n      // If the observed element is alread in DOM, but not accessible yet,\n      // we need to run the wait logic.\n      this._waitConditional(observedName);\n    }\n    return request;\n  }\n  requestFocus(observedName, timeout, options = {}) {\n    const requestId = ++this._lastRequestFocusId;\n    const currentRequestFocus = this._currentRequest;\n    if (currentRequestFocus) {\n      currentRequestFocus.diagnostics.reason = ObservedElementFailureReasons.SupersededByNewRequest;\n      currentRequestFocus.cancel();\n    }\n    const request = this.waitElement(observedName, timeout, ObservedElementAccessibilities.Focusable);\n    this._currentRequest = request;\n    this._currentRequestTimestamp = Date.now();\n    const ret = {\n      result: request.result.then(element => {\n        if (this._lastRequestFocusId !== requestId) {\n          request.diagnostics.reason = ObservedElementFailureReasons.SupersededByNewRequest;\n          return false;\n        }\n        if (!element) {\n          // Element was not found - reason should already be set by timeout or cancellation\n          // If not set, default to timeout reason\n          if (request.diagnostics.reason === undefined) {\n            request.diagnostics.reason = ObservedElementFailureReasons.TimeoutElementNotInDOM;\n          }\n          return false;\n        }\n        const focusResult = this._tabster.focusedElement.focus(element, true, undefined, options.preventScroll);\n        if (!focusResult) {\n          // Focus call failed\n          request.diagnostics.reason = ObservedElementFailureReasons.FocusCallFailed;\n        }\n        return focusResult;\n      }),\n      cancel: () => {\n        request.cancel();\n      },\n      status: request.status,\n      diagnostics: request.diagnostics\n    };\n    request.result.finally(() => {\n      if (this._currentRequest === request) {\n        delete this._currentRequest;\n      }\n      ret.status = request.status;\n    });\n    return ret;\n  }\n  _waitConditional(observedName) {\n    const waitingElementKey = \"_\" + observedName;\n    const waitingAccessibleElementKey = \"a\" + observedName;\n    const waitingFocusableElementKey = \"f\" + observedName;\n    const waitingElement = this._waiting[waitingElementKey];\n    const waitingAccessibleElement = this._waiting[waitingAccessibleElementKey];\n    const waitingFocusableElement = this._waiting[waitingFocusableElementKey];\n    const win = this._win();\n    const resolve = (element, key, waiting, accessibility) => {\n      var _a;\n      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;\n      if (!observed || !observed.names.includes(observedName)) {\n        return;\n      }\n      if (waiting.timer) {\n        win.clearTimeout(waiting.timer);\n      }\n      delete this._waiting[key];\n      if (waiting.request) {\n        waiting.request.status = ObservedElementRequestStatuses.Succeeded;\n      }\n      if (waiting.resolve) {\n        waiting.resolve(element);\n      }\n      this.trigger(element, {\n        names: [observedName],\n        details: observed.details,\n        accessibility\n      });\n    };\n    if (waitingElement) {\n      const element = this.getElement(observedName);\n      if (element && documentContains(element.ownerDocument, element)) {\n        resolve(element, waitingElementKey, waitingElement, ObservedElementAccessibilities.Any);\n      }\n    }\n    if (waitingAccessibleElement && !waitingAccessibleElement.conditionTimer) {\n      const resolveAccessible = () => {\n        const element = this.getElement(observedName);\n        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isAccessible(element)) {\n          resolve(element, waitingAccessibleElementKey, waitingAccessibleElement, ObservedElementAccessibilities.Accessible);\n        } else {\n          waitingAccessibleElement.conditionTimer = win.setTimeout(resolveAccessible, _conditionCheckTimeout);\n        }\n      };\n      resolveAccessible();\n    }\n    if (waitingFocusableElement && !waitingFocusableElement.conditionTimer) {\n      const resolveFocusable = () => {\n        const element = this.getElement(observedName);\n        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isFocusable(element, true)) {\n          resolve(element, waitingFocusableElementKey, waitingFocusableElement, ObservedElementAccessibilities.Focusable);\n        } else {\n          waitingFocusableElement.conditionTimer = win.setTimeout(resolveFocusable, _conditionCheckTimeout);\n        }\n      };\n      resolveFocusable();\n    }\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst defaultProps = {\n  areaClass: \"tabster-focus-outline-area\",\n  outlineClass: \"tabster-focus-outline\",\n  outlineColor: \"#ff4500\",\n  outlineWidth: 2,\n  zIndex: 2147483647\n};\nlet _props = defaultProps;\nclass OutlinePosition {\n  constructor(left, top, right, bottom) {\n    this.left = left;\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n  }\n  equalsTo(other) {\n    return this.left === other.left && this.top === other.top && this.right === other.right && this.bottom === other.bottom;\n  }\n  clone() {\n    return new OutlinePosition(this.left, this.top, this.right, this.bottom);\n  }\n}\nclass OutlineAPI {\n  constructor(tabster) {\n    this._isVisible = false;\n    this._allOutlineElements = [];\n    this._init = () => {\n      this._tabster.keyboardNavigation.subscribe(this._onKeyboardNavigationStateChanged);\n      this._tabster.focusedElement.subscribe(this._onFocus);\n      const win = this._win();\n      win.addEventListener(\"scroll\", this._onScroll, true); // Capture!\n      if (this._fullScreenEventName) {\n        win.document.addEventListener(this._fullScreenEventName, this._onFullScreenChanged);\n      }\n    };\n    this._onFullScreenChanged = e => {\n      if (!this._fullScreenElementName || !e.target) {\n        return;\n      }\n      const target = e.target.body || e.target;\n      const outlineElements = this._getDOM(target);\n      if (target.ownerDocument && outlineElements) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const fsElement = target.ownerDocument[this._fullScreenElementName];\n        if (fsElement) {\n          fsElement.appendChild(outlineElements.container);\n          this._fullScreenElement = fsElement;\n        } else {\n          target.ownerDocument.body.appendChild(outlineElements.container);\n          this._fullScreenElement = undefined;\n        }\n      }\n    };\n    this._onKeyboardNavigationStateChanged = () => {\n      this._onFocus(this._tabster.focusedElement.getFocusedElement());\n    };\n    this._onFocus = e => {\n      if (!this._updateElement(e) && this._isVisible) {\n        this._setVisibility(false);\n      }\n    };\n    this._onScroll = e => {\n      if (!this._outlinedElement || !OutlineAPI._isParentChild(e.target, this._outlinedElement)) {\n        return;\n      }\n      this._curPos = undefined;\n      this._setOutlinePosition();\n    };\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    tabster.queueInit(this._init);\n    if (typeof document !== \"undefined\") {\n      if (\"onfullscreenchange\" in document) {\n        this._fullScreenEventName = \"fullscreenchange\";\n        this._fullScreenElementName = \"fullscreenElement\";\n      } else if (\"onwebkitfullscreenchange\" in document) {\n        this._fullScreenEventName = \"webkitfullscreenchange\";\n        this._fullScreenElementName = \"webkitFullscreenElement\";\n      } else if (\"onmozfullscreenchange\" in document) {\n        this._fullScreenEventName = \"mozfullscreenchange\";\n        this._fullScreenElementName = \"mozFullScreenElement\";\n      } else if (\"onmsfullscreenchange\" in document) {\n        this._fullScreenEventName = \"msfullscreenchange\";\n        this._fullScreenElementName = \"msFullscreenElement\";\n      }\n    }\n  }\n  setup(props) {\n    _props = {\n      ..._props,\n      ...props\n    };\n    const win = this._win();\n    if (!win.__tabsterOutline) {\n      win.__tabsterOutline = {};\n    }\n    if (!win.__tabsterOutline.style) {\n      win.__tabsterOutline.style = appendStyles(win.document, _props);\n    }\n    if (!props || !props.areaClass) {\n      win.document.body.classList.add(defaultProps.areaClass);\n    } else {\n      win.document.body.classList.remove(defaultProps.areaClass);\n    }\n  }\n  dispose() {\n    const win = this._win();\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      this._updateTimer = undefined;\n    }\n    this._tabster.keyboardNavigation.unsubscribe(this._onKeyboardNavigationStateChanged);\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n    win.removeEventListener(\"scroll\", this._onScroll, true);\n    if (this._fullScreenEventName) {\n      win.document.removeEventListener(this._fullScreenEventName, this._onFullScreenChanged);\n    }\n    this._allOutlineElements.forEach(outlineElements => this._removeDOM(outlineElements.container));\n    this._allOutlineElements = [];\n    delete this._outlinedElement;\n    delete this._curPos;\n    delete this._curOutlineElements;\n    delete this._fullScreenElement;\n  }\n  _shouldShowCustomOutline(element) {\n    const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n    if (tabsterOnElement && tabsterOnElement.outline && tabsterOnElement.outline.isIgnored) {\n      return false;\n    }\n    for (let i = element; i; i = i.parentElement) {\n      if (i.classList && i.classList.contains(_props.areaClass)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _updateElement(e) {\n    this._outlinedElement = undefined;\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n      this._updateTimer = undefined;\n    }\n    this._curPos = undefined;\n    if (!this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n      return false;\n    }\n    if (e) {\n      // TODO: It's hard (and not necessary) to come up with every possible\n      // condition when there should be no outline, it's better to add an\n      // API to customize the ignores.\n      if (e.tagName === \"INPUT\") {\n        const inputType = e.type;\n        const outlinedInputTypes = {\n          button: true,\n          checkbox: true,\n          file: true,\n          image: true,\n          radio: true,\n          range: true,\n          reset: true,\n          submit: true\n        };\n        if (!(inputType in outlinedInputTypes)) {\n          return false;\n        }\n      } else if (e.tagName === \"TEXTAREA\" || e.contentEditable === \"true\" || e.tagName === \"IFRAME\") {\n        return false;\n      }\n      if (!this._shouldShowCustomOutline(e)) {\n        return false;\n      }\n      if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n        this._outlinedElement = e;\n        this._updateOutline();\n      }\n      return true;\n    }\n    return false;\n  }\n  _updateOutline() {\n    this._setOutlinePosition();\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n      this._updateTimer = undefined;\n    }\n    if (!this._outlinedElement) {\n      return;\n    }\n    this._updateTimer = this._win().setTimeout(() => {\n      this._updateTimer = undefined;\n      this._updateOutline();\n    }, 30);\n  }\n  _setVisibility(visible) {\n    this._isVisible = visible;\n    if (this._curOutlineElements) {\n      if (visible) {\n        this._curOutlineElements.container.classList.add(`${_props.outlineClass}_visible`);\n      } else {\n        this._curOutlineElements.container.classList.remove(`${_props.outlineClass}_visible`);\n        this._curPos = undefined;\n      }\n    }\n  }\n  _setOutlinePosition() {\n    if (!this._outlinedElement) {\n      return;\n    }\n    let boundingRect = getBoundingRect(this._win, this._outlinedElement);\n    const position = new OutlinePosition(boundingRect.left, boundingRect.top, boundingRect.right, boundingRect.bottom);\n    if (this._curPos && position.equalsTo(this._curPos)) {\n      return;\n    }\n    const outlineElements = this._getDOM(this._outlinedElement);\n    const win = this._outlinedElement.ownerDocument && this._outlinedElement.ownerDocument.defaultView;\n    if (!outlineElements || !win) {\n      return;\n    }\n    if (this._curOutlineElements !== outlineElements) {\n      this._setVisibility(false);\n      this._curOutlineElements = outlineElements;\n    }\n    this._curPos = position;\n    const p = position.clone();\n    let hasAbsolutePositionedParent = false;\n    let hasFixedPositionedParent = false;\n    const container = outlineElements.container;\n    const scrollingElement = container && container.ownerDocument && container.ownerDocument.scrollingElement;\n    if (!scrollingElement) {\n      return;\n    }\n    for (let parent = this._outlinedElement.parentElement; parent && parent.nodeType === Node.ELEMENT_NODE; parent = parent.parentElement) {\n      // The element might be partially visible within its scrollable parent,\n      // reduce the bounding rect if this is the case.\n      if (parent === this._fullScreenElement) {\n        break;\n      }\n      boundingRect = getBoundingRect(this._win, parent);\n      const win = parent.ownerDocument && parent.ownerDocument.defaultView;\n      if (!win) {\n        return;\n      }\n      const computedStyle = win.getComputedStyle(parent);\n      const position = computedStyle.position;\n      if (position === \"absolute\") {\n        hasAbsolutePositionedParent = true;\n      } else if (position === \"fixed\" || position === \"sticky\") {\n        hasFixedPositionedParent = true;\n      }\n      if (computedStyle.overflow === \"visible\") {\n        continue;\n      }\n      if (!hasAbsolutePositionedParent && !hasFixedPositionedParent || computedStyle.overflow === \"hidden\") {\n        if (boundingRect.left > p.left) {\n          p.left = boundingRect.left;\n        }\n        if (boundingRect.top > p.top) {\n          p.top = boundingRect.top;\n        }\n        if (boundingRect.right < p.right) {\n          p.right = boundingRect.right;\n        }\n        if (boundingRect.bottom < p.bottom) {\n          p.bottom = boundingRect.bottom;\n        }\n      }\n    }\n    const allRect = getBoundingRect(this._win, scrollingElement);\n    const allWidth = allRect.left + allRect.right;\n    const allHeight = allRect.top + allRect.bottom;\n    const ow = _props.outlineWidth;\n    p.left = p.left > ow ? p.left - ow : 0;\n    p.top = p.top > ow ? p.top - ow : 0;\n    p.right = p.right < allWidth - ow ? p.right + ow : allWidth;\n    p.bottom = p.bottom < allHeight - ow ? p.bottom + ow : allHeight;\n    const width = p.right - p.left;\n    const height = p.bottom - p.top;\n    if (width > ow * 2 && height > ow * 2) {\n      const leftBorderNode = outlineElements.left;\n      const topBorderNode = outlineElements.top;\n      const rightBorderNode = outlineElements.right;\n      const bottomBorderNode = outlineElements.bottom;\n      const sx = this._fullScreenElement || hasFixedPositionedParent ? 0 : win.pageXOffset;\n      const sy = this._fullScreenElement || hasFixedPositionedParent ? 0 : win.pageYOffset;\n      container.style.position = hasFixedPositionedParent ? \"fixed\" : \"absolute\";\n      container.style.background = _props.outlineColor;\n      leftBorderNode.style.width = rightBorderNode.style.width = topBorderNode.style.height = bottomBorderNode.style.height = _props.outlineWidth + \"px\";\n      leftBorderNode.style.left = topBorderNode.style.left = bottomBorderNode.style.left = p.left + sx + \"px\";\n      rightBorderNode.style.left = p.left + sx + width - ow + \"px\";\n      leftBorderNode.style.top = rightBorderNode.style.top = topBorderNode.style.top = p.top + sy + \"px\";\n      bottomBorderNode.style.top = p.top + sy + height - ow + \"px\";\n      leftBorderNode.style.height = rightBorderNode.style.height = height + \"px\";\n      topBorderNode.style.width = bottomBorderNode.style.width = width + \"px\";\n      this._setVisibility(true);\n    } else {\n      this._setVisibility(false);\n    }\n  }\n  _getDOM(contextElement) {\n    const doc = contextElement.ownerDocument;\n    const win = doc && doc.defaultView;\n    if (!doc || !win || !win.__tabsterOutline) {\n      return undefined;\n    }\n    if (!win.__tabsterOutline.style) {\n      win.__tabsterOutline.style = appendStyles(doc, _props);\n    }\n    if (!win.__tabsterOutline.elements) {\n      const outlineElements = {\n        container: doc.createElement(\"div\"),\n        left: doc.createElement(\"div\"),\n        top: doc.createElement(\"div\"),\n        right: doc.createElement(\"div\"),\n        bottom: doc.createElement(\"div\")\n      };\n      outlineElements.container.className = _props.outlineClass;\n      outlineElements.left.className = `${_props.outlineClass}__left`;\n      outlineElements.top.className = `${_props.outlineClass}__top`;\n      outlineElements.right.className = `${_props.outlineClass}__right`;\n      outlineElements.bottom.className = `${_props.outlineClass}__bottom`;\n      outlineElements.container.appendChild(outlineElements.left);\n      outlineElements.container.appendChild(outlineElements.top);\n      outlineElements.container.appendChild(outlineElements.right);\n      outlineElements.container.appendChild(outlineElements.bottom);\n      doc.body.appendChild(outlineElements.container);\n      win.__tabsterOutline.elements = outlineElements;\n      // TODO: Make a garbage collector to remove the references\n      // to the outlines which are nowhere in the DOM anymore.\n      this._allOutlineElements.push(outlineElements);\n    }\n    return win.__tabsterOutline.elements;\n  }\n  _removeDOM(contextElement) {\n    const win = contextElement.ownerDocument && contextElement.ownerDocument.defaultView;\n    const outline = win && win.__tabsterOutline;\n    if (!outline) {\n      return;\n    }\n    if (outline.style && outline.style.parentNode) {\n      outline.style.parentNode.removeChild(outline.style);\n      delete outline.style;\n    }\n    const outlineElements = outline && outline.elements;\n    if (outlineElements) {\n      if (outlineElements.container.parentNode) {\n        outlineElements.container.parentNode.removeChild(outlineElements.container);\n      }\n      delete outline.elements;\n    }\n  }\n  static _isParentChild(parent, child) {\n    return child === parent ||\n    // tslint:disable-next-line:no-bitwise\n    !!(parent.compareDocumentPosition(child) & document.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n}\nfunction appendStyles(document, props) {\n  const style = document.createElement(\"style\");\n  style.type = \"text/css\";\n  style.appendChild(document.createTextNode(getOutlineStyles(props)));\n  document.head.appendChild(style);\n  return style;\n}\nfunction getOutlineStyles(props) {\n  return `\n.${props.areaClass} *, .${props.areaClass} *:focus {\noutline: none !important;\n}\n\n.${props.outlineClass} {\ndisplay: none;\nposition: absolute;\nwidth: 0;\nheight: 0;\nleft: 0;\ntop: 0;\nz-index: ${props.zIndex};\n}\n\n.${props.outlineClass}.${props.outlineClass}_visible {\ndisplay: block;\n}\n\n.${props.outlineClass}__left,\n.${props.outlineClass}__top,\n.${props.outlineClass}__right,\n.${props.outlineClass}__bottom {\nposition: absolute;\nbackground: inherit;\n}`;\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Allows default or user focus behaviour on the DOM subtree\n * i.e. Tabster will not control focus events within an uncontrolled area\n */\nclass UncontrolledAPI {\n  constructor(isUncontrolledCompletely) {\n    this._isUncontrolledCompletely = isUncontrolledCompletely;\n  }\n  isUncontrolledCompletely(element, completely) {\n    var _a;\n    const isUncontrolledCompletely = (_a = this._isUncontrolledCompletely) === null || _a === void 0 ? void 0 : _a.call(this, element, completely);\n    // If isUncontrolledCompletely callback is not defined or returns undefined, then the default\n    // behaviour is to return the uncontrolled.completely value from the element.\n    return isUncontrolledCompletely === undefined ? completely : isUncontrolledCompletely;\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass Restorer extends TabsterPart {\n  constructor(tabster, element, props) {\n    var _a;\n    super(tabster, element, props);\n    this._hasFocus = false;\n    this._onFocusOut = e => {\n      var _a;\n      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n      if (element && e.relatedTarget === null) {\n        element.dispatchEvent(new RestorerRestoreFocusEvent());\n      }\n      if (element && !dom.nodeContains(element, e.relatedTarget)) {\n        this._hasFocus = false;\n      }\n    };\n    this._onFocusIn = () => {\n      this._hasFocus = true;\n    };\n    if (this._props.type === RestorerTypes.Source) {\n      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n      element === null || element === void 0 ? void 0 : element.addEventListener(\"focusout\", this._onFocusOut);\n      element === null || element === void 0 ? void 0 : element.addEventListener(\"focusin\", this._onFocusIn);\n      // set hasFocus when the instance is created, in case focus has already moved within it\n      this._hasFocus = dom.nodeContains(element, element && dom.getActiveElement(element.ownerDocument));\n    }\n  }\n  dispose() {\n    var _a;\n    if (this._props.type === RestorerTypes.Source) {\n      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n      element === null || element === void 0 ? void 0 : element.removeEventListener(\"focusout\", this._onFocusOut);\n      element === null || element === void 0 ? void 0 : element.removeEventListener(\"focusin\", this._onFocusIn);\n      if (this._hasFocus) {\n        const doc = this._tabster.getWindow().document;\n        doc.body.dispatchEvent(new RestorerRestoreFocusEvent());\n      }\n    }\n  }\n}\nclass History {\n  constructor(getWindow) {\n    this._stack = [];\n    this._getWindow = getWindow;\n  }\n  /**\n   * Push a weak element to the top of the history stack.\n   * If the stack is full, the bottom weak element is removed.\n   * If the element is already at the top of the stack, it is not duplicated.\n   */\n  push(element) {\n    var _a;\n    // Don't duplicate the top of history\n    if (((_a = this._stack[this._stack.length - 1]) === null || _a === void 0 ? void 0 : _a.get()) === element) {\n      return;\n    }\n    if (this._stack.length > History.DEPTH) {\n      this._stack.shift();\n    }\n    this._stack.push(new WeakHTMLElement(this._getWindow, element));\n  }\n  /**\n   * Pop the first element from the history that satisfies the callback.\n   * The history is searched from the top to the bottom (from the most recent to the least recent).\n   *\n   * If a weak reference to the element is broken,\n   * or the element is no longer in the DOM,\n   * the element is removed from the top of the stack while popping.\n   *\n   * If no matching element is found, undefined is returned.\n   * If the stack is empty, undefined is returned.\n   */\n  pop(filter = () => true) {\n    var _a;\n    const doc = this._getWindow().document;\n    for (let index = this._stack.length - 1; index >= 0; index--) {\n      const maybeElement = (_a = this._stack.pop()) === null || _a === void 0 ? void 0 : _a.get();\n      if (maybeElement && dom.nodeContains(doc.body, dom.getParentElement(maybeElement)) && filter(maybeElement)) {\n        return maybeElement;\n      }\n    }\n    return undefined;\n  }\n}\nHistory.DEPTH = 10;\nclass RestorerAPI {\n  constructor(tabster) {\n    this._onRestoreFocus = e => {\n      var _a, _b;\n      this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);\n      // ShadowDOM will have shadowRoot as e.target.\n      const source = e.composedPath()[0];\n      if (source) {\n        // source id must be recovered before source is removed from DOM\n        // otherwise it'll be unreachable\n        // (as tabster on element will not be available through getTabsterOnElement)\n        const sourceId = (_b = (_a = getTabsterOnElement(this._tabster, source)) === null || _a === void 0 ? void 0 : _a.restorer) === null || _b === void 0 ? void 0 : _b.getProps().id;\n        this._focusedElementState.requestAsyncFocus(AsyncFocusSources.Restorer, () => this._restoreFocus(source, sourceId), 0);\n      }\n    };\n    this._onFocusIn = element => {\n      var _a;\n      if (!element) {\n        return;\n      }\n      const tabsterAttribute = getTabsterOnElement(this._tabster, element);\n      if (((_a = tabsterAttribute === null || tabsterAttribute === void 0 ? void 0 : tabsterAttribute.restorer) === null || _a === void 0 ? void 0 : _a.getProps().type) !== RestorerTypes.Target) {\n        return;\n      }\n      this._history.push(element);\n    };\n    this._restoreFocus = (source, sourceId) => {\n      var _a;\n      // don't restore focus if focus isn't lost to body\n      const doc = this._getWindow().document;\n      if (dom.getActiveElement(doc) !== doc.body) {\n        return;\n      }\n      if (\n      // clicking on any empty space focuses body - this is can be a false positive\n      !this._keyboardNavState.isNavigatingWithKeyboard() &&\n      // Source no longer exists on DOM - always restore focus\n      dom.nodeContains(doc.body, source)) {\n        return;\n      }\n      const getId = element => {\n        var _a, _b;\n        const restorerProps = (_b = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.restorer) === null || _b === void 0 ? void 0 : _b.getProps();\n        // We return id or undefined if there is actual restorer on the element,\n        // and null otherwise. To filter out elements that had restorers in their lifetime\n        // but don't have them anymore.\n        return restorerProps ? restorerProps.id : null;\n      };\n      // sourceId is undefined or string, if there is no Restorer on the target, the element will\n      // be filtered out because getId() will return null.\n      (_a = this._history.pop(target => sourceId === getId(target))) === null || _a === void 0 ? void 0 : _a.focus();\n    };\n    this._tabster = tabster;\n    this._getWindow = tabster.getWindow;\n    this._getWindow().addEventListener(RestorerRestoreFocusEventName, this._onRestoreFocus);\n    this._history = new History(this._getWindow);\n    this._keyboardNavState = tabster.keyboardNavigation;\n    this._focusedElementState = tabster.focusedElement;\n    this._focusedElementState.subscribe(this._onFocusIn);\n  }\n  dispose() {\n    const win = this._getWindow();\n    this._focusedElementState.unsubscribe(this._onFocusIn);\n    this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);\n    win.removeEventListener(RestorerRestoreFocusEventName, this._onRestoreFocus);\n  }\n  createRestorer(element, props) {\n    const restorer = new Restorer(this._tabster, element, props);\n    // Focus might already be on a restorer target when it gets created so the focusin will not do anything\n    if (props.type === RestorerTypes.Target && dom.getActiveElement(element.ownerDocument) === element) {\n      this._history.push(element);\n    }\n    return restorer;\n  }\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction getActiveElement(doc) {\n  var _a;\n  let activeElement = doc.activeElement;\n  while ((_a = activeElement === null || activeElement === void 0 ? void 0 : activeElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.activeElement) {\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\nfunction nodeContains(node, otherNode) {\n  var _a, _b;\n  if (!node || !otherNode) {\n    return false;\n  }\n  let currentNode = otherNode;\n  while (currentNode) {\n    if (currentNode === node) {\n      return true;\n    }\n    if (typeof currentNode.assignedElements !== \"function\" && ((_a = currentNode.assignedSlot) === null || _a === void 0 ? void 0 : _a.parentNode)) {\n      // Element is slotted\n      currentNode = (_b = currentNode.assignedSlot) === null || _b === void 0 ? void 0 : _b.parentNode;\n    } else if (currentNode.nodeType === document.DOCUMENT_FRAGMENT_NODE) {\n      // Element is in shadow root\n      currentNode = currentNode.host;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n  return false;\n}\nfunction getParentNode(node) {\n  if (!node) {\n    return null;\n  }\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && node.host) {\n    return node.host;\n  }\n  return node.parentNode;\n}\nfunction getParentElement(element) {\n  for (let parentNode = getParentNode(element); parentNode; parentNode = getParentNode(parentNode)) {\n    if (parentNode.nodeType === Node.ELEMENT_NODE) {\n      return parentNode;\n    }\n  }\n  return null;\n}\nfunction getFirstChild(node) {\n  if (!node) {\n    return null;\n  }\n  if (node.shadowRoot) {\n    const child = getFirstChild(node.shadowRoot);\n    if (child) {\n      return child;\n    }\n    // If the attached shadowRoot has no children, just try ordinary children,\n    // that might come after.\n  }\n  return node.firstChild;\n}\nfunction getLastChild$1(node) {\n  if (!node) {\n    return null;\n  }\n  if (!node.lastChild && node.shadowRoot) {\n    return getLastChild$1(node.shadowRoot);\n  }\n  return node.lastChild;\n}\nfunction getNextSibling(node) {\n  return (node === null || node === void 0 ? void 0 : node.nextSibling) || null;\n}\nfunction getPreviousSibling(node) {\n  var _a;\n  if (!node) {\n    return null;\n  }\n  let sibling = node.previousSibling;\n  if (!sibling && ((_a = node.parentElement) === null || _a === void 0 ? void 0 : _a.shadowRoot)) {\n    sibling = getLastChild$1(node.parentElement.shadowRoot);\n  }\n  return sibling;\n}\nfunction getFirstElementChild(element) {\n  let child = getFirstChild(element);\n  while (child && child.nodeType !== Node.ELEMENT_NODE) {\n    child = getNextSibling(child);\n  }\n  return child;\n}\nfunction getLastElementChild(element) {\n  let child = getLastChild$1(element);\n  while (child && child.nodeType !== Node.ELEMENT_NODE) {\n    child = getPreviousSibling(child);\n  }\n  return child;\n}\nfunction getNextElementSibling(element) {\n  let sibling = getNextSibling(element);\n  while (sibling && sibling.nodeType !== Node.ELEMENT_NODE) {\n    sibling = getNextSibling(sibling);\n  }\n  return sibling;\n}\nfunction getPreviousElementSibling(element) {\n  let sibling = getPreviousSibling(element);\n  while (sibling && sibling.nodeType !== Node.ELEMENT_NODE) {\n    sibling = getPreviousSibling(sibling);\n  }\n  return sibling;\n}\nfunction appendChild(parent, child) {\n  const shadowRoot = parent.shadowRoot;\n  return shadowRoot ? shadowRoot.appendChild(child) : parent.appendChild(child);\n}\nfunction insertBefore(parent, child, referenceChild) {\n  const shadowRoot = parent.shadowRoot;\n  return shadowRoot ? shadowRoot.insertBefore(child, referenceChild) : parent.insertBefore(child, referenceChild);\n}\nfunction getSelection(ref) {\n  var _a;\n  const win = (_a = ref.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n  if (!win) {\n    return null;\n  }\n  for (let el = ref; el; el = el.parentNode) {\n    if (el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      const tmp = el;\n      // ShadowRoot.getSelection() exists only in Chrome.\n      if (tmp.getSelection) {\n        return tmp.getSelection() || null;\n      }\n      break;\n    }\n  }\n  return win.getSelection() || null;\n}\nfunction getElementsByName(referenceElement, name) {\n  for (let el = referenceElement; el; el = el.parentNode) {\n    if (el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      // Shadow root doesn't have getElementsByName()...\n      return el.querySelectorAll(`[name=${name}]`);\n    }\n  }\n  return referenceElement.ownerDocument.getElementsByName(name);\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction getLastChild(container) {\n  let lastChild = null;\n  for (let i = getLastElementChild(container); i; i = getLastElementChild(i)) {\n    lastChild = i;\n  }\n  return lastChild || undefined;\n}\nclass ShadowTreeWalker {\n  constructor(doc, root, whatToShow, filter) {\n    this._walkerStack = [];\n    this._currentSetFor = new Set();\n    this._acceptNode = node => {\n      var _a;\n      if (node.nodeType === Node.ELEMENT_NODE) {\n        const shadowRoot = node.shadowRoot;\n        if (shadowRoot) {\n          const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n            acceptNode: this._acceptNode\n          });\n          this._walkerStack.unshift(walker);\n          return NodeFilter.FILTER_ACCEPT;\n        } else {\n          if (typeof this.filter === \"function\") {\n            return this.filter(node);\n          } else if ((_a = this.filter) === null || _a === void 0 ? void 0 : _a.acceptNode) {\n            return this.filter.acceptNode(node);\n          } else if (this.filter === null) {\n            return NodeFilter.FILTER_ACCEPT;\n          }\n        }\n      }\n      return NodeFilter.FILTER_SKIP;\n    };\n    this._doc = doc;\n    this.root = root;\n    this.filter = filter !== null && filter !== void 0 ? filter : null;\n    this.whatToShow = whatToShow !== null && whatToShow !== void 0 ? whatToShow : NodeFilter.SHOW_ALL;\n    this._currentNode = root;\n    this._walkerStack.unshift(doc.createTreeWalker(root, whatToShow, this._acceptNode));\n    const shadowRoot = root.shadowRoot;\n    if (shadowRoot) {\n      const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n        acceptNode: this._acceptNode\n      });\n      this._walkerStack.unshift(walker);\n    }\n  }\n  get currentNode() {\n    return this._currentNode;\n  }\n  set currentNode(node) {\n    if (!nodeContains(this.root, node)) {\n      throw new Error(\"Cannot set currentNode to a node that is not contained by the root node.\");\n    }\n    const walkers = [];\n    let curNode = node;\n    let currentWalkerCurrentNode = node;\n    this._currentNode = node;\n    while (curNode && curNode !== this.root) {\n      if (curNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n        const shadowRoot = curNode;\n        const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n          acceptNode: this._acceptNode\n        });\n        walkers.push(walker);\n        walker.currentNode = currentWalkerCurrentNode;\n        this._currentSetFor.add(walker);\n        curNode = currentWalkerCurrentNode = shadowRoot.host;\n      } else {\n        curNode = curNode.parentNode;\n      }\n    }\n    const walker = this._doc.createTreeWalker(this.root, this.whatToShow, {\n      acceptNode: this._acceptNode\n    });\n    walkers.push(walker);\n    walker.currentNode = currentWalkerCurrentNode;\n    this._currentSetFor.add(walker);\n    this._walkerStack = walkers;\n  }\n  firstChild() {\n    if (true) {\n      throw new Error(\"Method not implemented.\");\n    }\n    return null;\n  }\n  lastChild() {\n    if (true) {\n      throw new Error(\"Method not implemented.\");\n    }\n    return null;\n  }\n  nextNode() {\n    var _a;\n    const nextNode = this._walkerStack[0].nextNode();\n    if (nextNode) {\n      const shadowRoot = nextNode.shadowRoot;\n      if (shadowRoot) {\n        let nodeResult;\n        if (typeof this.filter === \"function\") {\n          nodeResult = this.filter(nextNode);\n        } else if ((_a = this.filter) === null || _a === void 0 ? void 0 : _a.acceptNode) {\n          nodeResult = this.filter.acceptNode(nextNode);\n        }\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          return nextNode;\n        }\n        // _acceptNode should have added new walker for this shadow,\n        // go in recursively.\n        return this.nextNode();\n      }\n      return nextNode;\n    } else {\n      if (this._walkerStack.length > 1) {\n        this._walkerStack.shift();\n        return this.nextNode();\n      } else {\n        return null;\n      }\n    }\n  }\n  previousNode() {\n    var _a, _b;\n    const currentWalker = this._walkerStack[0];\n    if (currentWalker.currentNode === currentWalker.root) {\n      if (this._currentSetFor.has(currentWalker)) {\n        this._currentSetFor.delete(currentWalker);\n        if (this._walkerStack.length > 1) {\n          this._walkerStack.shift();\n          return this.previousNode();\n        } else {\n          return null;\n        }\n      }\n      const lastChild = getLastChild(currentWalker.root);\n      if (lastChild) {\n        currentWalker.currentNode = lastChild;\n        let nodeResult;\n        if (typeof this.filter === \"function\") {\n          nodeResult = this.filter(lastChild);\n        } else if ((_a = this.filter) === null || _a === void 0 ? void 0 : _a.acceptNode) {\n          nodeResult = this.filter.acceptNode(lastChild);\n        }\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          return lastChild;\n        }\n      }\n    }\n    const previousNode = currentWalker.previousNode();\n    if (previousNode) {\n      const shadowRoot = previousNode.shadowRoot;\n      if (shadowRoot) {\n        let nodeResult;\n        if (typeof this.filter === \"function\") {\n          nodeResult = this.filter(previousNode);\n        } else if ((_b = this.filter) === null || _b === void 0 ? void 0 : _b.acceptNode) {\n          nodeResult = this.filter.acceptNode(previousNode);\n        }\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          return previousNode;\n        }\n        // _acceptNode should have added new walker for this shadow,\n        // go in recursively.\n        return this.previousNode();\n      }\n      return previousNode;\n    } else {\n      if (this._walkerStack.length > 1) {\n        this._walkerStack.shift();\n        return this.previousNode();\n      } else {\n        return null;\n      }\n    }\n  }\n  nextSibling() {\n    if (true) {\n      throw new Error(\"Method not implemented.\");\n    }\n    return null;\n  }\n  previousSibling() {\n    if (true) {\n      throw new Error(\"Method not implemented.\");\n    }\n    return null;\n  }\n  parentNode() {\n    if (true) {\n      throw new Error(\"Method not implemented.\");\n    }\n    return null;\n  }\n}\nfunction createShadowTreeWalker(doc, root, whatToShow, filter) {\n  return new ShadowTreeWalker(doc, root, whatToShow, filter);\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass ShadowMutationObserver {\n  static _overrideAttachShadow(win) {\n    const origAttachShadow = win.Element.prototype.attachShadow;\n    if (origAttachShadow.__origAttachShadow) {\n      return;\n    }\n    Element.prototype.attachShadow = function (options) {\n      const shadowRoot = origAttachShadow.call(this, options);\n      for (const shadowObserver of ShadowMutationObserver._shadowObservers) {\n        shadowObserver._addSubObserver(shadowRoot);\n      }\n      return shadowRoot;\n    };\n    Element.prototype.attachShadow.__origAttachShadow = origAttachShadow;\n  }\n  constructor(callback) {\n    this._isObserving = false;\n    this._callbackWrapper = (mutations, observer) => {\n      for (const mutation of mutations) {\n        if (mutation.type === \"childList\") {\n          const removed = mutation.removedNodes;\n          const added = mutation.addedNodes;\n          for (let i = 0; i < removed.length; i++) {\n            this._walkShadows(removed[i], true);\n          }\n          for (let i = 0; i < added.length; i++) {\n            this._walkShadows(added[i]);\n          }\n        }\n      }\n      this._callback(mutations, observer);\n    };\n    this._callback = callback;\n    this._observer = new MutationObserver(this._callbackWrapper);\n    this._subObservers = new Map();\n  }\n  _addSubObserver(shadowRoot) {\n    if (!this._options || !this._callback || this._subObservers.has(shadowRoot)) {\n      return;\n    }\n    if (this._options.subtree && nodeContains(this._root, shadowRoot)) {\n      const subObserver = new MutationObserver(this._callbackWrapper);\n      this._subObservers.set(shadowRoot, subObserver);\n      if (this._isObserving) {\n        subObserver.observe(shadowRoot, this._options);\n      }\n      this._walkShadows(shadowRoot);\n    }\n  }\n  disconnect() {\n    this._isObserving = false;\n    delete this._options;\n    ShadowMutationObserver._shadowObservers.delete(this);\n    for (const subObserver of this._subObservers.values()) {\n      subObserver.disconnect();\n    }\n    this._subObservers.clear();\n    this._observer.disconnect();\n  }\n  observe(target, options) {\n    const doc = target.nodeType === Node.DOCUMENT_NODE ? target : target.ownerDocument;\n    const win = doc === null || doc === void 0 ? void 0 : doc.defaultView;\n    if (!doc || !win) {\n      return;\n    }\n    ShadowMutationObserver._overrideAttachShadow(win);\n    ShadowMutationObserver._shadowObservers.add(this);\n    this._root = target;\n    this._options = options;\n    this._isObserving = true;\n    this._observer.observe(target, options);\n    this._walkShadows(target);\n  }\n  _walkShadows(target, remove) {\n    const doc = target.nodeType === Node.DOCUMENT_NODE ? target : target.ownerDocument;\n    if (!doc) {\n      return;\n    }\n    if (target === doc) {\n      target = doc.body;\n    } else {\n      const shadowRoot = target.shadowRoot;\n      if (shadowRoot) {\n        this._addSubObserver(shadowRoot);\n        return;\n      }\n    }\n    const walker = doc.createTreeWalker(target, NodeFilter.SHOW_ELEMENT, {\n      acceptNode: node => {\n        if (node.nodeType === Node.ELEMENT_NODE) {\n          if (remove) {\n            const subObserver = this._subObservers.get(node);\n            if (subObserver) {\n              subObserver.disconnect();\n              this._subObservers.delete(node);\n            }\n          } else {\n            const shadowRoot = node.shadowRoot;\n            if (shadowRoot) {\n              this._addSubObserver(shadowRoot);\n            }\n          }\n        }\n        return NodeFilter.FILTER_SKIP;\n      }\n    });\n    walker.nextNode();\n  }\n  takeRecords() {\n    const records = this._observer.takeRecords();\n    for (const subObserver of this._subObservers.values()) {\n      records.push(...subObserver.takeRecords());\n    }\n    return records;\n  }\n}\nShadowMutationObserver._shadowObservers = /*#__PURE__*/new Set();\nfunction createShadowMutationObserver(callback) {\n  return new ShadowMutationObserver(callback);\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nfunction shadowQuerySelector(node, selector, all) {\n  // TODO: This is probably slow. Optimize to use each shadowRoot's querySelector/querySelectorAll\n  //       instead of walking the tree.\n  const elements = [];\n  walk(node, selector);\n  return elements;\n  function walk(from, selector) {\n    let el = null;\n    const walker = document.createTreeWalker(from, NodeFilter.SHOW_ELEMENT, {\n      acceptNode: n => {\n        if (n.nodeType === Node.ELEMENT_NODE) {\n          if (n.matches(selector)) {\n            el = n;\n            elements.push(el);\n            return all ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;\n          }\n          const shadowRoot = n.shadowRoot;\n          if (shadowRoot) {\n            walk(shadowRoot, selector);\n            return !all && elements.length ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n          }\n        }\n        return NodeFilter.FILTER_SKIP;\n      }\n    });\n    walker.nextNode();\n  }\n}\nfunction querySelectorAll(node, selector) {\n  return shadowQuerySelector(node, selector, true);\n}\nfunction querySelector(node, selector) {\n  return shadowQuerySelector(node, selector, false)[0] || null;\n}\nfunction getElementById(doc, id) {\n  return querySelector(doc, \"#\" + id);\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n// TODO: The functions below do not consider Shadow DOM slots yet. We will be adding\n// support for slots as the need arises.\n\nvar shadowDOMAPI = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    appendChild: appendChild,\n    createMutationObserver: createShadowMutationObserver,\n    createTreeWalker: createShadowTreeWalker,\n    getActiveElement: getActiveElement,\n    getElementById: getElementById,\n    getElementsByName: getElementsByName,\n    getFirstChild: getFirstChild,\n    getFirstElementChild: getFirstElementChild,\n    getLastChild: getLastChild$1,\n    getLastElementChild: getLastElementChild,\n    getNextElementSibling: getNextElementSibling,\n    getNextSibling: getNextSibling,\n    getParentElement: getParentElement,\n    getParentNode: getParentNode,\n    getPreviousElementSibling: getPreviousElementSibling,\n    getPreviousSibling: getPreviousSibling,\n    getSelection: getSelection,\n    insertBefore: insertBefore,\n    nodeContains: nodeContains,\n    querySelector: querySelector,\n    querySelectorAll: querySelectorAll\n});\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass Tabster {\n  constructor(tabster) {\n    this.keyboardNavigation = tabster.keyboardNavigation;\n    this.focusedElement = tabster.focusedElement;\n    this.focusable = tabster.focusable;\n    this.root = tabster.root;\n    this.uncontrolled = tabster.uncontrolled;\n    this.core = tabster;\n  }\n}\n/**\n * Extends Window to include an internal Tabster instance.\n */\nclass TabsterCore {\n  constructor(win, props) {\n    var _a, _b;\n    this._forgetMemorizedElements = [];\n    this._wrappers = new Set();\n    this._initQueue = [];\n    this._version = \"8.7.0\";\n    this._noop = false;\n    this.getWindow = () => {\n      if (!this._win) {\n        throw new Error(\"Using disposed Tabster.\");\n      }\n      return this._win;\n    };\n    this._storage = createWeakMap(win);\n    this._win = win;\n    const getWindow = this.getWindow;\n    if (props === null || props === void 0 ? void 0 : props.DOMAPI) {\n      setDOMAPI({\n        ...props.DOMAPI\n      });\n    }\n    this.keyboardNavigation = new KeyboardNavigationState(getWindow);\n    this.focusedElement = new FocusedElementState(this, getWindow);\n    this.focusable = new FocusableAPI(this);\n    this.root = new RootAPI(this, props === null || props === void 0 ? void 0 : props.autoRoot);\n    this.uncontrolled = new UncontrolledAPI(\n    // TODO: Remove checkUncontrolledTrappingFocus in the next major version.\n    (props === null || props === void 0 ? void 0 : props.checkUncontrolledCompletely) || (props === null || props === void 0 ? void 0 : props.checkUncontrolledTrappingFocus));\n    this.controlTab = (_a = props === null || props === void 0 ? void 0 : props.controlTab) !== null && _a !== void 0 ? _a : true;\n    this.rootDummyInputs = !!(props === null || props === void 0 ? void 0 : props.rootDummyInputs);\n    this._dummyObserver = new DummyInputObserver(getWindow);\n    this.getParent = (_b = props === null || props === void 0 ? void 0 : props.getParent) !== null && _b !== void 0 ? _b : dom.getParentNode;\n    this.internal = {\n      stopObserver: () => {\n        if (this._unobserve) {\n          this._unobserve();\n          delete this._unobserve;\n        }\n      },\n      resumeObserver: syncState => {\n        if (!this._unobserve) {\n          const doc = getWindow().document;\n          this._unobserve = observeMutations(doc, this, updateTabsterByAttribute, syncState);\n        }\n      }\n    };\n    startFakeWeakRefsCleanup(getWindow);\n    // Gives a tick to the host app to initialize other tabster\n    // APIs before tabster starts observing attributes.\n    this.queueInit(() => {\n      this.internal.resumeObserver(true);\n    });\n  }\n  /**\n   * Merges external props with the current props. Not all\n   * props can/should be mergeable, so let's add more as we move on.\n   * @param props Tabster props\n   */\n  _mergeProps(props) {\n    var _a;\n    if (!props) {\n      return;\n    }\n    this.getParent = (_a = props.getParent) !== null && _a !== void 0 ? _a : this.getParent;\n  }\n  createTabster(noRefCount, props) {\n    const wrapper = new Tabster(this);\n    if (!noRefCount) {\n      this._wrappers.add(wrapper);\n    }\n    this._mergeProps(props);\n    return wrapper;\n  }\n  disposeTabster(wrapper, allInstances) {\n    if (allInstances) {\n      this._wrappers.clear();\n    } else {\n      this._wrappers.delete(wrapper);\n    }\n    if (this._wrappers.size === 0) {\n      this.dispose();\n    }\n  }\n  dispose() {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    this.internal.stopObserver();\n    const win = this._win;\n    win === null || win === void 0 ? void 0 : win.clearTimeout(this._initTimer);\n    delete this._initTimer;\n    this._initQueue = [];\n    this._forgetMemorizedElements = [];\n    if (win && this._forgetMemorizedTimer) {\n      win.clearTimeout(this._forgetMemorizedTimer);\n      delete this._forgetMemorizedTimer;\n    }\n    (_a = this.outline) === null || _a === void 0 ? void 0 : _a.dispose();\n    (_b = this.crossOrigin) === null || _b === void 0 ? void 0 : _b.dispose();\n    (_c = this.deloser) === null || _c === void 0 ? void 0 : _c.dispose();\n    (_d = this.groupper) === null || _d === void 0 ? void 0 : _d.dispose();\n    (_e = this.mover) === null || _e === void 0 ? void 0 : _e.dispose();\n    (_f = this.modalizer) === null || _f === void 0 ? void 0 : _f.dispose();\n    (_g = this.observedElement) === null || _g === void 0 ? void 0 : _g.dispose();\n    (_h = this.restorer) === null || _h === void 0 ? void 0 : _h.dispose();\n    this.keyboardNavigation.dispose();\n    this.focusable.dispose();\n    this.focusedElement.dispose();\n    this.root.dispose();\n    this._dummyObserver.dispose();\n    stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);\n    clearElementCache(this.getWindow);\n    this._storage = new WeakMap();\n    this._wrappers.clear();\n    if (win) {\n      disposeInstanceContext(win);\n      delete win.__tabsterInstance;\n      delete this._win;\n    }\n  }\n  storageEntry(element, addremove) {\n    const storage = this._storage;\n    let entry = storage.get(element);\n    if (entry) {\n      if (addremove === false && Object.keys(entry).length === 0) {\n        storage.delete(element);\n      }\n    } else if (addremove === true) {\n      entry = {};\n      storage.set(element, entry);\n    }\n    return entry;\n  }\n  forceCleanup() {\n    if (!this._win) {\n      return;\n    }\n    this._forgetMemorizedElements.push(this._win.document.body);\n    if (this._forgetMemorizedTimer) {\n      return;\n    }\n    this._forgetMemorizedTimer = this._win.setTimeout(() => {\n      delete this._forgetMemorizedTimer;\n      for (let el = this._forgetMemorizedElements.shift(); el; el = this._forgetMemorizedElements.shift()) {\n        clearElementCache(this.getWindow, el);\n        FocusedElementState.forgetMemorized(this.focusedElement, el);\n      }\n    }, 0);\n    cleanupFakeWeakRefs(this.getWindow, true);\n  }\n  queueInit(callback) {\n    var _a;\n    if (!this._win) {\n      return;\n    }\n    this._initQueue.push(callback);\n    if (!this._initTimer) {\n      this._initTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.setTimeout(() => {\n        delete this._initTimer;\n        this.drainInitQueue();\n      }, 0);\n    }\n  }\n  drainInitQueue() {\n    if (!this._win) {\n      return;\n    }\n    const queue = this._initQueue;\n    // Resetting the queue before calling the callbacks to avoid recursion.\n    this._initQueue = [];\n    queue.forEach(callback => callback());\n  }\n}\nfunction forceCleanup(tabster) {\n  // The only legit case for calling this method is when you've completely removed\n  // the application DOM and not going to add the new one for a while.\n  const tabsterCore = tabster.core;\n  tabsterCore.forceCleanup();\n}\n/**\n * Creates an instance of Tabster, returns the current window instance if it already exists.\n */\nfunction createTabster(win, props) {\n  let tabster = getCurrentTabster(win);\n  if (tabster) {\n    return tabster.createTabster(false, props);\n  }\n  tabster = new TabsterCore(win, props);\n  win.__tabsterInstance = tabster;\n  return tabster.createTabster();\n}\n/**\n * Returns an instance of Tabster if it was created before or null.\n */\nfunction getTabster(win) {\n  const tabster = getCurrentTabster(win);\n  return tabster ? tabster.createTabster(true) : null;\n}\nfunction getShadowDOMAPI() {\n  return shadowDOMAPI;\n}\n/**\n * Creates a new groupper instance or returns an existing one\n * @param tabster Tabster instance\n */\nfunction getGroupper(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.groupper) {\n    tabsterCore.groupper = new GroupperAPI(tabsterCore, tabsterCore.getWindow);\n  }\n  return tabsterCore.groupper;\n}\n/**\n * Creates a new mover instance or returns an existing one\n * @param tabster Tabster instance\n */\nfunction getMover(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.mover) {\n    tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);\n  }\n  return tabsterCore.mover;\n}\nfunction getOutline(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.outline) {\n    tabsterCore.outline = new OutlineAPI(tabsterCore);\n  }\n  return tabsterCore.outline;\n}\n/**\n * Creates a new new deloser instance or returns an existing one\n * @param tabster Tabster instance\n * @param props Deloser props\n */\nfunction getDeloser(tabster, props) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.deloser) {\n    tabsterCore.deloser = new DeloserAPI(tabsterCore, props);\n  }\n  return tabsterCore.deloser;\n}\n/**\n * Creates a new modalizer instance or returns an existing one\n * @param tabster Tabster instance\n * @param alwaysAccessibleSelector When Modalizer is active, we put\n * aria-hidden to everything else to hide it from screen readers. This CSS\n * selector allows to exclude some elements from this behaviour. For example,\n * this could be used to exclude aria-live region with the application-wide\n * status announcements.\n * @param accessibleCheck An optional callback that will be called when\n * active Modalizer wants to hide an element that doesn't belong to it from\n * the screen readers by setting aria-hidden. Similar to alwaysAccessibleSelector\n * but allows to address the elements programmatically rather than with a selector.\n * If the callback returns true, the element will not receive aria-hidden.\n */\nfunction getModalizer(tabster,\n// @deprecated use accessibleCheck.\nalwaysAccessibleSelector, accessibleCheck) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.modalizer) {\n    tabsterCore.modalizer = new ModalizerAPI(tabsterCore, alwaysAccessibleSelector, accessibleCheck);\n  }\n  return tabsterCore.modalizer;\n}\nfunction getObservedElement(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.observedElement) {\n    tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);\n  }\n  return tabsterCore.observedElement;\n}\nfunction getCrossOrigin(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.crossOrigin) {\n    getDeloser(tabster);\n    getModalizer(tabster);\n    getMover(tabster);\n    getGroupper(tabster);\n    getOutline(tabster);\n    getObservedElement(tabster);\n    tabsterCore.crossOrigin = new CrossOriginAPI(tabsterCore);\n  }\n  return tabsterCore.crossOrigin;\n}\nfunction getInternal(tabster) {\n  const tabsterCore = tabster.core;\n  return tabsterCore.internal;\n}\nfunction getRestorer(tabster) {\n  const tabsterCore = tabster.core;\n  if (!tabsterCore.restorer) {\n    tabsterCore.restorer = new RestorerAPI(tabsterCore);\n  }\n  return tabsterCore.restorer;\n}\nfunction disposeTabster(tabster, allInstances) {\n  tabster.core.disposeTabster(tabster, allInstances);\n}\n/**\n * Returns an instance of Tabster if it already exists on the window .\n * @param win window instance that could contain an Tabster instance.\n */\nfunction getCurrentTabster(win) {\n  return win.__tabsterInstance;\n}\n/**\n * Allows to make Tabster non operational. Intended for performance debugging (and other\n * kinds of debugging), you can switch Tabster off without changing the application code\n * that consumes it.\n * @param tabster a reference created by createTabster().\n * @param noop true if you want to make Tabster noop, false if you want to turn it back.\n */\nfunction makeNoOp(tabster, noop) {\n  const core = tabster.core;\n  if (core._noop !== noop) {\n    core._noop = noop;\n    const processNode = element => {\n      if (!element.getAttribute) {\n        return NodeFilter.FILTER_SKIP;\n      }\n      if (getTabsterOnElement(core, element) || element.hasAttribute(TABSTER_ATTRIBUTE_NAME)) {\n        updateTabsterByAttribute(core, element);\n      }\n      return NodeFilter.FILTER_SKIP;\n    };\n    const doc = core.getWindow().document;\n    const body = doc.body;\n    processNode(body);\n    const walker = createElementTreeWalker(doc, body, processNode);\n    if (walker) {\n      while (walker.nextNode()) {\n        /* Iterating for the sake of calling processNode() callback. */\n      }\n    }\n  }\n}\nfunction isNoOp(tabster) {\n  return tabster._noop;\n}\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nvar Types = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nvar EventsTypes = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\n/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/** @deprecated This function is obsolete, use native element.dispatchEvent(new GroupperMoveFocusEvent(...)). */\nfunction dispatchGroupperMoveFocusEvent(target, action) {\n  return target.dispatchEvent(new GroupperMoveFocusEvent({\n    action\n  }));\n}\n/** @deprecated This function is obsolete, use native element.dispatchEvent(new MoverMoveFocusEvent(...)). */\nfunction dispatchMoverMoveFocusEvent(target, key) {\n  return target.dispatchEvent(new MoverMoveFocusEvent({\n    key\n  }));\n}\n/** @deprecated This function is obsolete, use native element.dispatchEvent(new MoverMemorizedElementEvent(...)). */\nfunction dispatchMoverMemorizedElementEvent(target, memorizedElement) {\n  return target.dispatchEvent(new MoverMemorizedElementEvent({\n    memorizedElement\n  }));\n}\n\n\n//# sourceMappingURL=tabster.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGFic3Rlci9kaXN0L3RhYnN0ZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0c7O0FBRXhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2S0FBNks7QUFDL007QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxhQUFhO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsWUFBWSxJQUFzQztBQUNsRCx5REFBeUQsRUFBRTtBQUMzRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVksU0FBUyxJQUFzQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWMsU0FBUyxJQUFzQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTLElBQXNDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZLFNBQVMsSUFBc0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVksU0FBUyxJQUFzQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLElBQXNDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUyxJQUFzQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxJQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxrQkFBa0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0osb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSTtBQUN6QixzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGlCQUFpQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsUUFBUSxvREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBILGNBQWMsZ0JBQWdCLGdCQUFnQiw0QkFBNEIsaUJBQWlCLGFBQWEsV0FBVztBQUM3TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFlBQVksb0RBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFzQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXNDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtREFBbUQ7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxVQUFVLElBQXNDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxHQUFHO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFlBQVksSUFBc0M7QUFDbEQseURBQXlELEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXNDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxZQUFZLG9EQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQWU7QUFDeEMseUJBQXlCLHFEQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0RBQWU7QUFDM0MsNEJBQTRCLHFEQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXNDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLElBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBc0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBc0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixnQkFBZ0IsSUFBc0M7QUFDdEQ7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsR0FBRztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEdBQUc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQXNDO0FBQ2hEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFVBQVU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsR0FBRztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvREFBZTtBQUMxQywyQkFBMkIscURBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxZQUFZLG9EQUFXO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9EQUFlO0FBQzNDLDRCQUE0QixxREFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvREFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQXNDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxHQUFHO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRLElBQXNDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBc0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVEQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBc0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IscUtBQXFLLFdBQVc7QUFDaEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQVc7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXNDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBc0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXNDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxJQUFJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsR0FBRztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTLElBQXNDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsSUFBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1YsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHdCQUF3QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG9EQUFXO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0JBQXNCLGlCQUFpQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsR0FBRztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsb0JBQW9CO0FBQ2hGLFFBQVE7QUFDUiwrREFBK0Qsb0JBQW9CO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGlEQUFpRDtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9CQUFvQjtBQUM5RCx5Q0FBeUMsb0JBQW9CO0FBQzdELDJDQUEyQyxvQkFBb0I7QUFDL0QsNENBQTRDLG9CQUFvQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGlCQUFpQixNQUFNLGlCQUFpQjtBQUMzQztBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUEsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUI7QUFDNUM7QUFDQTs7QUFFQSxHQUFHLG1CQUFtQjtBQUN0QixHQUFHLG1CQUFtQjtBQUN0QixHQUFHLG1CQUFtQjtBQUN0QixHQUFHLG1CQUFtQjtBQUN0QjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEdBQUc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0JBQW9CO0FBQzlDO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxJQUFJO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFb2dEO0FBQ3BnRCIsInNvdXJjZXMiOlsid2VicGFjazovL3NlYXJjaC1pbnRlbGxpZ2VuY2UtdWkvLi9ub2RlX21vZHVsZXMvdGFic3Rlci9kaXN0L3RhYnN0ZXIuZXNtLmpzPzE0YTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbmF0aXZlRm9jdXMsIEtFWUJPUkdfRk9DVVNJTiwgS0VZQk9SR19GT0NVU09VVCwgY3JlYXRlS2V5Ym9yZywgZGlzcG9zZUtleWJvcmcgfSBmcm9tICdrZXlib3JnJztcblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY29uc3QgVEFCU1RFUl9BVFRSSUJVVEVfTkFNRSA9IFwiZGF0YS10YWJzdGVyXCI7XG5jb25zdCBUQUJTVEVSX0RVTU1ZX0lOUFVUX0FUVFJJQlVURV9OQU1FID0gXCJkYXRhLXRhYnN0ZXItZHVtbXlcIjtcbmNvbnN0IEZPQ1VTQUJMRV9TRUxFQ1RPUiA9IGA6aXMoJHsvKiNfX1BVUkVfXyovW1wiYVtocmVmXVwiLCBcImJ1dHRvblwiLCBcImlucHV0XCIsIFwic2VsZWN0XCIsIFwidGV4dGFyZWFcIiwgXCIqW3RhYmluZGV4XVwiLCBcIipbY29udGVudGVkaXRhYmxlXVwiLCBcImRldGFpbHMgPiBzdW1tYXJ5XCIsIFwiYXVkaW9bY29udHJvbHNdXCIsIFwidmlkZW9bY29udHJvbHNdXCJdLmpvaW4oXCIsIFwiKX0pOm5vdCg6ZGlzYWJsZWQpYDtcbmNvbnN0IEFzeW5jRm9jdXNTb3VyY2VzID0ge1xuICBFc2NhcGVHcm91cHBlcjogMSxcbiAgUmVzdG9yZXI6IDIsXG4gIERlbG9zZXI6IDNcbn07XG5jb25zdCBPYnNlcnZlZEVsZW1lbnRBY2Nlc3NpYmlsaXRpZXMgPSB7XG4gIEFueTogMCxcbiAgQWNjZXNzaWJsZTogMSxcbiAgRm9jdXNhYmxlOiAyXG59O1xuY29uc3QgT2JzZXJ2ZWRFbGVtZW50UmVxdWVzdFN0YXR1c2VzID0ge1xuICBXYWl0aW5nOiAwLFxuICBTdWNjZWVkZWQ6IDEsXG4gIENhbmNlbGVkOiAyLFxuICBUaW1lZE91dDogM1xufTtcbmNvbnN0IE9ic2VydmVkRWxlbWVudEZhaWx1cmVSZWFzb25zID0ge1xuICBDYW5jZWxlZEZvY3VzQ2hhbmdlOiAxLFxuICBUaW1lb3V0RWxlbWVudE5vdEluRE9NOiAyLFxuICBUaW1lb3V0RWxlbWVudE5vdEFjY2Vzc2libGU6IDMsXG4gIFRpbWVvdXRFbGVtZW50Tm90Rm9jdXNhYmxlOiA0LFxuICBUaW1lb3V0RWxlbWVudE5vdFJlYWR5OiA1LFxuICBTdXBlcnNlZGVkQnlOZXdSZXF1ZXN0OiA2LFxuICBGb2N1c0NhbGxGYWlsZWQ6IDdcbn07XG5jb25zdCBSZXN0b3JlRm9jdXNPcmRlcnMgPSB7XG4gIEhpc3Rvcnk6IDAsXG4gIERlbG9zZXJEZWZhdWx0OiAxLFxuICBSb290RGVmYXVsdDogMixcbiAgRGVsb3NlckZpcnN0OiAzLFxuICBSb290Rmlyc3Q6IDRcbn07XG5jb25zdCBEZWxvc2VyU3RyYXRlZ2llcyA9IHtcbiAgLyoqXG4gICAqIElmIHRoZSBmb2N1cyBpcyBsb3N0LCB0aGUgZm9jdXMgd2lsbCBiZSByZXN0b3JlZCBhdXRvbWF0aWNhbGx5IHVzaW5nIGFsbCBhdmFpbGFibGUgZm9jdXMgaGlzdG9yeS5cbiAgICogVGhpcyBpcyB0aGUgZGVmYXVsdCBzdHJhdGVneS5cbiAgICovXG4gIEF1dG86IDAsXG4gIC8qKlxuICAgKiBJZiB0aGUgZm9jdXMgaXMgbG9zdCBmcm9tIHRoaXMgRGVsb3NlciBpbnN0YW5jZSwgdGhlIGZvY3VzIHdpbGwgbm90IGJlIHJlc3RvcmVkIGF1dG9tYXRpY2FsbHkuXG4gICAqIFRoZSBhcHBsaWNhdGlvbiBtaWdodCBsaXN0ZW4gdG8gdGhlIGV2ZW50IGFuZCByZXN0b3JlIHRoZSBmb2N1cyBtYW51YWxseS5cbiAgICogQnV0IGlmIGl0IGlzIGxvc3QgZnJvbSBhbm90aGVyIERlbG9zZXIgaW5zdGFuY2UsIHRoZSBoaXN0b3J5IG9mIHRoaXMgRGVsb3NlciBjb3VsZCBiZSB1c2VkIGZpbmRpbmdcbiAgICogdGhlIGVsZW1lbnQgdG8gZm9jdXMuXG4gICAqL1xuICBNYW51YWw6IDFcbn07XG5jb25zdCBWaXNpYmlsaXRpZXMgPSB7XG4gIEludmlzaWJsZTogMCxcbiAgUGFydGlhbGx5VmlzaWJsZTogMSxcbiAgVmlzaWJsZTogMlxufTtcbmNvbnN0IFJlc3RvcmVyVHlwZXMgPSB7XG4gIFNvdXJjZTogMCxcbiAgVGFyZ2V0OiAxXG59O1xuY29uc3QgTW92ZXJEaXJlY3Rpb25zID0ge1xuICBCb3RoOiAwLFxuICAvLyBEZWZhdWx0LCBib3RoIGxlZnQvdXAga2V5cyBtb3ZlIHRvIHRoZSBwcmV2aW91cywgcmlnaHQvZG93biBtb3ZlIHRvIHRoZSBuZXh0LlxuICBWZXJ0aWNhbDogMSxcbiAgLy8gT25seSB1cC9kb3duIGFycm93cyBtb3ZlIHRvIHRoZSBuZXh0L3ByZXZpb3VzLlxuICBIb3Jpem9udGFsOiAyLFxuICAvLyBPbmx5IGxlZnQvcmlnaHQgYXJyb3dzIG1vdmUgdG8gdGhlIG5leHQvcHJldmlvdXMuXG4gIEdyaWQ6IDMsXG4gIC8vIFR3by1kaW1lbnRpb25hbCBtb3ZlbWVudCBkZXBlbmRpbmcgb24gdGhlIHZpc3VhbCBwbGFjZW1lbnQuXG4gIEdyaWRMaW5lYXI6IDQgLy8gVHdvLWRpbWVudGlvbmFsIG1vdmVtZW50IGRlcGVuZGluZyBvbiB0aGUgdmlzdWFsIHBsYWNlbWVudC4gQWxsb3dzIGxpbmVhciBtb3ZlbWVudC5cbn07XG5jb25zdCBNb3ZlcktleXMgPSB7XG4gIEFycm93VXA6IDEsXG4gIEFycm93RG93bjogMixcbiAgQXJyb3dMZWZ0OiAzLFxuICBBcnJvd1JpZ2h0OiA0LFxuICBQYWdlVXA6IDUsXG4gIFBhZ2VEb3duOiA2LFxuICBIb21lOiA3LFxuICBFbmQ6IDhcbn07XG5jb25zdCBHcm91cHBlclRhYmJhYmlsaXRpZXMgPSB7XG4gIFVubGltaXRlZDogMCxcbiAgTGltaXRlZDogMSxcbiAgLy8gVGhlIHRhYmJhYmlsaXR5IGlzIGxpbWl0ZWQgdG8gdGhlIGNvbnRhaW5lciBhbmQgZXhwbGljaXQgRW50ZXIgaXMgbmVlZGVkIHRvIGdvIGluc2lkZS5cbiAgTGltaXRlZFRyYXBGb2N1czogMiAvLyBUaGUgZm9jdXMgaXMgbGltaXRlZCBhcyBhYm92ZSwgcGx1cyB0cmFwcGVkIHdoZW4gaW5zaWRlLlxufTtcbmNvbnN0IEdyb3VwcGVyTW92ZUZvY3VzQWN0aW9ucyA9IHtcbiAgRW50ZXI6IDEsXG4gIEVzY2FwZTogMlxufTtcbmNvbnN0IFN5c0R1bW15SW5wdXRzUG9zaXRpb25zID0ge1xuICBBdXRvOiAwLFxuICAvLyBUYWJzdGVyIHdpbGwgcGxhY2UgZHVtbXkgaW5wdXRzIGRlcGVuZGluZyBvbiB0aGUgY29udGFpbmVyIHRhZyBuYW1lIGFuZCBvbiB0aGUgZGVmYXVsdCBiZWhhdmlvdXIuXG4gIEluc2lkZTogMSxcbiAgLy8gVGFic3RlciB3aWxsIGFsd2F5cyBwbGFjZSBkdW1teSBpbnB1dHMgaW5zaWRlIHRoZSBjb250YWluZXIuXG4gIE91dHNpZGU6IDIgLy8gVGFic3RlciB3aWxsIGFsd2F5cyBwbGFjZSBkdW1teSBpbnB1dHMgb3V0c2lkZSBvZiB0aGUgY29udGFpbmVyLlxufTtcblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VGFic3Rlck9uRWxlbWVudCh0YWJzdGVyLCBlbGVtZW50KSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IHRhYnN0ZXIuc3RvcmFnZUVudHJ5KGVsZW1lbnQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGFic3Rlcjtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVRhYnN0ZXJCeUF0dHJpYnV0ZSh0YWJzdGVyLCBlbGVtZW50LCBkaXNwb3NlKSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCBuZXdBdHRyVmFsdWUgPSBkaXNwb3NlIHx8IHRhYnN0ZXIuX25vb3AgPyB1bmRlZmluZWQgOiBlbGVtZW50LmdldEF0dHJpYnV0ZShUQUJTVEVSX0FUVFJJQlVURV9OQU1FKTtcbiAgbGV0IGVudHJ5ID0gdGFic3Rlci5zdG9yYWdlRW50cnkoZWxlbWVudCk7XG4gIGxldCBuZXdBdHRyO1xuICBpZiAobmV3QXR0clZhbHVlKSB7XG4gICAgaWYgKG5ld0F0dHJWYWx1ZSAhPT0gKChfYSA9IGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbnRyeS5hdHRyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RyaW5nKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBKU09OLnBhcnNlKG5ld0F0dHJWYWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3VmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIGlzIG5vdCBhIEpTT04gb2JqZWN0LCBnb3QgJyR7bmV3QXR0clZhbHVlfScuYCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3QXR0ciA9IHtcbiAgICAgICAgICBzdHJpbmc6IG5ld0F0dHJWYWx1ZSxcbiAgICAgICAgICBvYmplY3Q6IG5ld1ZhbHVlXG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGRhdGEtdGFic3RlciBhdHRyaWJ1dGUgZXJyb3I6ICR7ZX1gLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbnRyeSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWVudHJ5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBlbnRyeSA9IHRhYnN0ZXIuc3RvcmFnZUVudHJ5KGVsZW1lbnQsIHRydWUpO1xuICB9XG4gIGlmICghZW50cnkudGFic3Rlcikge1xuICAgIGVudHJ5LnRhYnN0ZXIgPSB7fTtcbiAgfVxuICBjb25zdCB0YWJzdGVyT25FbGVtZW50ID0gZW50cnkudGFic3RlciB8fCB7fTtcbiAgY29uc3Qgb2xkVGFic3RlclByb3BzID0gKChfYiA9IGVudHJ5LmF0dHIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vYmplY3QpIHx8IHt9O1xuICBjb25zdCBuZXdUYWJzdGVyUHJvcHMgPSAobmV3QXR0ciA9PT0gbnVsbCB8fCBuZXdBdHRyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXdBdHRyLm9iamVjdCkgfHwge307XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9sZFRhYnN0ZXJQcm9wcykpIHtcbiAgICBpZiAoIW5ld1RhYnN0ZXJQcm9wc1trZXldKSB7XG4gICAgICBpZiAoa2V5ID09PSBcInJvb3RcIikge1xuICAgICAgICBjb25zdCByb290ID0gdGFic3Rlck9uRWxlbWVudFtrZXldO1xuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgIHRhYnN0ZXIucm9vdC5vblJvb3Qocm9vdCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJkZWxvc2VyXCI6XG4gICAgICAgIGNhc2UgXCJyb290XCI6XG4gICAgICAgIGNhc2UgXCJncm91cHBlclwiOlxuICAgICAgICBjYXNlIFwibW9kYWxpemVyXCI6XG4gICAgICAgIGNhc2UgXCJyZXN0b3JlclwiOlxuICAgICAgICBjYXNlIFwibW92ZXJcIjpcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY2FzZS1kZWNsYXJhdGlvbnNcbiAgICAgICAgICBjb25zdCBwYXJ0ID0gdGFic3Rlck9uRWxlbWVudFtrZXldO1xuICAgICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgICBwYXJ0LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0YWJzdGVyT25FbGVtZW50W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib2JzZXJ2ZWRcIjpcbiAgICAgICAgICBkZWxldGUgdGFic3Rlck9uRWxlbWVudFtrZXldO1xuICAgICAgICAgIGlmICh0YWJzdGVyLm9ic2VydmVkRWxlbWVudCkge1xuICAgICAgICAgICAgdGFic3Rlci5vYnNlcnZlZEVsZW1lbnQub25PYnNlcnZlZEVsZW1lbnRVcGRhdGUoZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZm9jdXNhYmxlXCI6XG4gICAgICAgIGNhc2UgXCJvdXRsaW5lXCI6XG4gICAgICAgIGNhc2UgXCJ1bmNvbnRyb2xsZWRcIjpcbiAgICAgICAgY2FzZSBcInN5c1wiOlxuICAgICAgICAgIGRlbGV0ZSB0YWJzdGVyT25FbGVtZW50W2tleV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG5ld1RhYnN0ZXJQcm9wcykpIHtcbiAgICBjb25zdCBzeXMgPSBuZXdUYWJzdGVyUHJvcHMuc3lzO1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlIFwiZGVsb3NlclwiOlxuICAgICAgICBpZiAodGFic3Rlck9uRWxlbWVudC5kZWxvc2VyKSB7XG4gICAgICAgICAgdGFic3Rlck9uRWxlbWVudC5kZWxvc2VyLnNldFByb3BzKG5ld1RhYnN0ZXJQcm9wcy5kZWxvc2VyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGFic3Rlci5kZWxvc2VyKSB7XG4gICAgICAgICAgICB0YWJzdGVyT25FbGVtZW50LmRlbG9zZXIgPSB0YWJzdGVyLmRlbG9zZXIuY3JlYXRlRGVsb3NlcihlbGVtZW50LCBuZXdUYWJzdGVyUHJvcHMuZGVsb3Nlcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRlbG9zZXIgQVBJIHVzZWQgYmVmb3JlIGluaXRpYWxpemF0aW9uLCBwbGVhc2UgY2FsbCBgZ2V0RGVsb3NlcigpYFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicm9vdFwiOlxuICAgICAgICBpZiAodGFic3Rlck9uRWxlbWVudC5yb290KSB7XG4gICAgICAgICAgdGFic3Rlck9uRWxlbWVudC5yb290LnNldFByb3BzKG5ld1RhYnN0ZXJQcm9wcy5yb290KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWJzdGVyT25FbGVtZW50LnJvb3QgPSB0YWJzdGVyLnJvb3QuY3JlYXRlUm9vdChlbGVtZW50LCBuZXdUYWJzdGVyUHJvcHMucm9vdCwgc3lzKTtcbiAgICAgICAgfVxuICAgICAgICB0YWJzdGVyLnJvb3Qub25Sb290KHRhYnN0ZXJPbkVsZW1lbnQucm9vdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1vZGFsaXplclwiOlxuICAgICAgICB7XG4gICAgICAgICAgbGV0IG5ld01vZGFsaXplclByb3BzO1xuICAgICAgICAgIGNvbnN0IG1vZGFsaXplckFQSSA9IHRhYnN0ZXIubW9kYWxpemVyO1xuICAgICAgICAgIGlmICh0YWJzdGVyT25FbGVtZW50Lm1vZGFsaXplcikge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBuZXdUYWJzdGVyUHJvcHMubW9kYWxpemVyO1xuICAgICAgICAgICAgY29uc3QgbmV3TW9kYWxpemVySWQgPSBwcm9wcy5pZDtcbiAgICAgICAgICAgIGlmIChuZXdNb2RhbGl6ZXJJZCAmJiAoKF9jID0gb2xkVGFic3RlclByb3BzID09PSBudWxsIHx8IG9sZFRhYnN0ZXJQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkVGFic3RlclByb3BzLm1vZGFsaXplcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmlkKSAhPT0gbmV3TW9kYWxpemVySWQpIHtcbiAgICAgICAgICAgICAgLy8gTW9kYWxpemVyIGlkIGlzIGNoYW5nZWQsIGdpdmVuIHRoZSBtb2RhbGl6ZXJzIGhhdmUgY29tcGxleCBsb2dpYyBhbmQgY291bGQgYmVcbiAgICAgICAgICAgICAgLy8gY29tcG9zaXRlLCBpdCBpcyBlYXNpZXIgdG8gcmVjcmVhdGUgdGhlIE1vZGFsaXplciBpbnN0YW5jZSB0aGFuIHRvIGltcGxlbWVudFxuICAgICAgICAgICAgICAvLyB0aGUgaWQgdXBkYXRlLlxuICAgICAgICAgICAgICB0YWJzdGVyT25FbGVtZW50Lm1vZGFsaXplci5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgIG5ld01vZGFsaXplclByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YWJzdGVyT25FbGVtZW50Lm1vZGFsaXplci5zZXRQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtb2RhbGl6ZXJBUEkpIHtcbiAgICAgICAgICAgICAgbmV3TW9kYWxpemVyUHJvcHMgPSBuZXdUYWJzdGVyUHJvcHMubW9kYWxpemVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTW9kYWxpemVyIEFQSSB1c2VkIGJlZm9yZSBpbml0aWFsaXphdGlvbiwgcGxlYXNlIGNhbGwgYGdldE1vZGFsaXplcigpYFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGFsaXplckFQSSAmJiBuZXdNb2RhbGl6ZXJQcm9wcykge1xuICAgICAgICAgICAgdGFic3Rlck9uRWxlbWVudC5tb2RhbGl6ZXIgPSBtb2RhbGl6ZXJBUEkuY3JlYXRlTW9kYWxpemVyKGVsZW1lbnQsIG5ld01vZGFsaXplclByb3BzLCBzeXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyZXN0b3JlclwiOlxuICAgICAgICBpZiAodGFic3Rlck9uRWxlbWVudC5yZXN0b3Jlcikge1xuICAgICAgICAgIHRhYnN0ZXJPbkVsZW1lbnQucmVzdG9yZXIuc2V0UHJvcHMobmV3VGFic3RlclByb3BzLnJlc3RvcmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGFic3Rlci5yZXN0b3Jlcikge1xuICAgICAgICAgICAgaWYgKG5ld1RhYnN0ZXJQcm9wcy5yZXN0b3Jlcikge1xuICAgICAgICAgICAgICB0YWJzdGVyT25FbGVtZW50LnJlc3RvcmVyID0gdGFic3Rlci5yZXN0b3Jlci5jcmVhdGVSZXN0b3JlcihlbGVtZW50LCBuZXdUYWJzdGVyUHJvcHMucmVzdG9yZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSZXN0b3JlciBBUEkgdXNlZCBiZWZvcmUgaW5pdGlhbGl6YXRpb24sIHBsZWFzZSBjYWxsIGBnZXRSZXN0b3JlcigpYFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZm9jdXNhYmxlXCI6XG4gICAgICAgIHRhYnN0ZXJPbkVsZW1lbnQuZm9jdXNhYmxlID0gbmV3VGFic3RlclByb3BzLmZvY3VzYWJsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZ3JvdXBwZXJcIjpcbiAgICAgICAgaWYgKHRhYnN0ZXJPbkVsZW1lbnQuZ3JvdXBwZXIpIHtcbiAgICAgICAgICB0YWJzdGVyT25FbGVtZW50Lmdyb3VwcGVyLnNldFByb3BzKG5ld1RhYnN0ZXJQcm9wcy5ncm91cHBlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRhYnN0ZXIuZ3JvdXBwZXIpIHtcbiAgICAgICAgICAgIHRhYnN0ZXJPbkVsZW1lbnQuZ3JvdXBwZXIgPSB0YWJzdGVyLmdyb3VwcGVyLmNyZWF0ZUdyb3VwcGVyKGVsZW1lbnQsIG5ld1RhYnN0ZXJQcm9wcy5ncm91cHBlciwgc3lzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiR3JvdXBwZXIgQVBJIHVzZWQgYmVmb3JlIGluaXRpYWxpemF0aW9uLCBwbGVhc2UgY2FsbCBgZ2V0R3JvdXBwZXIoKWBcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1vdmVyXCI6XG4gICAgICAgIGlmICh0YWJzdGVyT25FbGVtZW50Lm1vdmVyKSB7XG4gICAgICAgICAgdGFic3Rlck9uRWxlbWVudC5tb3Zlci5zZXRQcm9wcyhuZXdUYWJzdGVyUHJvcHMubW92ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0YWJzdGVyLm1vdmVyKSB7XG4gICAgICAgICAgICB0YWJzdGVyT25FbGVtZW50Lm1vdmVyID0gdGFic3Rlci5tb3Zlci5jcmVhdGVNb3ZlcihlbGVtZW50LCBuZXdUYWJzdGVyUHJvcHMubW92ZXIsIHN5cyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk1vdmVyIEFQSSB1c2VkIGJlZm9yZSBpbml0aWFsaXphdGlvbiwgcGxlYXNlIGNhbGwgYGdldE1vdmVyKClgXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvYnNlcnZlZFwiOlxuICAgICAgICBpZiAodGFic3Rlci5vYnNlcnZlZEVsZW1lbnQpIHtcbiAgICAgICAgICB0YWJzdGVyT25FbGVtZW50Lm9ic2VydmVkID0gbmV3VGFic3RlclByb3BzLm9ic2VydmVkO1xuICAgICAgICAgIHRhYnN0ZXIub2JzZXJ2ZWRFbGVtZW50Lm9uT2JzZXJ2ZWRFbGVtZW50VXBkYXRlKGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIk9ic2VydmVkRWxlbWVudCBBUEkgdXNlZCBiZWZvcmUgaW5pdGlhbGl6YXRpb24sIHBsZWFzZSBjYWxsIGBnZXRPYnNlcnZlZEVsZW1lbnQoKWBcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidW5jb250cm9sbGVkXCI6XG4gICAgICAgIHRhYnN0ZXJPbkVsZW1lbnQudW5jb250cm9sbGVkID0gbmV3VGFic3RlclByb3BzLnVuY29udHJvbGxlZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib3V0bGluZVwiOlxuICAgICAgICBpZiAodGFic3Rlci5vdXRsaW5lKSB7XG4gICAgICAgICAgdGFic3Rlck9uRWxlbWVudC5vdXRsaW5lID0gbmV3VGFic3RlclByb3BzLm91dGxpbmU7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiT3V0bGluZSBBUEkgdXNlZCBiZWZvcmUgaW5pdGlhbGl6YXRpb24sIHBsZWFzZSBjYWxsIGBnZXRPdXRsaW5lKClgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInN5c1wiOlxuICAgICAgICB0YWJzdGVyT25FbGVtZW50LnN5cyA9IG5ld1RhYnN0ZXJQcm9wcy5zeXM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS5lcnJvcihgVW5rbm93biBrZXkgJyR7a2V5fScgaW4gZGF0YS10YWJzdGVyIGF0dHJpYnV0ZSB2YWx1ZS5gKTtcbiAgICB9XG4gIH1cbiAgaWYgKG5ld0F0dHIpIHtcbiAgICBlbnRyeS5hdHRyID0gbmV3QXR0cjtcbiAgfSBlbHNlIHtcbiAgICBpZiAoT2JqZWN0LmtleXModGFic3Rlck9uRWxlbWVudCkubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgZW50cnkudGFic3RlcjtcbiAgICAgIGRlbGV0ZSBlbnRyeS5hdHRyO1xuICAgIH1cbiAgICB0YWJzdGVyLnN0b3JhZ2VFbnRyeShlbGVtZW50LCBmYWxzZSk7XG4gIH1cbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBFdmVudHMgc2VudCBieSBUYWJzdGVyLlxuICovXG5jb25zdCBUYWJzdGVyRm9jdXNJbkV2ZW50TmFtZSA9IFwidGFic3Rlcjpmb2N1c2luXCI7XG5jb25zdCBUYWJzdGVyRm9jdXNPdXRFdmVudE5hbWUgPSBcInRhYnN0ZXI6Zm9jdXNvdXRcIjtcbi8vIEV2ZW50IGlzIGRpc3BhdGNoZWQgd2hlbiBUYWJzdGVyIHdhbnRzIHRvIG1vdmUgZm9jdXMgYXMgdGhlIHJlc3VsdCBvZlxuLy8gaGFuZGxpbmcga2V5Ym9hcmQgZXZlbnQuIFRoaXMgYWxsb3dzIHRvIHByZXZlbnREZWZhdWx0KCkgaWYgeW91IHdhbnQgdG8gaGF2ZVxuLy8gc29tZSBjdXN0b20gbG9naWMuXG5jb25zdCBUYWJzdGVyTW92ZUZvY3VzRXZlbnROYW1lID0gXCJ0YWJzdGVyOm1vdmVmb2N1c1wiO1xuLyoqXG4gKiBFdmVudHMgc2VudCBieSBEZWxvc2VyLlxuICovXG5jb25zdCBEZWxvc2VyRm9jdXNMb3N0RXZlbnROYW1lID0gXCJ0YWJzdGVyOmRlbG9zZXI6Zm9jdXMtbG9zdFwiO1xuLyoqXG4gKiBFdmVudHMgdG8gYmUgc2VudCB0byBEZWxvc2VyIGJ5IHRoZSBhcHBsaWNhdGlvbi5cbiAqL1xuY29uc3QgRGVsb3NlclJlc3RvcmVGb2N1c0V2ZW50TmFtZSA9IFwidGFic3RlcjpkZWxvc2VyOnJlc3RvcmUtZm9jdXNcIjtcbi8qKlxuICogRXZlbnRzIHNlbnQgYnkgTW9kYWxpemVyLlxuICovXG5jb25zdCBNb2RhbGl6ZXJBY3RpdmVFdmVudE5hbWUgPSBcInRhYnN0ZXI6bW9kYWxpemVyOmFjdGl2ZVwiO1xuY29uc3QgTW9kYWxpemVySW5hY3RpdmVFdmVudE5hbWUgPSBcInRhYnN0ZXI6bW9kYWxpemVyOmluYWN0aXZlXCI7XG5jb25zdCBNb2RhbGl6ZXJGb2N1c0luRXZlbnROYW1lID0gXCJ0YWJzdGVyOm1vZGFsaXplcjpmb2N1c2luXCI7XG5jb25zdCBNb2RhbGl6ZXJGb2N1c091dEV2ZW50TmFtZSA9IFwidGFic3Rlcjptb2RhbGl6ZXI6Zm9jdXNvdXRcIjtcbi8qKlxuICogRXZlbnRzIHNlbnQgYnkgTW92ZXIuXG4gKi9cbmNvbnN0IE1vdmVyU3RhdGVFdmVudE5hbWUgPSBcInRhYnN0ZXI6bW92ZXI6c3RhdGVcIjtcbi8qKlxuICogRXZlbnRzIHRvIGJlIHNlbnQgdG8gTW92ZXIgYnkgdGhlIGFwcGxpY2F0aW9uLlxuICovXG4vLyBFdmVudCB0aGF0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBhcHBsaWNhdGlvbiB0byBwcm9ncmFtbWF0aWNhbGx5IG1vdmVcbi8vIGZvY3VzIGluc2lkZSBNb3Zlci5cbmNvbnN0IE1vdmVyTW92ZUZvY3VzRXZlbnROYW1lID0gXCJ0YWJzdGVyOm1vdmVyOm1vdmVmb2N1c1wiO1xuLy8gRXZlbnQgdGhhdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgYXBwbGljYXRpb24gdG8gZm9yZ2V0IG9yIG1vZGlmeVxuLy8gbWVtb3JpemVkIGVsZW1lbnQgaW4gTW92ZXIgd2l0aCBtZW1vcml6ZUN1cnJlbnQgcHJvcGVydHkuXG5jb25zdCBNb3Zlck1lbW9yaXplZEVsZW1lbnRFdmVudE5hbWUgPSBcInRhYnN0ZXI6bW92ZXI6bWVtb3JpemVkLWVsZW1lbnRcIjtcbi8qKlxuICogRXZlbnRzIHNlbnQgYnkgR3JvdXBwZXIuXG4gKi9cbi8qKlxuICogRXZlbnRzIHRvIGJlIHNlbnQgdG8gR3JvdXBwZXIgYnkgdGhlIGFwcGxpY2F0aW9uLlxuICovXG4vLyBFdmVudCB0aGF0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBhcHBsaWNhdGlvbiB0byBwcm9ncmFtbWF0aWNhbGx5IGVudGVyXG4vLyBvciBlc2NhcGUgR3JvdXBwZXIuXG5jb25zdCBHcm91cHBlck1vdmVGb2N1c0V2ZW50TmFtZSA9IFwidGFic3Rlcjpncm91cHBlcjptb3ZlZm9jdXNcIjtcbi8qKlxuICogRXZlbnRzIHNlbnQgYnkgUmVzdG9yZXIuXG4gKi9cbmNvbnN0IFJlc3RvcmVyUmVzdG9yZUZvY3VzRXZlbnROYW1lID0gXCJ0YWJzdGVyOnJlc3RvcmVyOnJlc3RvcmUtZm9jdXNcIjtcbi8qKlxuICogRXZlbnRzIHNlbnQgYnkgUm9vdC5cbiAqL1xuY29uc3QgUm9vdEZvY3VzRXZlbnROYW1lID0gXCJ0YWJzdGVyOnJvb3Q6Zm9jdXNcIjtcbmNvbnN0IFJvb3RCbHVyRXZlbnROYW1lID0gXCJ0YWJzdGVyOnJvb3Q6Ymx1clwiO1xuLy8gTm9kZS5qcyBlbnZpcm9ubWVudHMgZG8gbm90IGhhdmUgQ3VzdG9tRXZlbnQgYW5kIGl0IGlzIG5lZWRlZCBmb3IgdGhlIGV2ZW50cyB0byBiZVxuLy8gZXZhbHVhdGVkLiBJdCBkb2Vzbid0IG1hdHRlciBpZiBpdCB3b3JrcyBvciBub3QgaW4gTm9kZS5qcyBlbnZpcm9ubWVudC5cbi8vIFNvLCB3ZSBqdXN0IG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgaXQgZG9lc24ndCB0aHJvdyB1bmRlZmluZWQgcmVmZXJlbmNlLlxuY29uc3QgQ3VzdG9tRXZlbnRfID0gdHlwZW9mIEN1c3RvbUV2ZW50ICE9PSBcInVuZGVmaW5lZFwiID8gQ3VzdG9tRXZlbnQgOiBmdW5jdGlvbiAoKSB7XG4gIC8qIG5vLW9wICovXG59O1xuY2xhc3MgVGFic3RlckN1c3RvbUV2ZW50IGV4dGVuZHMgQ3VzdG9tRXZlbnRfIHtcbiAgY29uc3RydWN0b3IodHlwZSwgZGV0YWlsKSB7XG4gICAgc3VwZXIodHlwZSwge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgIGRldGFpbFxuICAgIH0pO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbDtcbiAgfVxufVxuY2xhc3MgVGFic3RlckZvY3VzSW5FdmVudCBleHRlbmRzIFRhYnN0ZXJDdXN0b21FdmVudCB7XG4gIGNvbnN0cnVjdG9yKGRldGFpbCkge1xuICAgIHN1cGVyKFRhYnN0ZXJGb2N1c0luRXZlbnROYW1lLCBkZXRhaWwpO1xuICB9XG59XG5jbGFzcyBUYWJzdGVyRm9jdXNPdXRFdmVudCBleHRlbmRzIFRhYnN0ZXJDdXN0b21FdmVudCB7XG4gIGNvbnN0cnVjdG9yKGRldGFpbCkge1xuICAgIHN1cGVyKFRhYnN0ZXJGb2N1c091dEV2ZW50TmFtZSwgZGV0YWlsKTtcbiAgfVxufVxuY2xhc3MgVGFic3Rlck1vdmVGb2N1c0V2ZW50IGV4dGVuZHMgVGFic3RlckN1c3RvbUV2ZW50IHtcbiAgY29uc3RydWN0b3IoZGV0YWlsKSB7XG4gICAgc3VwZXIoVGFic3Rlck1vdmVGb2N1c0V2ZW50TmFtZSwgZGV0YWlsKTtcbiAgfVxufVxuY2xhc3MgTW92ZXJTdGF0ZUV2ZW50IGV4dGVuZHMgVGFic3RlckN1c3RvbUV2ZW50IHtcbiAgY29uc3RydWN0b3IoZGV0YWlsKSB7XG4gICAgc3VwZXIoTW92ZXJTdGF0ZUV2ZW50TmFtZSwgZGV0YWlsKTtcbiAgfVxufVxuY2xhc3MgTW92ZXJNb3ZlRm9jdXNFdmVudCBleHRlbmRzIFRhYnN0ZXJDdXN0b21FdmVudCB7XG4gIGNvbnN0cnVjdG9yKGRldGFpbCkge1xuICAgIHN1cGVyKE1vdmVyTW92ZUZvY3VzRXZlbnROYW1lLCBkZXRhaWwpO1xuICB9XG59XG5jbGFzcyBNb3Zlck1lbW9yaXplZEVsZW1lbnRFdmVudCBleHRlbmRzIFRhYnN0ZXJDdXN0b21FdmVudCB7XG4gIGNvbnN0cnVjdG9yKGRldGFpbCkge1xuICAgIHN1cGVyKE1vdmVyTWVtb3JpemVkRWxlbWVudEV2ZW50TmFtZSwgZGV0YWlsKTtcbiAgfVxufVxuY2xhc3MgR3JvdXBwZXJNb3ZlRm9jdXNFdmVudCBleHRlbmRzIFRhYnN0ZXJDdXN0b21FdmVudCB7XG4gIGNvbnN0cnVjdG9yKGRldGFpbCkge1xuICAgIHN1cGVyKEdyb3VwcGVyTW92ZUZvY3VzRXZlbnROYW1lLCBkZXRhaWwpO1xuICB9XG59XG5jbGFzcyBNb2RhbGl6ZXJBY3RpdmVFdmVudCBleHRlbmRzIFRhYnN0ZXJDdXN0b21FdmVudCB7XG4gIGNvbnN0cnVjdG9yKGRldGFpbCkge1xuICAgIHN1cGVyKE1vZGFsaXplckFjdGl2ZUV2ZW50TmFtZSwgZGV0YWlsKTtcbiAgfVxufVxuY2xhc3MgTW9kYWxpemVySW5hY3RpdmVFdmVudCBleHRlbmRzIFRhYnN0ZXJDdXN0b21FdmVudCB7XG4gIGNvbnN0cnVjdG9yKGRldGFpbCkge1xuICAgIHN1cGVyKE1vZGFsaXplckluYWN0aXZlRXZlbnROYW1lLCBkZXRhaWwpO1xuICB9XG59XG5jbGFzcyBEZWxvc2VyRm9jdXNMb3N0RXZlbnQgZXh0ZW5kcyBUYWJzdGVyQ3VzdG9tRXZlbnQge1xuICBjb25zdHJ1Y3RvcihkZXRhaWwpIHtcbiAgICBzdXBlcihEZWxvc2VyRm9jdXNMb3N0RXZlbnROYW1lLCBkZXRhaWwpO1xuICB9XG59XG5jbGFzcyBEZWxvc2VyUmVzdG9yZUZvY3VzRXZlbnQgZXh0ZW5kcyBUYWJzdGVyQ3VzdG9tRXZlbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihEZWxvc2VyUmVzdG9yZUZvY3VzRXZlbnROYW1lKTtcbiAgfVxufVxuY2xhc3MgUmVzdG9yZXJSZXN0b3JlRm9jdXNFdmVudCBleHRlbmRzIFRhYnN0ZXJDdXN0b21FdmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFJlc3RvcmVyUmVzdG9yZUZvY3VzRXZlbnROYW1lKTtcbiAgfVxufVxuY2xhc3MgUm9vdEZvY3VzRXZlbnQgZXh0ZW5kcyBUYWJzdGVyQ3VzdG9tRXZlbnQge1xuICBjb25zdHJ1Y3RvcihkZXRhaWwpIHtcbiAgICBzdXBlcihSb290Rm9jdXNFdmVudE5hbWUsIGRldGFpbCk7XG4gIH1cbn1cbmNsYXNzIFJvb3RCbHVyRXZlbnQgZXh0ZW5kcyBUYWJzdGVyQ3VzdG9tRXZlbnQge1xuICBjb25zdHJ1Y3RvcihkZXRhaWwpIHtcbiAgICBzdXBlcihSb290Qmx1ckV2ZW50TmFtZSwgZGV0YWlsKTtcbiAgfVxufVxuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5jb25zdCBfY3JlYXRlTXV0YXRpb25PYnNlcnZlciA9IGNhbGxiYWNrID0+IG5ldyBNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKTtcbmNvbnN0IF9jcmVhdGVUcmVlV2Fsa2VyID0gKGRvYywgcm9vdCwgd2hhdFRvU2hvdywgZmlsdGVyKSA9PiBkb2MuY3JlYXRlVHJlZVdhbGtlcihyb290LCB3aGF0VG9TaG93LCBmaWx0ZXIpO1xuY29uc3QgX2dldFBhcmVudE5vZGUgPSBub2RlID0+IG5vZGUgPyBub2RlLnBhcmVudE5vZGUgOiBudWxsO1xuY29uc3QgX2dldFBhcmVudEVsZW1lbnQgPSBlbGVtZW50ID0+IGVsZW1lbnQgPyBlbGVtZW50LnBhcmVudEVsZW1lbnQgOiBudWxsO1xuY29uc3QgX25vZGVDb250YWlucyA9IChwYXJlbnQsIGNoaWxkKSA9PiAhIShjaGlsZCAmJiAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmNvbnRhaW5zKGNoaWxkKSkpO1xuY29uc3QgX2dldEFjdGl2ZUVsZW1lbnQgPSBkb2MgPT4gZG9jLmFjdGl2ZUVsZW1lbnQ7XG5jb25zdCBfcXVlcnlTZWxlY3RvciA9IChlbGVtZW50LCBzZWxlY3RvcikgPT4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbmNvbnN0IF9xdWVyeVNlbGVjdG9yQWxsID0gKGVsZW1lbnQsIHNlbGVjdG9yKSA9PiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLCAwKTtcbmNvbnN0IF9nZXRFbGVtZW50QnlJZCA9IChkb2MsIGlkKSA9PiBkb2MuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuY29uc3QgX2dldEZpcnN0Q2hpbGQgPSBub2RlID0+IChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUuZmlyc3RDaGlsZCkgfHwgbnVsbDtcbmNvbnN0IF9nZXRMYXN0Q2hpbGQgPSBub2RlID0+IChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUubGFzdENoaWxkKSB8fCBudWxsO1xuY29uc3QgX2dldE5leHRTaWJsaW5nID0gbm9kZSA9PiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLm5leHRTaWJsaW5nKSB8fCBudWxsO1xuY29uc3QgX2dldFByZXZpb3VzU2libGluZyA9IG5vZGUgPT4gKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5wcmV2aW91c1NpYmxpbmcpIHx8IG51bGw7XG5jb25zdCBfZ2V0Rmlyc3RFbGVtZW50Q2hpbGQgPSBlbGVtZW50ID0+IChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpIHx8IG51bGw7XG5jb25zdCBfZ2V0TGFzdEVsZW1lbnRDaGlsZCA9IGVsZW1lbnQgPT4gKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudC5sYXN0RWxlbWVudENoaWxkKSB8fCBudWxsO1xuY29uc3QgX2dldE5leHRFbGVtZW50U2libGluZyA9IGVsZW1lbnQgPT4gKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHx8IG51bGw7XG5jb25zdCBfZ2V0UHJldmlvdXNFbGVtZW50U2libGluZyA9IGVsZW1lbnQgPT4gKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB8fCBudWxsO1xuY29uc3QgX2FwcGVuZENoaWxkID0gKHBhcmVudCwgY2hpbGQpID0+IHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG5jb25zdCBfaW5zZXJ0QmVmb3JlID0gKHBhcmVudCwgY2hpbGQsIHJlZmVyZW5jZUNoaWxkKSA9PiBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCByZWZlcmVuY2VDaGlsZCk7XG5jb25zdCBfZ2V0U2VsZWN0aW9uID0gcmVmID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKChfYSA9IHJlZi5vd25lckRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U2VsZWN0aW9uKCkpIHx8IG51bGw7XG59O1xuY29uc3QgX2dldEVsZW1lbnRzQnlOYW1lID0gKHJlZmVyZW5jZUVsZW1lbnQsIG5hbWUpID0+IHJlZmVyZW5jZUVsZW1lbnQub3duZXJEb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShuYW1lKTtcbmNvbnN0IGRvbSA9IHtcbiAgY3JlYXRlTXV0YXRpb25PYnNlcnZlcjogX2NyZWF0ZU11dGF0aW9uT2JzZXJ2ZXIsXG4gIGNyZWF0ZVRyZWVXYWxrZXI6IF9jcmVhdGVUcmVlV2Fsa2VyLFxuICBnZXRQYXJlbnROb2RlOiBfZ2V0UGFyZW50Tm9kZSxcbiAgZ2V0UGFyZW50RWxlbWVudDogX2dldFBhcmVudEVsZW1lbnQsXG4gIG5vZGVDb250YWluczogX25vZGVDb250YWlucyxcbiAgZ2V0QWN0aXZlRWxlbWVudDogX2dldEFjdGl2ZUVsZW1lbnQsXG4gIHF1ZXJ5U2VsZWN0b3I6IF9xdWVyeVNlbGVjdG9yLFxuICBxdWVyeVNlbGVjdG9yQWxsOiBfcXVlcnlTZWxlY3RvckFsbCxcbiAgZ2V0RWxlbWVudEJ5SWQ6IF9nZXRFbGVtZW50QnlJZCxcbiAgZ2V0Rmlyc3RDaGlsZDogX2dldEZpcnN0Q2hpbGQsXG4gIGdldExhc3RDaGlsZDogX2dldExhc3RDaGlsZCxcbiAgZ2V0TmV4dFNpYmxpbmc6IF9nZXROZXh0U2libGluZyxcbiAgZ2V0UHJldmlvdXNTaWJsaW5nOiBfZ2V0UHJldmlvdXNTaWJsaW5nLFxuICBnZXRGaXJzdEVsZW1lbnRDaGlsZDogX2dldEZpcnN0RWxlbWVudENoaWxkLFxuICBnZXRMYXN0RWxlbWVudENoaWxkOiBfZ2V0TGFzdEVsZW1lbnRDaGlsZCxcbiAgZ2V0TmV4dEVsZW1lbnRTaWJsaW5nOiBfZ2V0TmV4dEVsZW1lbnRTaWJsaW5nLFxuICBnZXRQcmV2aW91c0VsZW1lbnRTaWJsaW5nOiBfZ2V0UHJldmlvdXNFbGVtZW50U2libGluZyxcbiAgYXBwZW5kQ2hpbGQ6IF9hcHBlbmRDaGlsZCxcbiAgaW5zZXJ0QmVmb3JlOiBfaW5zZXJ0QmVmb3JlLFxuICBnZXRTZWxlY3Rpb246IF9nZXRTZWxlY3Rpb24sXG4gIGdldEVsZW1lbnRzQnlOYW1lOiBfZ2V0RWxlbWVudHNCeU5hbWVcbn07XG5mdW5jdGlvbiBzZXRET01BUEkoZG9tYXBpKSB7XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGRvbWFwaSkpIHtcbiAgICBkb21ba2V5XSA9IGRvbWFwaVtrZXldO1xuICB9XG59XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmxldCBfaXNCcm9rZW5JRTExO1xuY29uc3QgX0RPTVJlY3QgPSB0eXBlb2YgRE9NUmVjdCAhPT0gXCJ1bmRlZmluZWRcIiA/IERPTVJlY3QgOiBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmxlZnQgPSB4IHx8IDA7XG4gICAgdGhpcy50b3AgPSB5IHx8IDA7XG4gICAgdGhpcy5yaWdodCA9ICh4IHx8IDApICsgKHdpZHRoIHx8IDApO1xuICAgIHRoaXMuYm90dG9tID0gKHkgfHwgMCkgKyAoaGVpZ2h0IHx8IDApO1xuICB9XG59O1xubGV0IF91aWRDb3VudGVyID0gMDtcbnRyeSB7XG4gIC8vIElFMTEgb25seSBhY2NlcHRzIGBmaWx0ZXJgIGFyZ3VtZW50IGFzIGEgZnVuY3Rpb24gKG5vdCBvYmplY3Qgd2l0aCB0aGUgYGFjY2VwdE5vZGVgXG4gIC8vIHByb3BlcnR5IGFzIHRoZSBkb2NzIGRlZmluZSkuIEFsc28gYGVudGl0eVJlZmVyZW5jZUV4cGFuc2lvbmAgYXJndW1lbnQgaXMgbm90XG4gIC8vIG9wdGlvbmFsLiBBbmQgaXQgdGhyb3dzIGV4Y2VwdGlvbiB3aGVuIHRoZSBhYm92ZSBhcmd1bWVudHMgYXJlbid0IHRoZXJlLlxuICBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGRvY3VtZW50LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCk7XG4gIF9pc0Jyb2tlbklFMTEgPSBmYWxzZTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xufSBjYXRjaCAoZSkge1xuICBfaXNCcm9rZW5JRTExID0gdHJ1ZTtcbn1cbmNvbnN0IF91cGRhdGVEdW1teUlucHV0c1RpbWVvdXQgPSAxMDA7XG5mdW5jdGlvbiBnZXRJbnN0YW5jZUNvbnRleHQoZ2V0V2luZG93KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdygpO1xuICBsZXQgY3R4ID0gd2luLl9fdGFic3Rlckluc3RhbmNlQ29udGV4dDtcbiAgaWYgKCFjdHgpIHtcbiAgICBjdHggPSB7XG4gICAgICBlbGVtZW50QnlVSWQ6IHt9LFxuICAgICAgYmFzaWNzOiB7XG4gICAgICAgIFByb21pc2U6IHdpbi5Qcm9taXNlIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgV2Vha1JlZjogd2luLldlYWtSZWYgfHwgdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAgY29udGFpbmVyQm91bmRpbmdSZWN0Q2FjaGU6IHt9LFxuICAgICAgbGFzdENvbnRhaW5lckJvdW5kaW5nUmVjdENhY2hlSWQ6IDAsXG4gICAgICBmYWtlV2Vha1JlZnM6IFtdLFxuICAgICAgZmFrZVdlYWtSZWZzU3RhcnRlZDogZmFsc2VcbiAgICB9O1xuICAgIHdpbi5fX3RhYnN0ZXJJbnN0YW5jZUNvbnRleHQgPSBjdHg7XG4gIH1cbiAgcmV0dXJuIGN0eDtcbn1cbmZ1bmN0aW9uIGRpc3Bvc2VJbnN0YW5jZUNvbnRleHQod2luKSB7XG4gIGNvbnN0IGN0eCA9IHdpbi5fX3RhYnN0ZXJJbnN0YW5jZUNvbnRleHQ7XG4gIGlmIChjdHgpIHtcbiAgICBjdHguZWxlbWVudEJ5VUlkID0ge307XG4gICAgZGVsZXRlIGN0eC5XZWFrUmVmO1xuICAgIGN0eC5jb250YWluZXJCb3VuZGluZ1JlY3RDYWNoZSA9IHt9O1xuICAgIGlmIChjdHguY29udGFpbmVyQm91bmRpbmdSZWN0Q2FjaGVUaW1lcikge1xuICAgICAgd2luLmNsZWFyVGltZW91dChjdHguY29udGFpbmVyQm91bmRpbmdSZWN0Q2FjaGVUaW1lcik7XG4gICAgfVxuICAgIGlmIChjdHguZmFrZVdlYWtSZWZzVGltZXIpIHtcbiAgICAgIHdpbi5jbGVhclRpbWVvdXQoY3R4LmZha2VXZWFrUmVmc1RpbWVyKTtcbiAgICB9XG4gICAgY3R4LmZha2VXZWFrUmVmcyA9IFtdO1xuICAgIGRlbGV0ZSB3aW4uX190YWJzdGVySW5zdGFuY2VDb250ZXh0O1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVXZWFrTWFwKHdpbikge1xuICBjb25zdCBjdHggPSB3aW4uX190YWJzdGVySW5zdGFuY2VDb250ZXh0O1xuICByZXR1cm4gbmV3ICgoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LmJhc2ljcy5XZWFrTWFwKSB8fCBXZWFrTWFwKSgpO1xufVxuZnVuY3Rpb24gaGFzU3ViRm9jdXNhYmxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuICEhZWxlbWVudC5xdWVyeVNlbGVjdG9yKEZPQ1VTQUJMRV9TRUxFQ1RPUik7XG59XG5jbGFzcyBGYWtlV2Vha1JlZiB7XG4gIGNvbnN0cnVjdG9yKHRhcmdldCkge1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgfVxuICBkZXJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xuICB9XG4gIHN0YXRpYyBjbGVhbnVwKGZ3ciwgZm9yY2VSZW1vdmUpIHtcbiAgICBpZiAoIWZ3ci5fdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGZvcmNlUmVtb3ZlIHx8ICFkb2N1bWVudENvbnRhaW5zKGZ3ci5fdGFyZ2V0Lm93bmVyRG9jdW1lbnQsIGZ3ci5fdGFyZ2V0KSkge1xuICAgICAgZGVsZXRlIGZ3ci5fdGFyZ2V0O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuY2xhc3MgV2Vha0hUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZ2V0V2luZG93LCBlbGVtZW50LCBkYXRhKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGdldEluc3RhbmNlQ29udGV4dChnZXRXaW5kb3cpO1xuICAgIGxldCByZWY7XG4gICAgaWYgKGNvbnRleHQuV2Vha1JlZikge1xuICAgICAgcmVmID0gbmV3IGNvbnRleHQuV2Vha1JlZihlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVmID0gbmV3IEZha2VXZWFrUmVmKGVsZW1lbnQpO1xuICAgICAgY29udGV4dC5mYWtlV2Vha1JlZnMucHVzaChyZWYpO1xuICAgIH1cbiAgICB0aGlzLl9yZWYgPSByZWY7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH1cbiAgZ2V0KCkge1xuICAgIGNvbnN0IHJlZiA9IHRoaXMuX3JlZjtcbiAgICBsZXQgZWxlbWVudDtcbiAgICBpZiAocmVmKSB7XG4gICAgICBlbGVtZW50ID0gcmVmLmRlcmVmKCk7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3JlZjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYW51cEZha2VXZWFrUmVmcyhnZXRXaW5kb3csIGZvcmNlUmVtb3ZlKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBnZXRJbnN0YW5jZUNvbnRleHQoZ2V0V2luZG93KTtcbiAgY29udGV4dC5mYWtlV2Vha1JlZnMgPSBjb250ZXh0LmZha2VXZWFrUmVmcy5maWx0ZXIoZSA9PiAhRmFrZVdlYWtSZWYuY2xlYW51cChlLCBmb3JjZVJlbW92ZSkpO1xufVxuZnVuY3Rpb24gc3RhcnRGYWtlV2Vha1JlZnNDbGVhbnVwKGdldFdpbmRvdykge1xuICBjb25zdCBjb250ZXh0ID0gZ2V0SW5zdGFuY2VDb250ZXh0KGdldFdpbmRvdyk7XG4gIGlmICghY29udGV4dC5mYWtlV2Vha1JlZnNTdGFydGVkKSB7XG4gICAgY29udGV4dC5mYWtlV2Vha1JlZnNTdGFydGVkID0gdHJ1ZTtcbiAgICBjb250ZXh0LldlYWtSZWYgPSBnZXRXZWFrUmVmKGNvbnRleHQpO1xuICB9XG4gIGlmICghY29udGV4dC5mYWtlV2Vha1JlZnNUaW1lcikge1xuICAgIGNvbnRleHQuZmFrZVdlYWtSZWZzVGltZXIgPSBnZXRXaW5kb3coKS5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnRleHQuZmFrZVdlYWtSZWZzVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICBjbGVhbnVwRmFrZVdlYWtSZWZzKGdldFdpbmRvdyk7XG4gICAgICBzdGFydEZha2VXZWFrUmVmc0NsZWFudXAoZ2V0V2luZG93KTtcbiAgICB9LCAyICogNjAgKiAxMDAwKTsgLy8gMiBtaW51dGVzLlxuICB9XG59XG5mdW5jdGlvbiBzdG9wRmFrZVdlYWtSZWZzQ2xlYW51cEFuZENsZWFyU3RvcmFnZShnZXRXaW5kb3cpIHtcbiAgY29uc3QgY29udGV4dCA9IGdldEluc3RhbmNlQ29udGV4dChnZXRXaW5kb3cpO1xuICBjb250ZXh0LmZha2VXZWFrUmVmc1N0YXJ0ZWQgPSBmYWxzZTtcbiAgaWYgKGNvbnRleHQuZmFrZVdlYWtSZWZzVGltZXIpIHtcbiAgICBnZXRXaW5kb3coKS5jbGVhclRpbWVvdXQoY29udGV4dC5mYWtlV2Vha1JlZnNUaW1lcik7XG4gICAgY29udGV4dC5mYWtlV2Vha1JlZnNUaW1lciA9IHVuZGVmaW5lZDtcbiAgICBjb250ZXh0LmZha2VXZWFrUmVmcyA9IFtdO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50VHJlZVdhbGtlcihkb2MsIHJvb3QsIGFjY2VwdE5vZGUpIHtcbiAgLy8gSUUxMSB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiB3aGVuIHRoZSBUcmVlV2Fsa2VyIHJvb3QgaXMgbm90IGFuIEVsZW1lbnQuXG4gIGlmIChyb290Lm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgLy8gVHlwZVNjcmlwdCBpc24ndCBhd2FyZSBvZiBJRTExIGJlaGF2aW5nIGJhZGx5LlxuICBjb25zdCBmaWx0ZXIgPSBfaXNCcm9rZW5JRTExID8gYWNjZXB0Tm9kZSA6IHtcbiAgICBhY2NlcHROb2RlXG4gIH07XG4gIHJldHVybiBkb20uY3JlYXRlVHJlZVdhbGtlcihkb2MsIHJvb3QsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCBmaWx0ZXIsXG4gIC8vIEB0cy1pZ25vcmU6IFdlIHN0aWxsIGRvbid0IHdhbnQgdG8gY29tcGxldGVseSBicmVhayBJRTExLCBzbywgZW50aXR5UmVmZXJlbmNlRXhwYW5zaW9uIGFyZ3VtZW50IGlzIG5vdCBvcHRpb25hbC5cbiAgZmFsc2UgLyogTGFzdCBhcmd1bWVudCBpcyBub3Qgb3B0aW9uYWwgZm9yIElFMTEhICovKTtcbn1cbmZ1bmN0aW9uIGdldEJvdW5kaW5nUmVjdChnZXRXaW5kb3csIGVsZW1lbnQpIHtcbiAgbGV0IGNhY2hlSWQgPSBlbGVtZW50Ll9fdGFic3RlckNhY2hlSWQ7XG4gIGNvbnN0IGNvbnRleHQgPSBnZXRJbnN0YW5jZUNvbnRleHQoZ2V0V2luZG93KTtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGVJZCA/IGNvbnRleHQuY29udGFpbmVyQm91bmRpbmdSZWN0Q2FjaGVbY2FjaGVJZF0gOiB1bmRlZmluZWQ7XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkLnJlY3Q7XG4gIH1cbiAgY29uc3Qgc2Nyb2xsaW5nRWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudCAmJiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBpZiAoIXNjcm9sbGluZ0VsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IF9ET01SZWN0KCk7XG4gIH1cbiAgLy8gQSBib3VuZGluZyByZWN0IG9mIHRoZSB0b3AtbGV2ZWwgZWxlbWVudCBjb250YWlucyB0aGUgd2hvbGUgcGFnZSByZWdhcmRsZXNzIG9mIHRoZVxuICAvLyBzY3JvbGxiYXIuIFNvLCB3ZSBpbXByb3Zpc2UgYSBsaXR0bGUgYW5kIGxpbWl0aW5nIHRoZSBmaW5hbCByZXN1bHQuLi5cbiAgbGV0IGxlZnQgPSAwO1xuICBsZXQgdG9wID0gMDtcbiAgbGV0IHJpZ2h0ID0gc2Nyb2xsaW5nRWxlbWVudC5jbGllbnRXaWR0aDtcbiAgbGV0IGJvdHRvbSA9IHNjcm9sbGluZ0VsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICBpZiAoZWxlbWVudCAhPT0gc2Nyb2xsaW5nRWxlbWVudCkge1xuICAgIGNvbnN0IHIgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCByLmxlZnQpO1xuICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgci50b3ApO1xuICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIHIucmlnaHQpO1xuICAgIGJvdHRvbSA9IE1hdGgubWluKGJvdHRvbSwgci5ib3R0b20pO1xuICB9XG4gIGNvbnN0IHJlY3QgPSBuZXcgX0RPTVJlY3QobGVmdCA8IHJpZ2h0ID8gbGVmdCA6IC0xLCB0b3AgPCBib3R0b20gPyB0b3AgOiAtMSwgbGVmdCA8IHJpZ2h0ID8gcmlnaHQgLSBsZWZ0IDogMCwgdG9wIDwgYm90dG9tID8gYm90dG9tIC0gdG9wIDogMCk7XG4gIGlmICghY2FjaGVJZCkge1xuICAgIGNhY2hlSWQgPSBcInItXCIgKyArK2NvbnRleHQubGFzdENvbnRhaW5lckJvdW5kaW5nUmVjdENhY2hlSWQ7XG4gICAgZWxlbWVudC5fX3RhYnN0ZXJDYWNoZUlkID0gY2FjaGVJZDtcbiAgfVxuICBjb250ZXh0LmNvbnRhaW5lckJvdW5kaW5nUmVjdENhY2hlW2NhY2hlSWRdID0ge1xuICAgIHJlY3QsXG4gICAgZWxlbWVudFxuICB9O1xuICBpZiAoIWNvbnRleHQuY29udGFpbmVyQm91bmRpbmdSZWN0Q2FjaGVUaW1lcikge1xuICAgIGNvbnRleHQuY29udGFpbmVyQm91bmRpbmdSZWN0Q2FjaGVUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnRleHQuY29udGFpbmVyQm91bmRpbmdSZWN0Q2FjaGVUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgIGZvciAoY29uc3QgY0lkIG9mIE9iamVjdC5rZXlzKGNvbnRleHQuY29udGFpbmVyQm91bmRpbmdSZWN0Q2FjaGUpKSB7XG4gICAgICAgIGRlbGV0ZSBjb250ZXh0LmNvbnRhaW5lckJvdW5kaW5nUmVjdENhY2hlW2NJZF0uZWxlbWVudC5fX3RhYnN0ZXJDYWNoZUlkO1xuICAgICAgfVxuICAgICAgY29udGV4dC5jb250YWluZXJCb3VuZGluZ1JlY3RDYWNoZSA9IHt9O1xuICAgIH0sIDUwKTtcbiAgfVxuICByZXR1cm4gcmVjdDtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudFZlcnRpY2FsbHlWaXNpYmxlSW5Db250YWluZXIoZ2V0V2luZG93LCBlbGVtZW50LCB0b2xlcmFuY2UpIHtcbiAgY29uc3QgY29udGFpbmVyID0gZ2V0U2Nyb2xsYWJsZUNvbnRhaW5lcihlbGVtZW50KTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgY29udGFpbmVyUmVjdCA9IGdldEJvdW5kaW5nUmVjdChnZXRXaW5kb3csIGNvbnRhaW5lcik7XG4gIGNvbnN0IGVsZW1lbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgaW50ZXJzZWN0aW9uVG9sZXJhbmNlID0gZWxlbWVudFJlY3QuaGVpZ2h0ICogKDEgLSB0b2xlcmFuY2UpO1xuICBjb25zdCB0b3BJbnRlcnNlY3Rpb24gPSBNYXRoLm1heCgwLCBjb250YWluZXJSZWN0LnRvcCAtIGVsZW1lbnRSZWN0LnRvcCk7XG4gIGNvbnN0IGJvdHRvbUludGVyc2VjdGlvbiA9IE1hdGgubWF4KDAsIGVsZW1lbnRSZWN0LmJvdHRvbSAtIGNvbnRhaW5lclJlY3QuYm90dG9tKTtcbiAgY29uc3QgdG90YWxJbnRlcnNlY3Rpb24gPSB0b3BJbnRlcnNlY3Rpb24gKyBib3R0b21JbnRlcnNlY3Rpb247XG4gIHJldHVybiB0b3RhbEludGVyc2VjdGlvbiA9PT0gMCB8fCB0b3RhbEludGVyc2VjdGlvbiA8PSBpbnRlcnNlY3Rpb25Ub2xlcmFuY2U7XG59XG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhnZXRXaW5kb3csIGVsZW1lbnQsIGFsaWduVG9Ub3ApIHtcbiAgLy8gQnVpbHQtaW4gRE9NJ3Mgc2Nyb2xsSW50b1ZpZXcoKSBpcyBjb29sLCBidXQgd2hlbiB3ZSBoYXZlIG5lc3RlZCBjb250YWluZXJzLFxuICAvLyBpdCBzY3JvbGxzIGFsbCBvZiB0aGVtLCBub3QganVzdCB0aGUgZGVlcGVzdCBvbmUuIFNvLCB0cnlpbmcgdG8gd29yayBpdCBhcm91bmQuXG4gIGNvbnN0IGNvbnRhaW5lciA9IGdldFNjcm9sbGFibGVDb250YWluZXIoZWxlbWVudCk7XG4gIGlmIChjb250YWluZXIpIHtcbiAgICBjb25zdCBjb250YWluZXJSZWN0ID0gZ2V0Qm91bmRpbmdSZWN0KGdldFdpbmRvdywgY29udGFpbmVyKTtcbiAgICBjb25zdCBlbGVtZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGFsaWduVG9Ub3ApIHtcbiAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gZWxlbWVudFJlY3QudG9wIC0gY29udGFpbmVyUmVjdC50b3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gZWxlbWVudFJlY3QuYm90dG9tIC0gY29udGFpbmVyUmVjdC5ib3R0b207XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxhYmxlQ29udGFpbmVyKGVsZW1lbnQpIHtcbiAgY29uc3QgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICBpZiAoZG9jKSB7XG4gICAgZm9yIChsZXQgZWwgPSBkb20uZ2V0UGFyZW50RWxlbWVudChlbGVtZW50KTsgZWw7IGVsID0gZG9tLmdldFBhcmVudEVsZW1lbnQoZWwpKSB7XG4gICAgICBpZiAoZWwuc2Nyb2xsV2lkdGggPiBlbC5jbGllbnRXaWR0aCB8fCBlbC5zY3JvbGxIZWlnaHQgPiBlbC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG1ha2VGb2N1c0lnbm9yZWQoZWxlbWVudCkge1xuICBlbGVtZW50Ll9fc2hvdWxkSWdub3JlRm9jdXMgPSB0cnVlO1xufVxuZnVuY3Rpb24gc2hvdWxkSWdub3JlRm9jdXMoZWxlbWVudCkge1xuICByZXR1cm4gISFlbGVtZW50Ll9fc2hvdWxkSWdub3JlRm9jdXM7XG59XG5mdW5jdGlvbiBnZXRVSWQod25kKSB7XG4gIGNvbnN0IHJuZCA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgaWYgKHduZC5jcnlwdG8gJiYgd25kLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICB3bmQuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhybmQpO1xuICB9IGVsc2UgaWYgKHduZC5tc0NyeXB0byAmJiB3bmQubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgd25kLm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhybmQpO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICBybmRbaV0gPSAweGZmZmZmZmZmICogTWF0aC5yYW5kb20oKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3JuZCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJuZC5sZW5ndGg7IGkrKykge1xuICAgIHNybmQucHVzaChybmRbaV0udG9TdHJpbmcoMzYpKTtcbiAgfVxuICBzcm5kLnB1c2goXCJ8XCIpO1xuICBzcm5kLnB1c2goKCsrX3VpZENvdW50ZXIpLnRvU3RyaW5nKDM2KSk7XG4gIHNybmQucHVzaChcInxcIik7XG4gIHNybmQucHVzaChEYXRlLm5vdygpLnRvU3RyaW5nKDM2KSk7XG4gIHJldHVybiBzcm5kLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50VUlkKGdldFdpbmRvdywgZWxlbWVudCkge1xuICBjb25zdCBjb250ZXh0ID0gZ2V0SW5zdGFuY2VDb250ZXh0KGdldFdpbmRvdyk7XG4gIGxldCB1aWQgPSBlbGVtZW50Ll9fdGFic3RlckVsZW1lbnRVSUQ7XG4gIGlmICghdWlkKSB7XG4gICAgdWlkID0gZWxlbWVudC5fX3RhYnN0ZXJFbGVtZW50VUlEID0gZ2V0VUlkKGdldFdpbmRvdygpKTtcbiAgfVxuICBpZiAoIWNvbnRleHQuZWxlbWVudEJ5VUlkW3VpZF0gJiYgZG9jdW1lbnRDb250YWlucyhlbGVtZW50Lm93bmVyRG9jdW1lbnQsIGVsZW1lbnQpKSB7XG4gICAgY29udGV4dC5lbGVtZW50QnlVSWRbdWlkXSA9IG5ldyBXZWFrSFRNTEVsZW1lbnQoZ2V0V2luZG93LCBlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gdWlkO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93VUlkKHdpbikge1xuICBsZXQgdWlkID0gd2luLl9fdGFic3RlckNyb3NzT3JpZ2luV2luZG93VUlEO1xuICBpZiAoIXVpZCkge1xuICAgIHVpZCA9IHdpbi5fX3RhYnN0ZXJDcm9zc09yaWdpbldpbmRvd1VJRCA9IGdldFVJZCh3aW4pO1xuICB9XG4gIHJldHVybiB1aWQ7XG59XG5mdW5jdGlvbiBjbGVhckVsZW1lbnRDYWNoZShnZXRXaW5kb3csIHBhcmVudCkge1xuICBjb25zdCBjb250ZXh0ID0gZ2V0SW5zdGFuY2VDb250ZXh0KGdldFdpbmRvdyk7XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvbnRleHQuZWxlbWVudEJ5VUlkKSkge1xuICAgIGNvbnN0IHdlbCA9IGNvbnRleHQuZWxlbWVudEJ5VUlkW2tleV07XG4gICAgY29uc3QgZWwgPSB3ZWwgJiYgd2VsLmdldCgpO1xuICAgIGlmIChlbCAmJiBwYXJlbnQpIHtcbiAgICAgIGlmICghZG9tLm5vZGVDb250YWlucyhwYXJlbnQsIGVsKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlIGNvbnRleHQuZWxlbWVudEJ5VUlkW2tleV07XG4gIH1cbn1cbi8vIElFMTEgZG9lc24ndCBoYXZlIGRvY3VtZW50LmNvbnRhaW5zKCkuLi5cbmZ1bmN0aW9uIGRvY3VtZW50Q29udGFpbnMoZG9jLCBlbGVtZW50KSB7XG4gIHJldHVybiBkb20ubm9kZUNvbnRhaW5zKGRvYyA9PT0gbnVsbCB8fCBkb2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvYy5ib2R5LCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIG1hdGNoZXNTZWxlY3RvcihlbGVtZW50LCBzZWxlY3Rvcikge1xuICBjb25zdCBtYXRjaGVzID0gZWxlbWVudC5tYXRjaGVzIHx8IGVsZW1lbnQubWF0Y2hlc1NlbGVjdG9yIHx8IGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3IgfHwgZWxlbWVudC53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG4gIHJldHVybiBtYXRjaGVzICYmIG1hdGNoZXMuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG59XG5mdW5jdGlvbiBnZXRQcm9taXNlKGdldFdpbmRvdykge1xuICBjb25zdCBjb250ZXh0ID0gZ2V0SW5zdGFuY2VDb250ZXh0KGdldFdpbmRvdyk7XG4gIGlmIChjb250ZXh0LmJhc2ljcy5Qcm9taXNlKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuYmFzaWNzLlByb21pc2U7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUHJvbWlzZSBkZWZpbmVkLlwiKTtcbn1cbmZ1bmN0aW9uIGdldFdlYWtSZWYoY29udGV4dCkge1xuICByZXR1cm4gY29udGV4dC5iYXNpY3MuV2Vha1JlZjtcbn1cbmxldCBfbGFzdFRhYnN0ZXJQYXJ0SWQgPSAwO1xuY2xhc3MgVGFic3RlclBhcnQge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyLCBlbGVtZW50LCBwcm9wcykge1xuICAgIGNvbnN0IGdldFdpbmRvdyA9IHRhYnN0ZXIuZ2V0V2luZG93O1xuICAgIHRoaXMuX3RhYnN0ZXIgPSB0YWJzdGVyO1xuICAgIHRoaXMuX2VsZW1lbnQgPSBuZXcgV2Vha0hUTUxFbGVtZW50KGdldFdpbmRvdywgZWxlbWVudCk7XG4gICAgdGhpcy5fcHJvcHMgPSB7XG4gICAgICAuLi5wcm9wc1xuICAgIH07XG4gICAgdGhpcy5pZCA9IFwiaVwiICsgKytfbGFzdFRhYnN0ZXJQYXJ0SWQ7XG4gIH1cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5nZXQoKTtcbiAgfVxuICBnZXRQcm9wcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvcHM7XG4gIH1cbiAgc2V0UHJvcHMocHJvcHMpIHtcbiAgICB0aGlzLl9wcm9wcyA9IHtcbiAgICAgIC4uLnByb3BzXG4gICAgfTtcbiAgfVxufVxuLyoqXG4gKiBEdW1teSBIVE1MIGVsZW1lbnRzIHRoYXQgYXJlIHVzZWQgYXMgZm9jdXMgc2VudGluZWxzIGZvciB0aGUgRE9NIGVuY2xvc2VkIHdpdGhpbiB0aGVtXG4gKi9cbmNsYXNzIER1bW15SW5wdXQge1xuICBjb25zdHJ1Y3RvcihnZXRXaW5kb3csIGlzT3V0c2lkZSwgcHJvcHMsIGVsZW1lbnQsIGZpeGVkVGFyZ2V0KSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuX2ZvY3VzSW4gPSBlID0+IHtcbiAgICAgIGlmICh0aGlzLl9maXhlZFRhcmdldCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9maXhlZFRhcmdldC5nZXQoKTtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIG5hdGl2ZUZvY3VzKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgICAgaWYgKHRoaXMub25Gb2N1c0luICYmIGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBlLnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgIHRoaXMub25Gb2N1c0luKHRoaXMsIHRoaXMuX2lzQmFja3dhcmQodHJ1ZSwgaW5wdXQsIHJlbGF0ZWRUYXJnZXQpLCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX2ZvY3VzT3V0ID0gZSA9PiB7XG4gICAgICBpZiAodGhpcy5fZml4ZWRUYXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy51c2VEZWZhdWx0QWN0aW9uID0gZmFsc2U7XG4gICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gICAgICBpZiAodGhpcy5vbkZvY3VzT3V0ICYmIGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBlLnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgIHRoaXMub25Gb2N1c091dCh0aGlzLCB0aGlzLl9pc0JhY2t3YXJkKGZhbHNlLCBpbnB1dCwgcmVsYXRlZFRhcmdldCksIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgd2luID0gZ2V0V2luZG93KCk7XG4gICAgY29uc3QgaW5wdXQgPSB3aW4uZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlcIik7XG4gICAgaW5wdXQudGFiSW5kZXggPSAwO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJub25lXCIpO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZShUQUJTVEVSX0RVTU1ZX0lOUFVUX0FUVFJJQlVURV9OQU1FLCBcIlwiKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgY29uc3Qgc3R5bGUgPSBpbnB1dC5zdHlsZTtcbiAgICBzdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgICBzdHlsZS53aWR0aCA9IHN0eWxlLmhlaWdodCA9IFwiMXB4XCI7XG4gICAgc3R5bGUub3BhY2l0eSA9IFwiMC4wMDFcIjtcbiAgICBzdHlsZS56SW5kZXggPSBcIi0xXCI7XG4gICAgc3R5bGUuc2V0UHJvcGVydHkoXCJjb250ZW50LXZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XG4gICAgbWFrZUZvY3VzSWdub3JlZChpbnB1dCk7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIHRoaXMuaXNGaXJzdCA9IHByb3BzLmlzRmlyc3Q7XG4gICAgdGhpcy5pc091dHNpZGUgPSBpc091dHNpZGU7XG4gICAgdGhpcy5faXNQaGFudG9tID0gKF9hID0gcHJvcHMuaXNQaGFudG9tKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICB0aGlzLl9maXhlZFRhcmdldCA9IGZpeGVkVGFyZ2V0O1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuX2ZvY3VzSW4pO1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLl9mb2N1c091dCk7XG4gICAgaW5wdXQuX190YWJzdGVyRHVtbXlDb250YWluZXIgPSBlbGVtZW50O1xuICAgIGlmICh0aGlzLl9pc1BoYW50b20pIHtcbiAgICAgIHRoaXMuX2Rpc3Bvc2VUaW1lciA9IHdpbi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2Rpc3Bvc2VUaW1lcjtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICB9LCAwKTtcbiAgICAgIHRoaXMuX2NsZWFyRGlzcG9zZVRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9kaXNwb3NlVGltZXIpIHtcbiAgICAgICAgICB3aW4uY2xlYXJUaW1lb3V0KHRoaXMuX2Rpc3Bvc2VUaW1lcik7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2Rpc3Bvc2VUaW1lcjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fY2xlYXJEaXNwb3NlVGltZW91dDtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0aGlzLl9jbGVhckRpc3Bvc2VUaW1lb3V0KSB7XG4gICAgICB0aGlzLl9jbGVhckRpc3Bvc2VUaW1lb3V0KCk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLl9maXhlZFRhcmdldDtcbiAgICBkZWxldGUgdGhpcy5vbkZvY3VzSW47XG4gICAgZGVsZXRlIHRoaXMub25Gb2N1c091dDtcbiAgICBkZWxldGUgdGhpcy5pbnB1dDtcbiAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCB0aGlzLl9mb2N1c0luKTtcbiAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy5fZm9jdXNPdXQpO1xuICAgIGRlbGV0ZSBpbnB1dC5fX3RhYnN0ZXJEdW1teUNvbnRhaW5lcjtcbiAgICAoX2EgPSBkb20uZ2V0UGFyZW50Tm9kZShpbnB1dCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVDaGlsZChpbnB1dCk7XG4gIH1cbiAgc2V0VG9wTGVmdCh0b3AsIGxlZnQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc3R5bGUgPSAoX2EgPSB0aGlzLmlucHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3R5bGU7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBzdHlsZS50b3AgPSBgJHt0b3B9cHhgO1xuICAgICAgc3R5bGUubGVmdCA9IGAke2xlZnR9cHhgO1xuICAgIH1cbiAgfVxuICBfaXNCYWNrd2FyZChpc0luLCBjdXJyZW50LCBwcmV2aW91cykge1xuICAgIHJldHVybiBpc0luICYmICFwcmV2aW91cyA/ICF0aGlzLmlzRmlyc3QgOiAhIShwcmV2aW91cyAmJiBjdXJyZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHByZXZpb3VzKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HKTtcbiAgfVxufVxuY29uc3QgRHVtbXlJbnB1dE1hbmFnZXJQcmlvcml0aWVzID0ge1xuICBSb290OiAxLFxuICBNb2RhbGl6ZXI6IDIsXG4gIE1vdmVyOiAzLFxuICBHcm91cHBlcjogNFxufTtcbmNsYXNzIER1bW15SW5wdXRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IodGFic3RlciwgZWxlbWVudCwgcHJpb3JpdHksIHN5cywgb3V0c2lkZUJ5RGVmYXVsdCwgY2FsbEZvckRlZmF1bHRBY3Rpb24pIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG5ldyBEdW1teUlucHV0TWFuYWdlckNvcmUodGFic3RlciwgZWxlbWVudCwgdGhpcywgcHJpb3JpdHksIHN5cywgb3V0c2lkZUJ5RGVmYXVsdCwgY2FsbEZvckRlZmF1bHRBY3Rpb24pO1xuICB9XG4gIF9zZXRIYW5kbGVycyhvbkZvY3VzSW4sIG9uRm9jdXNPdXQpIHtcbiAgICB0aGlzLl9vbkZvY3VzSW4gPSBvbkZvY3VzSW47XG4gICAgdGhpcy5fb25Gb2N1c091dCA9IG9uRm9jdXNPdXQ7XG4gIH1cbiAgbW92ZU91dChiYWNrd2FyZHMpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5faW5zdGFuY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb3ZlT3V0KGJhY2t3YXJkcyk7XG4gIH1cbiAgbW92ZU91dFdpdGhEZWZhdWx0QWN0aW9uKGJhY2t3YXJkcywgcmVsYXRlZEV2ZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuX2luc3RhbmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW92ZU91dFdpdGhEZWZhdWx0QWN0aW9uKGJhY2t3YXJkcywgcmVsYXRlZEV2ZW50KTtcbiAgfVxuICBnZXRIYW5kbGVyKGlzSW4pIHtcbiAgICByZXR1cm4gaXNJbiA/IHRoaXMuX29uRm9jdXNJbiA6IHRoaXMuX29uRm9jdXNPdXQ7XG4gIH1cbiAgc2V0VGFiYmFibGUodGFiYmFibGUpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5faW5zdGFuY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRUYWJiYWJsZSh0aGlzLCB0YWJiYWJsZSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuX2luc3RhbmNlLmRpc3Bvc2UodGhpcyk7XG4gICAgICBkZWxldGUgdGhpcy5faW5zdGFuY2U7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLl9vbkZvY3VzSW47XG4gICAgZGVsZXRlIHRoaXMuX29uRm9jdXNPdXQ7XG4gIH1cbiAgc3RhdGljIG1vdmVXaXRoUGhhbnRvbUR1bW15KHRhYnN0ZXIsIGVsZW1lbnQsXG4gIC8vIFRoZSB0YXJnZXQgZWxlbWVudCB0byBtb3ZlIHRvIG9yIG91dCBvZi5cbiAgbW92ZU91dE9mRWxlbWVudCxcbiAgLy8gV2hldGhlciB0byBtb3ZlIG91dCBvZiB0aGUgZWxlbWVudCBvciBpbnRvIGl0LlxuICBpc0JhY2t3YXJkLFxuICAvLyBBcmUgd2UgdGFiYmluZyBvZiBzaGlmdC10YWJiaW5nP1xuICByZWxhdGVkRXZlbnQgLy8gVGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBtb3ZlLlxuICApIHtcbiAgICAvLyBQaGFudG9tIGR1bW15IGlzIGEgaGFjayB0byB1c2UgYnJvd3NlcidzIGRlZmF1bHQgYWN0aW9uIHRvIG1vdmVcbiAgICAvLyBmb2N1cyBmcm9tIGEgc3BlY2lmaWMgcG9pbnQgaW4gdGhlIGFwcGxpY2F0aW9uIHRvIHRoZSBuZXh0L3ByZXZpb3VzXG4gICAgLy8gZWxlbWVudC4gRGVmYXVsdCBhY3Rpb24gaXMgbmVlZGVkIGJlY2F1c2UgbmV4dCBmb2N1c2FibGUgZWxlbWVudFxuICAgIC8vIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlIHRvIGZvY3VzIGRpcmVjdGx5IChmb3IgZXhhbXBsZSwgbmV4dCBmb2N1c2FibGVcbiAgICAvLyBpcyBpbnNpZGUgaXNvbGF0ZWQgaWZyYW1lKSBvciBmb3IgdW5jb250cm9sbGVkIGFyZWFzIHdlIHdhbnQgdG8gbWFrZVxuICAgIC8vIHN1cmUgdGhhdCBzb21ldGhpbmcgdGhhdCBjb250cm9scyBpdCB0YWtlcyBjYXJlIG9mIHRoZSBmb2N1c2luZy5cbiAgICAvLyBJdCB3b3JrcyBpbiBhIHdheSB0aGF0IGR1cmluZyB0aGUgVGFiIGtleSBoYW5kbGluZywgd2UgY3JlYXRlIGEgZHVtbXlcbiAgICAvLyBpbnB1dCBlbGVtZW50LCBwbGFjZSBpdCB0byB0aGUgc3BlY2lmaWMgcGxhY2UgaW4gdGhlIERPTSBhbmQgZm9jdXMgaXQsXG4gICAgLy8gdGhlbiB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgdGhlIFRhYiBwcmVzcyB3aWxsIG1vdmUgZm9jdXMgZnJvbSBvdXIgZHVtbXlcbiAgICAvLyBpbnB1dC4gQW5kIHdlIHJlbW92ZSBpdCBmcm9tIHRoZSBET00gcmlnaHQgYWZ0ZXIgdGhhdC5cbiAgICBjb25zdCBkdW1teSA9IG5ldyBEdW1teUlucHV0KHRhYnN0ZXIuZ2V0V2luZG93LCB0cnVlLCB7XG4gICAgICBpc1BoYW50b206IHRydWUsXG4gICAgICBpc0ZpcnN0OiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgaW5wdXQgPSBkdW1teS5pbnB1dDtcbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgIGxldCBwYXJlbnQ7XG4gICAgICBsZXQgaW5zZXJ0QmVmb3JlO1xuICAgICAgLy8gTGV0J3Mgc2F5IHdlIGhhdmUgYSBmb2xsb3dpbmcgRE9NIHN0cnVjdHVyZTpcbiAgICAgIC8vIDxkaXY+XG4gICAgICAvLyAgIDxidXR0b24+QnV0dG9uMTwvYnV0dG9uPlxuICAgICAgLy8gICA8ZGl2IGlkPVwidW5jb250cm9sbGVkXCIgZGF0YS10YWJzdGVyPXt1bmNvbnRyb2xsZWQ6IHt9fT5cbiAgICAgIC8vICAgICA8YnV0dG9uPkJ1dHRvbjI8L2J1dHRvbj5cbiAgICAgIC8vICAgICA8YnV0dG9uPkJ1dHRvbjM8L2J1dHRvbj5cbiAgICAgIC8vICAgPC9kaXY+XG4gICAgICAvLyAgIDxidXR0b24+QnV0dG9uNDwvYnV0dG9uPlxuICAgICAgLy8gPC9kaXY+XG4gICAgICAvL1xuICAgICAgLy8gV2UgcGFzcyB0aGUgXCJ1bmNvbnRyb2xsZWRcIiBkaXYgYXMgdGhlIGVsZW1lbnQgdG8gbW92ZSB0byBvciBvdXQgb2YuXG4gICAgICAvL1xuICAgICAgLy8gV2hlbiB3ZSBwYXNzIG1vdmVPdXRPZkVsZW1lbnQ9dHJ1ZSBhbmQgaXNCYWNrd2FyZD1mYWxzZSxcbiAgICAgIC8vIHRoZSBwaGFudG9tIGR1bW15IGlucHV0IHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIEJ1dHRvbjQuXG4gICAgICAvL1xuICAgICAgLy8gV2hlbiB3ZSBwYXNzIG1vdmVPdXRPZkVsZW1lbnQ9dHJ1ZSBhbmQgaXNCYWNrd2FyZD10cnVlLCB0aGVyZSBhcmVcbiAgICAgIC8vIHR3byBjYXNlcy4gSWYgdGhlIHVuY29udHJvbGxlZCBlbGVtZW50IGlzIGZvY3VzYWJsZSAoaGFzIHRhYmluZGV4PTApLFxuICAgICAgLy8gdGhlIHBoYW50b20gZHVtbXkgaW5wdXQgd2lsbCBiZSBpbnNlcnRlZCBhZnRlciBCdXR0b24xLiBJZiB0aGVcbiAgICAgIC8vIHVuY29udHJvbGxlZCBlbGVtZW50IGlzIG5vdCBmb2N1c2FibGUsIHRoZSBwaGFudG9tIGR1bW15IGlucHV0IHdpbGwgYmVcbiAgICAgIC8vIGluc2VydGVkIGJlZm9yZSBCdXR0b24yLlxuICAgICAgLy9cbiAgICAgIC8vIFdoZW4gd2UgcGFzcyBtb3ZlT3V0T2ZFbGVtZW50PWZhbHNlIGFuZCBpc0JhY2t3YXJkPWZhbHNlLCB0aGVcbiAgICAgIC8vIHBoYW50b20gZHVtbXkgaW5wdXQgd2lsbCBiZSBpbnNlcnRlZCBhZnRlciBCdXR0b24xLlxuICAgICAgLy9cbiAgICAgIC8vIFdoZW4gd2UgcGFzcyBtb3ZlT3V0T2ZFbGVtZW50PWZhbHNlIGFuZCBpc0JhY2t3YXJkPXRydWUsIHRoZSBwaGFudG9tXG4gICAgICAvLyBkdW1teSBpbnB1dCB3aWxsIGJlIGluc2VydGVkIGJlZm9yZSBCdXR0b240LlxuICAgICAgLy9cbiAgICAgIC8vIEFuZCB3ZSBoYXZlIGEgY29ybmVyIGNhc2UgZm9yIDxib2R5PiBhbmQgd2UgbWFrZSBzdXJlIHRoYXQgdGhlIGluc2VydGVkXG4gICAgICAvLyBkdW1teSBpcyBpbnNlcnRlZCBwcm9wZXJseSB3aGVuIHRoZXJlIGFyZSBleGlzdGluZyBwZXJtYW5lbnQgZHVtbWllcy5cbiAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUgPT09IFwiQk9EWVwiKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCBpbnNlcnQgZWxlbWVudHMgb3V0c2lkZSBvZiBCT0RZLlxuICAgICAgICBwYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBpbnNlcnRCZWZvcmUgPSBtb3ZlT3V0T2ZFbGVtZW50ICYmIGlzQmFja3dhcmQgfHwgIW1vdmVPdXRPZkVsZW1lbnQgJiYgIWlzQmFja3dhcmQgPyBkb20uZ2V0Rmlyc3RFbGVtZW50Q2hpbGQoZWxlbWVudCkgOiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1vdmVPdXRPZkVsZW1lbnQgJiYgKCFpc0JhY2t3YXJkIHx8IGlzQmFja3dhcmQgJiYgIXRhYnN0ZXIuZm9jdXNhYmxlLmlzRm9jdXNhYmxlKGVsZW1lbnQsIGZhbHNlLCB0cnVlLCB0cnVlKSkpIHtcbiAgICAgICAgICBwYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICAgIGluc2VydEJlZm9yZSA9IGlzQmFja3dhcmQgPyBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnQgPSBkb20uZ2V0UGFyZW50RWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICBpbnNlcnRCZWZvcmUgPSBtb3ZlT3V0T2ZFbGVtZW50ICYmIGlzQmFja3dhcmQgfHwgIW1vdmVPdXRPZkVsZW1lbnQgJiYgIWlzQmFja3dhcmQgPyBlbGVtZW50IDogZG9tLmdldE5leHRFbGVtZW50U2libGluZyhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcG90ZW50aWFsRHVtbXk7XG4gICAgICAgIGxldCBkdW1teUZvcjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSBzYWZldHkgcGlsbG93IGZvciB0aGUgY2FzZXMgd2hlbiBzb21lb25lLCBjb21iaW5lc1xuICAgICAgICAgIC8vIGdyb3VwcGVyIHdpdGggdW5jb250cm9sbGVkIG9uIHRoZSBzYW1lIG5vZGUuIFdoaWNoIGlzIHRlY2huaWNhbGx5XG4gICAgICAgICAgLy8gbm90IGNvcnJlY3QsIGJ1dCBtb3ZpbmcgaW50byB0aGUgY29udGFpbmVyIGVsZW1lbnQgdmlhIGl0cyBkdW1teVxuICAgICAgICAgIC8vIGlucHV0IHdvdWxkIHByb2R1Y2UgYSBjb3JyZWN0IGJlaGF2aW91ciBpbiB1bmNvbnRyb2xsZWQgbW9kZS5cbiAgICAgICAgICBwb3RlbnRpYWxEdW1teSA9IG1vdmVPdXRPZkVsZW1lbnQgJiYgaXNCYWNrd2FyZCB8fCAhbW92ZU91dE9mRWxlbWVudCAmJiAhaXNCYWNrd2FyZCA/IGRvbS5nZXRQcmV2aW91c0VsZW1lbnRTaWJsaW5nKGluc2VydEJlZm9yZSkgOiBpbnNlcnRCZWZvcmU7XG4gICAgICAgICAgZHVtbXlGb3IgPSBnZXREdW1teUlucHV0Q29udGFpbmVyKHBvdGVudGlhbER1bW15KTtcbiAgICAgICAgICBpZiAoZHVtbXlGb3IgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGluc2VydEJlZm9yZSA9IG1vdmVPdXRPZkVsZW1lbnQgJiYgaXNCYWNrd2FyZCB8fCAhbW92ZU91dE9mRWxlbWVudCAmJiAhaXNCYWNrd2FyZCA/IHBvdGVudGlhbER1bW15IDogZG9tLmdldE5leHRFbGVtZW50U2libGluZyhwb3RlbnRpYWxEdW1teSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR1bW15Rm9yID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGR1bW15Rm9yKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuZGlzcGF0Y2hFdmVudChuZXcgVGFic3Rlck1vdmVGb2N1c0V2ZW50KHtcbiAgICAgICAgYnk6IFwicm9vdFwiLFxuICAgICAgICBvd25lcjogcGFyZW50LFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICByZWxhdGVkRXZlbnRcbiAgICAgIH0pKSkge1xuICAgICAgICBkb20uaW5zZXJ0QmVmb3JlKHBhcmVudCwgaW5wdXQsIGluc2VydEJlZm9yZSk7XG4gICAgICAgIG5hdGl2ZUZvY3VzKGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhdGljIGFkZFBoYW50b21EdW1teVdpdGhUYXJnZXQodGFic3Rlciwgc291cmNlRWxlbWVudCwgaXNCYWNrd2FyZCwgdGFyZ2V0RWxlbWVudCkge1xuICAgIGNvbnN0IGR1bW15ID0gbmV3IER1bW15SW5wdXQodGFic3Rlci5nZXRXaW5kb3csIHRydWUsIHtcbiAgICAgIGlzUGhhbnRvbTogdHJ1ZSxcbiAgICAgIGlzRmlyc3Q6IHRydWVcbiAgICB9LCB1bmRlZmluZWQsIG5ldyBXZWFrSFRNTEVsZW1lbnQodGFic3Rlci5nZXRXaW5kb3csIHRhcmdldEVsZW1lbnQpKTtcbiAgICBjb25zdCBpbnB1dCA9IGR1bW15LmlucHV0O1xuICAgIGlmIChpbnB1dCkge1xuICAgICAgbGV0IGR1bW15UGFyZW50O1xuICAgICAgbGV0IGluc2VydEJlZm9yZTtcbiAgICAgIGlmIChoYXNTdWJGb2N1c2FibGUoc291cmNlRWxlbWVudCkgJiYgIWlzQmFja3dhcmQpIHtcbiAgICAgICAgZHVtbXlQYXJlbnQgPSBzb3VyY2VFbGVtZW50O1xuICAgICAgICBpbnNlcnRCZWZvcmUgPSBkb20uZ2V0Rmlyc3RFbGVtZW50Q2hpbGQoc291cmNlRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkdW1teVBhcmVudCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KHNvdXJjZUVsZW1lbnQpO1xuICAgICAgICBpbnNlcnRCZWZvcmUgPSBpc0JhY2t3YXJkID8gc291cmNlRWxlbWVudCA6IGRvbS5nZXROZXh0RWxlbWVudFNpYmxpbmcoc291cmNlRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBpZiAoZHVtbXlQYXJlbnQpIHtcbiAgICAgICAgZG9tLmluc2VydEJlZm9yZShkdW1teVBhcmVudCwgaW5wdXQsIGluc2VydEJlZm9yZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXREdW1teUlucHV0RGVidWdWYWx1ZShkdW1teSwgd3JhcHBlcnMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB3aGF0ID0ge1xuICAgIDE6IFwiUm9vdFwiLFxuICAgIDI6IFwiTW9kYWxpemVyXCIsXG4gICAgMzogXCJNb3ZlclwiLFxuICAgIDQ6IFwiR3JvdXBwZXJcIlxuICB9O1xuICAoX2EgPSBkdW1teS5pbnB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEF0dHJpYnV0ZShUQUJTVEVSX0RVTU1ZX0lOUFVUX0FUVFJJQlVURV9OQU1FLCBbYGlzRmlyc3Q9JHtkdW1teS5pc0ZpcnN0fWAsIGBpc091dHNpZGU9JHtkdW1teS5pc091dHNpZGV9YCwgLi4ud3JhcHBlcnMubWFwKHcgPT4gYCgke3doYXRbdy5wcmlvcml0eV19LCB0YWJiYWJsZT0ke3cudGFiYmFibGV9KWApXS5qb2luKFwiLCBcIikpO1xufVxuY2xhc3MgRHVtbXlJbnB1dE9ic2VydmVyIHtcbiAgY29uc3RydWN0b3Iod2luKSB7XG4gICAgdGhpcy5fdXBkYXRlUXVldWUgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fbGFzdFVwZGF0ZVF1ZXVlVGltZSA9IDA7XG4gICAgdGhpcy5fY2hhbmdlZFBhcmVudHMgPSBuZXcgV2Vha1NldCgpO1xuICAgIHRoaXMuX2R1bW15RWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl9kdW1teUNhbGxiYWNrcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5fZG9tQ2hhbmdlZCA9IHBhcmVudCA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAodGhpcy5fY2hhbmdlZFBhcmVudHMuaGFzKHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2hhbmdlZFBhcmVudHMuYWRkKHBhcmVudCk7XG4gICAgICBpZiAodGhpcy5fdXBkYXRlRHVtbXlJbnB1dHNUaW1lcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVEdW1teUlucHV0c1RpbWVyID0gKF9hID0gdGhpcy5fd2luKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKS5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3VwZGF0ZUR1bW15SW5wdXRzVGltZXI7XG4gICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHRoaXMuX2R1bW15RWxlbWVudHMpIHtcbiAgICAgICAgICBjb25zdCBkdW1teUVsZW1lbnQgPSByZWYuZ2V0KCk7XG4gICAgICAgICAgaWYgKGR1bW15RWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9kdW1teUNhbGxiYWNrcy5nZXQoZHVtbXlFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjb25zdCBkdW1teVBhcmVudCA9IGRvbS5nZXRQYXJlbnROb2RlKGR1bW15RWxlbWVudCk7XG4gICAgICAgICAgICAgIGlmICghZHVtbXlQYXJlbnQgfHwgdGhpcy5fY2hhbmdlZFBhcmVudHMuaGFzKGR1bW15UGFyZW50KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhbmdlZFBhcmVudHMgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgfSwgX3VwZGF0ZUR1bW15SW5wdXRzVGltZW91dCk7XG4gICAgfTtcbiAgICB0aGlzLl93aW4gPSB3aW47XG4gIH1cbiAgYWRkKGR1bW15LCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5fZHVtbXlDYWxsYmFja3MuaGFzKGR1bW15KSAmJiB0aGlzLl93aW4pIHtcbiAgICAgIHRoaXMuX2R1bW15RWxlbWVudHMucHVzaChuZXcgV2Vha0hUTUxFbGVtZW50KHRoaXMuX3dpbiwgZHVtbXkpKTtcbiAgICAgIHRoaXMuX2R1bW15Q2FsbGJhY2tzLnNldChkdW1teSwgY2FsbGJhY2spO1xuICAgICAgdGhpcy5kb21DaGFuZ2VkID0gdGhpcy5fZG9tQ2hhbmdlZDtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlKGR1bW15KSB7XG4gICAgdGhpcy5fZHVtbXlFbGVtZW50cyA9IHRoaXMuX2R1bW15RWxlbWVudHMuZmlsdGVyKHJlZiA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gcmVmLmdldCgpO1xuICAgICAgcmV0dXJuIGVsZW1lbnQgJiYgZWxlbWVudCAhPT0gZHVtbXk7XG4gICAgfSk7XG4gICAgdGhpcy5fZHVtbXlDYWxsYmFja3MuZGVsZXRlKGR1bW15KTtcbiAgICBpZiAodGhpcy5fZHVtbXlFbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRvbUNoYW5nZWQ7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHdpbiA9IChfYSA9IHRoaXMuX3dpbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuX3VwZGF0ZVRpbWVyKSB7XG4gICAgICB3aW4gPT09IG51bGwgfHwgd2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW4uY2xlYXJUaW1lb3V0KHRoaXMuX3VwZGF0ZVRpbWVyKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVUaW1lcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3VwZGF0ZUR1bW15SW5wdXRzVGltZXIpIHtcbiAgICAgIHdpbiA9PT0gbnVsbCB8fCB3aW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbi5jbGVhclRpbWVvdXQodGhpcy5fdXBkYXRlRHVtbXlJbnB1dHNUaW1lcik7XG4gICAgICBkZWxldGUgdGhpcy5fdXBkYXRlRHVtbXlJbnB1dHNUaW1lcjtcbiAgICB9XG4gICAgdGhpcy5fY2hhbmdlZFBhcmVudHMgPSBuZXcgV2Vha1NldCgpO1xuICAgIHRoaXMuX2R1bW15Q2FsbGJhY2tzID0gbmV3IFdlYWtNYXAoKTtcbiAgICB0aGlzLl9kdW1teUVsZW1lbnRzID0gW107XG4gICAgdGhpcy5fdXBkYXRlUXVldWUuY2xlYXIoKTtcbiAgICBkZWxldGUgdGhpcy5kb21DaGFuZ2VkO1xuICAgIGRlbGV0ZSB0aGlzLl93aW47XG4gIH1cbiAgdXBkYXRlUG9zaXRpb25zKGNvbXB1dGUpIHtcbiAgICBpZiAoIXRoaXMuX3dpbikge1xuICAgICAgLy8gQXMgdGhpcyBpcyBhIHB1YmxpYyBtZXRob2QsIHdlIG1ha2Ugc3VyZSB0aGF0IGl0IGhhcyBubyBlZmZlY3Qgd2hlblxuICAgICAgLy8gY2FsbGVkIGFmdGVyIGRpc3Bvc2UoKS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlUXVldWUuYWRkKGNvbXB1dGUpO1xuICAgIHRoaXMuX2xhc3RVcGRhdGVRdWV1ZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuX3NjaGVkdWxlZFVwZGF0ZVBvc2l0aW9ucygpO1xuICB9XG4gIF9zY2hlZHVsZWRVcGRhdGVQb3NpdGlvbnMoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0aGlzLl91cGRhdGVUaW1lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVUaW1lciA9IChfYSA9IHRoaXMuX3dpbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcykuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBkZWxldGUgdGhpcy5fdXBkYXRlVGltZXI7XG4gICAgICAvLyB1cGRhdGVQb3NpdGlvbnMoKSBtaWdodCBiZSBjYWxsZWQgcXVpdGUgYSBsb3QgZHVyaW5nIHRoZSBzY3JvbGxpbmcuXG4gICAgICAvLyBTbywgaW5zdGVhZCBvZiBjbGVhcmluZyB0aGUgdGltZW91dCBhbmQgc2NoZWR1bGluZyBhIG5ldyBvbmUsIHdlXG4gICAgICAvLyBjaGVjayBpZiBlbm91Z2ggdGltZSBoYXMgcGFzc2VkIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZVBvc2l0aW9ucygpIGNhbGxcbiAgICAgIC8vIGFuZCBvbmx5IHNjaGVkdWxlIGEgbmV3IG9uZSBpZiBub3QuXG4gICAgICAvLyBBdCBtYXhpbXVtLCB3ZSB3aWxsIHVwZGF0ZSBkdW1teSBpbnB1dHMgcG9zaXRpb25zXG4gICAgICAvLyBfdXBkYXRlRHVtbXlJbnB1dHNUaW1lb3V0ICogMiBhZnRlciB0aGUgbGFzdCB1cGRhdGVQb3NpdGlvbnMoKSBjYWxsLlxuICAgICAgaWYgKHRoaXMuX2xhc3RVcGRhdGVRdWV1ZVRpbWUgKyBfdXBkYXRlRHVtbXlJbnB1dHNUaW1lb3V0IDw9IERhdGUubm93KCkpIHtcbiAgICAgICAgLy8gQSBjYWNoZSBmb3IgY3VycmVudCBidWxrIG9mIHVwZGF0ZXMgdG8gcmVkdWNlIGdldENvbXB1dGVkU3R5bGUoKSBjYWxscy5cbiAgICAgICAgY29uc3Qgc2Nyb2xsVG9wTGVmdENhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBzZXRUb3BMZWZ0Q2FsbGJhY2tzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgY29tcHV0ZSBvZiB0aGlzLl91cGRhdGVRdWV1ZSkge1xuICAgICAgICAgIHNldFRvcExlZnRDYWxsYmFja3MucHVzaChjb21wdXRlKHNjcm9sbFRvcExlZnRDYWNoZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZVF1ZXVlLmNsZWFyKCk7XG4gICAgICAgIC8vIFdlJ3JlIHNwbGl0dGluZyB0aGUgY29tcHV0YXRpb24gb2Ygb2Zmc2V0cyBhbmQgc2V0dGluZyB0aGVtIHRvIGF2b2lkIGV4dHJhXG4gICAgICAgIC8vIHJlZmxvd3MuXG4gICAgICAgIGZvciAoY29uc3Qgc2V0VG9wTGVmdCBvZiBzZXRUb3BMZWZ0Q2FsbGJhY2tzKSB7XG4gICAgICAgICAgc2V0VG9wTGVmdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgY2xlYXIgdG8gbm90IGhvbGQgcmVmZXJlbmNlcyB0aWxsIHRoZSBuZXh0IGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICAgICAgc2Nyb2xsVG9wTGVmdENhY2hlLmNsZWFyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zY2hlZHVsZWRVcGRhdGVQb3NpdGlvbnMoKTtcbiAgICAgIH1cbiAgICB9LCBfdXBkYXRlRHVtbXlJbnB1dHNUaW1lb3V0KTtcbiAgfVxufVxuLyoqXG4gKiBQYXJlbnQgY2xhc3MgdGhhdCBlbmNhcHN1bGF0ZXMgdGhlIGJlaGF2aW91ciBvZiBkdW1teSBpbnB1dHMgKGZvY3VzIHNlbnRpbmVscylcbiAqL1xuY2xhc3MgRHVtbXlJbnB1dE1hbmFnZXJDb3JlIHtcbiAgY29uc3RydWN0b3IodGFic3RlciwgZWxlbWVudCwgbWFuYWdlciwgcHJpb3JpdHksIHN5cywgb3V0c2lkZUJ5RGVmYXVsdCwgY2FsbEZvckRlZmF1bHRBY3Rpb24pIHtcbiAgICB0aGlzLl93cmFwcGVycyA9IFtdO1xuICAgIHRoaXMuX2lzT3V0c2lkZSA9IGZhbHNlO1xuICAgIHRoaXMuX3RyYW5zZm9ybUVsZW1lbnRzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX29uRm9jdXNJbiA9IChkdW1teUlucHV0LCBpc0JhY2t3YXJkLCByZWxhdGVkVGFyZ2V0KSA9PiB7XG4gICAgICB0aGlzLl9vbkZvY3VzKHRydWUsIGR1bW15SW5wdXQsIGlzQmFja3dhcmQsIHJlbGF0ZWRUYXJnZXQpO1xuICAgIH07XG4gICAgdGhpcy5fb25Gb2N1c091dCA9IChkdW1teUlucHV0LCBpc0JhY2t3YXJkLCByZWxhdGVkVGFyZ2V0KSA9PiB7XG4gICAgICB0aGlzLl9vbkZvY3VzKGZhbHNlLCBkdW1teUlucHV0LCBpc0JhY2t3YXJkLCByZWxhdGVkVGFyZ2V0KTtcbiAgICB9O1xuICAgIHRoaXMubW92ZU91dCA9IGJhY2t3YXJkcyA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBmaXJzdCA9IHRoaXMuX2ZpcnN0RHVtbXk7XG4gICAgICBjb25zdCBsYXN0ID0gdGhpcy5fbGFzdER1bW15O1xuICAgICAgaWYgKGZpcnN0ICYmIGxhc3QpIHtcbiAgICAgICAgLy8gRm9yIHRoZSBzYWtlIG9mIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiwgdGhlIGR1bW15IGlucHV0XG4gICAgICAgIC8vIHBvc2l0aW9uIGluIHRoZSBET00gdXBkYXRlcyBhc3luY2hyb25vdXNseSBmcm9tIHRoZSBET00gY2hhbmdlLlxuICAgICAgICAvLyBDYWxsaW5nIF9lbnN1cmVQb3NpdGlvbigpIHRvIG1ha2Ugc3VyZSB0aGUgcG9zaXRpb24gaXMgY29ycmVjdC5cbiAgICAgICAgdGhpcy5fZW5zdXJlUG9zaXRpb24oKTtcbiAgICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IGZpcnN0LmlucHV0O1xuICAgICAgICBjb25zdCBsYXN0SW5wdXQgPSBsYXN0LmlucHV0O1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gKF9hID0gdGhpcy5fZWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldCgpO1xuICAgICAgICBpZiAoZmlyc3RJbnB1dCAmJiBsYXN0SW5wdXQgJiYgZWxlbWVudCkge1xuICAgICAgICAgIGxldCB0b0ZvY3VzO1xuICAgICAgICAgIGlmIChiYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIGZpcnN0SW5wdXQudGFiSW5kZXggPSAwO1xuICAgICAgICAgICAgdG9Gb2N1cyA9IGZpcnN0SW5wdXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RJbnB1dC50YWJJbmRleCA9IDA7XG4gICAgICAgICAgICB0b0ZvY3VzID0gbGFzdElucHV0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9Gb2N1cykge1xuICAgICAgICAgICAgbmF0aXZlRm9jdXModG9Gb2N1cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyB0byBtb3ZlIGZvY3VzIG91dCBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBieSBmb2N1c2luZ1xuICAgICAqIG9uZSBvZiB0aGUgZHVtbXkgaW5wdXRzIGFuZCBzZXR0aW5nIHRoZSBgdXNlRGVmYXVsdEFjdGlvbmAgZmxhZ1xuICAgICAqIEBwYXJhbSBiYWNrd2FyZHMgZm9jdXMgbW92aW5nIHRvIGFuIGVsZW1lbnQgYmVoaW5kIHRoZSBnaXZlbiBlbGVtZW50XG4gICAgICovXG4gICAgdGhpcy5tb3ZlT3V0V2l0aERlZmF1bHRBY3Rpb24gPSAoYmFja3dhcmRzLCByZWxhdGVkRXZlbnQpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5fZmlyc3REdW1teTtcbiAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLl9sYXN0RHVtbXk7XG4gICAgICBpZiAoZmlyc3QgJiYgbGFzdCkge1xuICAgICAgICAvLyBGb3IgdGhlIHNha2Ugb2YgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCB0aGUgZHVtbXkgaW5wdXRcbiAgICAgICAgLy8gcG9zaXRpb24gaW4gdGhlIERPTSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5IGZyb20gdGhlIERPTSBjaGFuZ2UuXG4gICAgICAgIC8vIENhbGxpbmcgX2Vuc3VyZVBvc2l0aW9uKCkgdG8gbWFrZSBzdXJlIHRoZSBwb3NpdGlvbiBpcyBjb3JyZWN0LlxuICAgICAgICB0aGlzLl9lbnN1cmVQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCBmaXJzdElucHV0ID0gZmlyc3QuaW5wdXQ7XG4gICAgICAgIGNvbnN0IGxhc3RJbnB1dCA9IGxhc3QuaW5wdXQ7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSAoX2EgPSB0aGlzLl9lbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCk7XG4gICAgICAgIGlmIChmaXJzdElucHV0ICYmIGxhc3RJbnB1dCAmJiBlbGVtZW50KSB7XG4gICAgICAgICAgbGV0IHRvRm9jdXM7XG4gICAgICAgICAgaWYgKGJhY2t3YXJkcykge1xuICAgICAgICAgICAgaWYgKCFmaXJzdC5pc091dHNpZGUgJiYgdGhpcy5fdGFic3Rlci5mb2N1c2FibGUuaXNGb2N1c2FibGUoZWxlbWVudCwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgdG9Gb2N1cyA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaXJzdC51c2VEZWZhdWx0QWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZmlyc3RJbnB1dC50YWJJbmRleCA9IDA7XG4gICAgICAgICAgICAgIHRvRm9jdXMgPSBmaXJzdElucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0LnVzZURlZmF1bHRBY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgbGFzdElucHV0LnRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgIHRvRm9jdXMgPSBsYXN0SW5wdXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b0ZvY3VzICYmIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgVGFic3Rlck1vdmVGb2N1c0V2ZW50KHtcbiAgICAgICAgICAgIGJ5OiBcInJvb3RcIixcbiAgICAgICAgICAgIG93bmVyOiBlbGVtZW50LFxuICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgICAgIHJlbGF0ZWRFdmVudFxuICAgICAgICAgIH0pKSkge1xuICAgICAgICAgICAgbmF0aXZlRm9jdXModG9Gb2N1cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnNldFRhYmJhYmxlID0gKG1hbmFnZXIsIHRhYmJhYmxlKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgZm9yIChjb25zdCB3IG9mIHRoaXMuX3dyYXBwZXJzKSB7XG4gICAgICAgIGlmICh3Lm1hbmFnZXIgPT09IG1hbmFnZXIpIHtcbiAgICAgICAgICB3LnRhYmJhYmxlID0gdGFiYmFibGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLl9nZXRDdXJyZW50KCk7XG4gICAgICBpZiAod3JhcHBlcikge1xuICAgICAgICBjb25zdCB0YWJJbmRleCA9IHdyYXBwZXIudGFiYmFibGUgPyAwIDogLTE7XG4gICAgICAgIGxldCBpbnB1dCA9IChfYSA9IHRoaXMuX2ZpcnN0RHVtbXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbnB1dDtcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgaW5wdXQudGFiSW5kZXggPSB0YWJJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IChfYiA9IHRoaXMuX2xhc3REdW1teSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlucHV0O1xuICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICBpbnB1dC50YWJJbmRleCA9IHRhYkluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgdGhpcy5fZmlyc3REdW1teSAmJiBzZXREdW1teUlucHV0RGVidWdWYWx1ZSh0aGlzLl9maXJzdER1bW15LCB0aGlzLl93cmFwcGVycyk7XG4gICAgICAgIHRoaXMuX2xhc3REdW1teSAmJiBzZXREdW1teUlucHV0RGVidWdWYWx1ZSh0aGlzLl9sYXN0RHVtbXksIHRoaXMuX3dyYXBwZXJzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgZHVtbXkgaW5wdXRzIGFzIHRoZSBmaXJzdCBhbmQgbGFzdCBjaGlsZCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgICAqIENhbGxlZCBlYWNoIHRpbWUgdGhlIGNoaWxkcmVuIHVuZGVyIHRoZSBlbGVtZW50IGlzIG11dGF0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9hZGREdW1teUlucHV0cyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9hZGRUaW1lcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9hZGRUaW1lciA9IHRoaXMuX2dldFdpbmRvdygpLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5fYWRkVGltZXI7XG4gICAgICAgIHRoaXMuX2Vuc3VyZVBvc2l0aW9uKCk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIHRoaXMuX2ZpcnN0RHVtbXkgJiYgc2V0RHVtbXlJbnB1dERlYnVnVmFsdWUodGhpcy5fZmlyc3REdW1teSwgdGhpcy5fd3JhcHBlcnMpO1xuICAgICAgICAgIHRoaXMuX2xhc3REdW1teSAmJiBzZXREdW1teUlucHV0RGVidWdWYWx1ZSh0aGlzLl9sYXN0RHVtbXksIHRoaXMuX3dyYXBwZXJzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRUcmFuc2Zvcm1PZmZzZXRzKCk7XG4gICAgICB9LCAwKTtcbiAgICB9O1xuICAgIHRoaXMuX2FkZFRyYW5zZm9ybU9mZnNldHMgPSAoKSA9PiB7XG4gICAgICB0aGlzLl90YWJzdGVyLl9kdW1teU9ic2VydmVyLnVwZGF0ZVBvc2l0aW9ucyh0aGlzLl9jb21wdXRlVHJhbnNmb3JtT2Zmc2V0cyk7XG4gICAgfTtcbiAgICB0aGlzLl9jb21wdXRlVHJhbnNmb3JtT2Zmc2V0cyA9IHNjcm9sbFRvcExlZnRDYWNoZSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgZnJvbSA9ICgoX2EgPSB0aGlzLl9maXJzdER1bW15KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5wdXQpIHx8ICgoX2IgPSB0aGlzLl9sYXN0RHVtbXkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbnB1dCk7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1FbGVtZW50cyA9IHRoaXMuX3RyYW5zZm9ybUVsZW1lbnRzO1xuICAgICAgY29uc3QgbmV3VHJhbnNmb3JtRWxlbWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICBsZXQgc2Nyb2xsVG9wID0gMDtcbiAgICAgIGxldCBzY3JvbGxMZWZ0ID0gMDtcbiAgICAgIGNvbnN0IHdpbiA9IHRoaXMuX2dldFdpbmRvdygpO1xuICAgICAgZm9yIChsZXQgZWxlbWVudCA9IGZyb207IGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7IGVsZW1lbnQgPSBkb20uZ2V0UGFyZW50RWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICBsZXQgc2Nyb2xsVG9wTGVmdCA9IHNjcm9sbFRvcExlZnRDYWNoZS5nZXQoZWxlbWVudCk7XG4gICAgICAgIC8vIGdldENvbXB1dGVkU3R5bGUoKSBhbmQgZWxlbWVudC5zY3JvbGxMZWZ0L1RvcCgpIGNhdXNlIHN0eWxlIHJlY2FsY3VsYXRpb24sXG4gICAgICAgIC8vIHNvIHdlIGNhY2hlIHRoZSByZXN1bHQgYWNyb3NzIGFsbCBlbGVtZW50cyBpbiB0aGUgY3VycmVudCBidWxrLlxuICAgICAgICBpZiAoc2Nyb2xsVG9wTGVmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkudHJhbnNmb3JtO1xuICAgICAgICAgIGlmICh0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgc2Nyb2xsVG9wTGVmdCA9IHtcbiAgICAgICAgICAgICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY3JvbGxUb3BMZWZ0Q2FjaGUuc2V0KGVsZW1lbnQsIHNjcm9sbFRvcExlZnQgfHwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjcm9sbFRvcExlZnQpIHtcbiAgICAgICAgICBuZXdUcmFuc2Zvcm1FbGVtZW50cy5hZGQoZWxlbWVudCk7XG4gICAgICAgICAgaWYgKCF0cmFuc2Zvcm1FbGVtZW50cy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLl9hZGRUcmFuc2Zvcm1PZmZzZXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2Nyb2xsVG9wICs9IHNjcm9sbFRvcExlZnQuc2Nyb2xsVG9wO1xuICAgICAgICAgIHNjcm9sbExlZnQgKz0gc2Nyb2xsVG9wTGVmdC5zY3JvbGxMZWZ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGVsIG9mIHRyYW5zZm9ybUVsZW1lbnRzKSB7XG4gICAgICAgIGlmICghbmV3VHJhbnNmb3JtRWxlbWVudHMuaGFzKGVsKSkge1xuICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5fYWRkVHJhbnNmb3JtT2Zmc2V0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3RyYW5zZm9ybUVsZW1lbnRzID0gbmV3VHJhbnNmb3JtRWxlbWVudHM7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAoX2EgPSB0aGlzLl9maXJzdER1bW15KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0VG9wTGVmdChzY3JvbGxUb3AsIHNjcm9sbExlZnQpO1xuICAgICAgICAoX2IgPSB0aGlzLl9sYXN0RHVtbXkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXRUb3BMZWZ0KHNjcm9sbFRvcCwgc2Nyb2xsTGVmdCk7XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgZWwgPSBlbGVtZW50LmdldCgpO1xuICAgIGlmICghZWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVsZW1lbnRcIik7XG4gICAgfVxuICAgIHRoaXMuX3RhYnN0ZXIgPSB0YWJzdGVyO1xuICAgIHRoaXMuX2dldFdpbmRvdyA9IHRhYnN0ZXIuZ2V0V2luZG93O1xuICAgIHRoaXMuX2NhbGxGb3JEZWZhdWx0QWN0aW9uID0gY2FsbEZvckRlZmF1bHRBY3Rpb247XG4gICAgY29uc3QgaW5zdGFuY2UgPSBlbC5fX3RhYnN0ZXJEdW1teTtcbiAgICAoaW5zdGFuY2UgfHwgdGhpcykuX3dyYXBwZXJzLnB1c2goe1xuICAgICAgbWFuYWdlcixcbiAgICAgIHByaW9yaXR5LFxuICAgICAgdGFiYmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICB0aGlzLl9maXJzdER1bW15ICYmIHNldER1bW15SW5wdXREZWJ1Z1ZhbHVlKHRoaXMuX2ZpcnN0RHVtbXksIGluc3RhbmNlLl93cmFwcGVycyk7XG4gICAgICAgIHRoaXMuX2xhc3REdW1teSAmJiBzZXREdW1teUlucHV0RGVidWdWYWx1ZSh0aGlzLl9sYXN0RHVtbXksIGluc3RhbmNlLl93cmFwcGVycyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIGVsLl9fdGFic3RlckR1bW15ID0gdGhpcztcbiAgICAvLyBTb21lIGVsZW1lbnRzIGFsbG93IG9ubHkgc3BlY2lmaWMgdHlwZXMgb2YgZGlyZWN0IGRlc2NlbmRhbnRzIGFuZCB3ZSBuZWVkIHRvXG4gICAgLy8gcHV0IG91ciBkdW1teSBpbnB1dHMgaW5zaWRlIG9yIG91dHNpZGUgb2YgdGhlIGVsZW1lbnQgYWNjb3JkaW5nbHkuXG4gICAgY29uc3QgZm9yY2VkRHVtbXlQb3NpdGlvbiA9IHN5cyA9PT0gbnVsbCB8fCBzeXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN5cy5kdW1teUlucHV0c1Bvc2l0aW9uO1xuICAgIGNvbnN0IHRhZ05hbWUgPSBlbC50YWdOYW1lO1xuICAgIHRoaXMuX2lzT3V0c2lkZSA9ICFmb3JjZWREdW1teVBvc2l0aW9uID8gKG91dHNpZGVCeURlZmF1bHQgfHwgdGFnTmFtZSA9PT0gXCJVTFwiIHx8IHRhZ05hbWUgPT09IFwiT0xcIiB8fCB0YWdOYW1lID09PSBcIlRBQkxFXCIpICYmICEodGFnTmFtZSA9PT0gXCJMSVwiIHx8IHRhZ05hbWUgPT09IFwiVERcIiB8fCB0YWdOYW1lID09PSBcIlRIXCIpIDogZm9yY2VkRHVtbXlQb3NpdGlvbiA9PT0gU3lzRHVtbXlJbnB1dHNQb3NpdGlvbnMuT3V0c2lkZTtcbiAgICB0aGlzLl9maXJzdER1bW15ID0gbmV3IER1bW15SW5wdXQodGhpcy5fZ2V0V2luZG93LCB0aGlzLl9pc091dHNpZGUsIHtcbiAgICAgIGlzRmlyc3Q6IHRydWVcbiAgICB9LCBlbGVtZW50KTtcbiAgICB0aGlzLl9sYXN0RHVtbXkgPSBuZXcgRHVtbXlJbnB1dCh0aGlzLl9nZXRXaW5kb3csIHRoaXMuX2lzT3V0c2lkZSwge1xuICAgICAgaXNGaXJzdDogZmFsc2VcbiAgICB9LCBlbGVtZW50KTtcbiAgICAvLyBXZSB3aWxsIGJlIGNoZWNraW5nIGR1bW15IGlucHV0IHBhcmVudHMgdG8gc2VlIGlmIHRoZWlyIGNoaWxkIGxpc3QgaGF2ZSBjaGFuZ2VkLlxuICAgIC8vIFNvLCBpdCBpcyBlbm91Z2ggdG8gaGF2ZSBqdXN0IG9uZSBvZiB0aGUgaW5wdXRzIG9ic2VydmVkLCBiZWNhdXNlXG4gICAgLy8gYm90aCBkdW1teSBpbnB1dHMgYWx3YXlzIGhhdmUgdGhlIHNhbWUgcGFyZW50LlxuICAgIGNvbnN0IGR1bW15RWxlbWVudCA9IHRoaXMuX2ZpcnN0RHVtbXkuaW5wdXQ7XG4gICAgZHVtbXlFbGVtZW50ICYmIHRhYnN0ZXIuX2R1bW15T2JzZXJ2ZXIuYWRkKGR1bW15RWxlbWVudCwgdGhpcy5fYWRkRHVtbXlJbnB1dHMpO1xuICAgIHRoaXMuX2ZpcnN0RHVtbXkub25Gb2N1c0luID0gdGhpcy5fb25Gb2N1c0luO1xuICAgIHRoaXMuX2ZpcnN0RHVtbXkub25Gb2N1c091dCA9IHRoaXMuX29uRm9jdXNPdXQ7XG4gICAgdGhpcy5fbGFzdER1bW15Lm9uRm9jdXNJbiA9IHRoaXMuX29uRm9jdXNJbjtcbiAgICB0aGlzLl9sYXN0RHVtbXkub25Gb2N1c091dCA9IHRoaXMuX29uRm9jdXNPdXQ7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fYWRkRHVtbXlJbnB1dHMoKTtcbiAgfVxuICBkaXNwb3NlKG1hbmFnZXIsIGZvcmNlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHdyYXBwZXJzID0gdGhpcy5fd3JhcHBlcnMgPSB0aGlzLl93cmFwcGVycy5maWx0ZXIodyA9PiB3Lm1hbmFnZXIgIT09IG1hbmFnZXIgJiYgIWZvcmNlKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIHRoaXMuX2ZpcnN0RHVtbXkgJiYgc2V0RHVtbXlJbnB1dERlYnVnVmFsdWUodGhpcy5fZmlyc3REdW1teSwgd3JhcHBlcnMpO1xuICAgICAgdGhpcy5fbGFzdER1bW15ICYmIHNldER1bW15SW5wdXREZWJ1Z1ZhbHVlKHRoaXMuX2xhc3REdW1teSwgd3JhcHBlcnMpO1xuICAgIH1cbiAgICBpZiAod3JhcHBlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgKChfYSA9IHRoaXMuX2VsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKSkuX190YWJzdGVyRHVtbXk7XG4gICAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMuX3RyYW5zZm9ybUVsZW1lbnRzKSB7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5fYWRkVHJhbnNmb3JtT2Zmc2V0cyk7XG4gICAgICB9XG4gICAgICB0aGlzLl90cmFuc2Zvcm1FbGVtZW50cy5jbGVhcigpO1xuICAgICAgY29uc3Qgd2luID0gdGhpcy5fZ2V0V2luZG93KCk7XG4gICAgICBpZiAodGhpcy5fYWRkVGltZXIpIHtcbiAgICAgICAgd2luLmNsZWFyVGltZW91dCh0aGlzLl9hZGRUaW1lcik7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9hZGRUaW1lcjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGR1bW15RWxlbWVudCA9IChfYiA9IHRoaXMuX2ZpcnN0RHVtbXkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbnB1dDtcbiAgICAgIGR1bW15RWxlbWVudCAmJiB0aGlzLl90YWJzdGVyLl9kdW1teU9ic2VydmVyLnJlbW92ZShkdW1teUVsZW1lbnQpO1xuICAgICAgKF9jID0gdGhpcy5fZmlyc3REdW1teSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRpc3Bvc2UoKTtcbiAgICAgIChfZCA9IHRoaXMuX2xhc3REdW1teSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cbiAgX29uRm9jdXMoaXNJbiwgZHVtbXlJbnB1dCwgaXNCYWNrd2FyZCwgcmVsYXRlZFRhcmdldCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB3cmFwcGVyID0gdGhpcy5fZ2V0Q3VycmVudCgpO1xuICAgIGlmICh3cmFwcGVyICYmICghZHVtbXlJbnB1dC51c2VEZWZhdWx0QWN0aW9uIHx8IHRoaXMuX2NhbGxGb3JEZWZhdWx0QWN0aW9uKSkge1xuICAgICAgKF9hID0gd3JhcHBlci5tYW5hZ2VyLmdldEhhbmRsZXIoaXNJbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYShkdW1teUlucHV0LCBpc0JhY2t3YXJkLCByZWxhdGVkVGFyZ2V0KTtcbiAgICB9XG4gIH1cbiAgX2dldEN1cnJlbnQoKSB7XG4gICAgdGhpcy5fd3JhcHBlcnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgaWYgKGEudGFiYmFibGUgIT09IGIudGFiYmFibGUpIHtcbiAgICAgICAgcmV0dXJuIGEudGFiYmFibGUgPyAtMSA6IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZXJzWzBdO1xuICB9XG4gIF9lbnN1cmVQb3NpdGlvbigpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBlbGVtZW50ID0gKF9hID0gdGhpcy5fZWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldCgpO1xuICAgIGNvbnN0IGZpcnN0RHVtbXlJbnB1dCA9IChfYiA9IHRoaXMuX2ZpcnN0RHVtbXkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbnB1dDtcbiAgICBjb25zdCBsYXN0RHVtbXlJbnB1dCA9IChfYyA9IHRoaXMuX2xhc3REdW1teSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmlucHV0O1xuICAgIGlmICghZWxlbWVudCB8fCAhZmlyc3REdW1teUlucHV0IHx8ICFsYXN0RHVtbXlJbnB1dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5faXNPdXRzaWRlKSB7XG4gICAgICBjb25zdCBlbGVtZW50UGFyZW50ID0gZG9tLmdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gICAgICBpZiAoZWxlbWVudFBhcmVudCkge1xuICAgICAgICBjb25zdCBuZXh0U2libGluZyA9IGRvbS5nZXROZXh0U2libGluZyhlbGVtZW50KTtcbiAgICAgICAgaWYgKG5leHRTaWJsaW5nICE9PSBsYXN0RHVtbXlJbnB1dCkge1xuICAgICAgICAgIGRvbS5pbnNlcnRCZWZvcmUoZWxlbWVudFBhcmVudCwgbGFzdER1bW15SW5wdXQsIG5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9tLmdldFByZXZpb3VzRWxlbWVudFNpYmxpbmcoZWxlbWVudCkgIT09IGZpcnN0RHVtbXlJbnB1dCkge1xuICAgICAgICAgIGRvbS5pbnNlcnRCZWZvcmUoZWxlbWVudFBhcmVudCwgZmlyc3REdW1teUlucHV0LCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZG9tLmdldExhc3RFbGVtZW50Q2hpbGQoZWxlbWVudCkgIT09IGxhc3REdW1teUlucHV0KSB7XG4gICAgICAgIGRvbS5hcHBlbmRDaGlsZChlbGVtZW50LCBsYXN0RHVtbXlJbnB1dCk7XG4gICAgICB9XG4gICAgICBjb25zdCBmaXJzdEVsZW1lbnRDaGlsZCA9IGRvbS5nZXRGaXJzdEVsZW1lbnRDaGlsZChlbGVtZW50KTtcbiAgICAgIGlmIChmaXJzdEVsZW1lbnRDaGlsZCAmJiBmaXJzdEVsZW1lbnRDaGlsZCAhPT0gZmlyc3REdW1teUlucHV0ICYmIGZpcnN0RWxlbWVudENoaWxkLnBhcmVudE5vZGUpIHtcbiAgICAgICAgZG9tLmluc2VydEJlZm9yZShmaXJzdEVsZW1lbnRDaGlsZC5wYXJlbnROb2RlLCBmaXJzdER1bW15SW5wdXQsIGZpcnN0RWxlbWVudENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExhc3RDaGlsZCQyKGNvbnRhaW5lcikge1xuICBsZXQgbGFzdENoaWxkID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IGRvbS5nZXRMYXN0RWxlbWVudENoaWxkKGNvbnRhaW5lcik7IGk7IGkgPSBkb20uZ2V0TGFzdEVsZW1lbnRDaGlsZChpKSkge1xuICAgIGxhc3RDaGlsZCA9IGk7XG4gIH1cbiAgcmV0dXJuIGxhc3RDaGlsZCB8fCB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXRBZGphY2VudEVsZW1lbnQoZnJvbSwgcHJldikge1xuICBsZXQgY3VyID0gZnJvbTtcbiAgbGV0IGFkamFjZW50ID0gbnVsbDtcbiAgd2hpbGUgKGN1ciAmJiAhYWRqYWNlbnQpIHtcbiAgICBhZGphY2VudCA9IHByZXYgPyBkb20uZ2V0UHJldmlvdXNFbGVtZW50U2libGluZyhjdXIpIDogZG9tLmdldE5leHRFbGVtZW50U2libGluZyhjdXIpO1xuICAgIGN1ciA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGN1cik7XG4gIH1cbiAgcmV0dXJuIGFkamFjZW50IHx8IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGF1Z21lbnRBdHRyaWJ1dGUodGFic3RlciwgZWxlbWVudCwgbmFtZSwgdmFsdWUgLy8gUmVzdG9yZSBvcmlnaW5hbCB2YWx1ZSB3aGVuIHVuZGVmaW5lZC5cbikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICBjb25zdCBlbnRyeSA9IHRhYnN0ZXIuc3RvcmFnZUVudHJ5KGVsZW1lbnQsIHRydWUpO1xuICBsZXQgcmV0ID0gZmFsc2U7XG4gIGlmICghZW50cnkuYXVnKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGVudHJ5LmF1ZyA9IHt9O1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG5hbWUgaW4gZW50cnkuYXVnKSB7XG4gICAgICBjb25zdCBvcmlnVmFsID0gZW50cnkuYXVnW25hbWVdO1xuICAgICAgZGVsZXRlIGVudHJ5LmF1Z1tuYW1lXTtcbiAgICAgIGlmIChvcmlnVmFsID09PSBudWxsKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgb3JpZ1ZhbCk7XG4gICAgICB9XG4gICAgICByZXQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgb3JpZ1ZhbHVlO1xuICAgIGlmICghKG5hbWUgaW4gZW50cnkuYXVnKSkge1xuICAgICAgb3JpZ1ZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuICAgIGlmIChvcmlnVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvcmlnVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICBlbnRyeS5hdWdbbmFtZV0gPSBvcmlnVmFsdWU7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBPYmplY3Qua2V5cyhlbnRyeS5hdWcpLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlbGV0ZSBlbnRyeS5hdWc7XG4gICAgdGFic3Rlci5zdG9yYWdlRW50cnkoZWxlbWVudCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBpc0Rpc3BsYXlOb25lKGVsZW1lbnQpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgZWxlbWVudERvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gKF9hID0gZWxlbWVudERvY3VtZW50LmRlZmF1bHRWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgLy8gb2Zmc2V0UGFyZW50IGlzIG51bGwgZm9yIGVsZW1lbnRzIHdpdGggZGlzcGxheTpub25lLCBkaXNwbGF5OmZpeGVkIGFuZCBmb3IgPGJvZHk+LlxuICBpZiAoZWxlbWVudC5vZmZzZXRQYXJlbnQgPT09IG51bGwgJiYgZWxlbWVudERvY3VtZW50LmJvZHkgIT09IGVsZW1lbnQgJiYgKGNvbXB1dGVkU3R5bGUgPT09IG51bGwgfHwgY29tcHV0ZWRTdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcHV0ZWRTdHlsZS5wb3NpdGlvbikgIT09IFwiZml4ZWRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIEZvciBvdXIgcHVycG9zZXMgb2YgbG9va2luZyBmb3IgZm9jdXNhYmxlIGVsZW1lbnRzLCB2aXNpYmlsaXR5OmhpZGRlbiBoYXMgdGhlIHNhbWVcbiAgLy8gZWZmZWN0IGFzIGRpc3BsYXk6bm9uZS5cbiAgaWYgKChjb21wdXRlZFN0eWxlID09PSBudWxsIHx8IGNvbXB1dGVkU3R5bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXB1dGVkU3R5bGUudmlzaWJpbGl0eSkgPT09IFwiaGlkZGVuXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBpZiBhbiBlbGVtZW50IGhhcyBkaXNwbGF5OiBmaXhlZCwgd2UgbmVlZCB0byBjaGVjayBpZiBpdCBpcyBhbHNvIGhpZGRlbiB3aXRoIENTUyxcbiAgLy8gb3Igd2l0aGluIGEgcGFyZW50IGhpZGRlbiB3aXRoIENTU1xuICBpZiAoKGNvbXB1dGVkU3R5bGUgPT09IG51bGwgfHwgY29tcHV0ZWRTdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcHV0ZWRTdHlsZS5wb3NpdGlvbikgPT09IFwiZml4ZWRcIikge1xuICAgIGlmIChjb21wdXRlZFN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCgoX2IgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vZmZzZXRQYXJlbnQpID09PSBudWxsICYmIGVsZW1lbnREb2N1bWVudC5ib2R5ICE9PSBlbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1JhZGlvKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZSA9PT0gXCJJTlBVVFwiICYmICEhZWxlbWVudC5uYW1lICYmIGVsZW1lbnQudHlwZSA9PT0gXCJyYWRpb1wiO1xufVxuZnVuY3Rpb24gZ2V0UmFkaW9CdXR0b25Hcm91cChlbGVtZW50KSB7XG4gIGlmICghaXNSYWRpbyhlbGVtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuYW1lID0gZWxlbWVudC5uYW1lO1xuICBsZXQgcmFkaW9CdXR0b25zID0gQXJyYXkuZnJvbShkb20uZ2V0RWxlbWVudHNCeU5hbWUoZWxlbWVudCwgbmFtZSkpO1xuICBsZXQgY2hlY2tlZDtcbiAgcmFkaW9CdXR0b25zID0gcmFkaW9CdXR0b25zLmZpbHRlcihlbCA9PiB7XG4gICAgaWYgKGlzUmFkaW8oZWwpKSB7XG4gICAgICBpZiAoZWwuY2hlY2tlZCkge1xuICAgICAgICBjaGVja2VkID0gZWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIGJ1dHRvbnM6IG5ldyBTZXQocmFkaW9CdXR0b25zKSxcbiAgICBjaGVja2VkXG4gIH07XG59XG4vKipcbiAqIElmIHRoZSBwYXNzZWQgZWxlbWVudCBpcyBUYWJzdGVyIGR1bW15IGlucHV0LCByZXR1cm5zIHRoZSBjb250YWluZXIgZWxlbWVudCB0aGlzIGR1bW15IGlucHV0IGJlbG9uZ3MgdG8uXG4gKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHRvIGNoZWNrIGZvciBiZWluZyBkdW1teSBpbnB1dC5cbiAqIEByZXR1cm5zIER1bW15IGlucHV0IGNvbnRhaW5lciBlbGVtZW50IChpZiB0aGUgcGFzc2VkIGVsZW1lbnQgaXMgYSBkdW1teSBpbnB1dCkgb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0RHVtbXlJbnB1dENvbnRhaW5lcihlbGVtZW50KSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuICgoX2EgPSBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQuX190YWJzdGVyRHVtbXlDb250YWluZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKSkgfHwgbnVsbDtcbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VGFic3RlckF0dHJpYnV0ZShwcm9wcywgcGxhaW4pIHtcbiAgY29uc3QgYXR0ciA9IEpTT04uc3RyaW5naWZ5KHByb3BzKTtcbiAgaWYgKHBsYWluID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGF0dHI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBbVEFCU1RFUl9BVFRSSUJVVEVfTkFNRV06IGF0dHJcbiAgfTtcbn1cbi8qKlxuICogVXBkYXRlcyBUYWJzdGVyIHByb3BzIG9iamVjdCB3aXRoIG5ldyBwcm9wcy5cbiAqIEBwYXJhbSBlbGVtZW50IGFuIGVsZW1lbnQgdG8gc2V0IGRhdGEtdGFic3RlciBhdHRyaWJ1dGUgb24uXG4gKiBAcGFyYW0gcHJvcHMgY3VycmVudCBUYWJzdGVyIHByb3BzIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSBuZXdQcm9wcyBuZXcgVGFic3RlciBwcm9wcyB0byBhZGQuXG4gKiAgV2hlbiB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpbiBuZXdQcm9wcyBpcyB1bmRlZmluZWQsIHRoZSBwcm9wZXJ0eVxuICogIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBhdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlVGFic3RlclByb3BzKHByb3BzLCBuZXdQcm9wcykge1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhuZXdQcm9wcykpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG5ld1Byb3BzW2tleV07XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgcHJvcHNba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgcHJvcHNba2V5XTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogU2V0cyBvciB1cGRhdGVzIFRhYnN0ZXIgYXR0cmlidXRlIG9mIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIGVsZW1lbnQgYW4gZWxlbWVudCB0byBzZXQgZGF0YS10YWJzdGVyIGF0dHJpYnV0ZSBvbi5cbiAqIEBwYXJhbSBuZXdQcm9wcyBuZXcgVGFic3RlciBwcm9wcyB0byBzZXQuXG4gKiBAcGFyYW0gdXBkYXRlIGlmIHRydWUsIG5ld1Byb3BzIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGV4aXN0aW5nIHByb3BzLlxuICogIFdoZW4gdHJ1ZSBhbmQgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaW4gbmV3UHJvcHMgaXMgdW5kZWZpbmVkLCB0aGUgcHJvcGVydHlcbiAqICB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgYXR0cmlidXRlLlxuICovXG5mdW5jdGlvbiBzZXRUYWJzdGVyQXR0cmlidXRlKGVsZW1lbnQsIG5ld1Byb3BzLCB1cGRhdGUpIHtcbiAgbGV0IHByb3BzO1xuICBpZiAodXBkYXRlKSB7XG4gICAgY29uc3QgYXR0ciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFRBQlNURVJfQVRUUklCVVRFX05BTUUpO1xuICAgIGlmIChhdHRyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwcm9wcyA9IEpTT04ucGFyc2UoYXR0cik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGRhdGEtdGFic3RlciBhdHRyaWJ1dGUgZXJyb3I6ICR7ZX1gLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIXByb3BzKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBtZXJnZVRhYnN0ZXJQcm9wcyhwcm9wcywgbmV3UHJvcHMpO1xuICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA+IDApIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShUQUJTVEVSX0FUVFJJQlVURV9OQU1FLCBnZXRUYWJzdGVyQXR0cmlidXRlKHByb3BzLCB0cnVlKSk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoVEFCU1RFUl9BVFRSSUJVVEVfTkFNRSk7XG4gIH1cbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gX3NldEluZm9ybWF0aXZlU3R5bGUkMyh3ZWFrRWxlbWVudCwgcmVtb3ZlLCBpZCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gd2Vha0VsZW1lbnQuZ2V0KCk7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcIi0tdGFic3Rlci1yb290XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tdGFic3Rlci1yb290XCIsIGlkICsgXCIsXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY2xhc3MgUm9vdER1bW15TWFuYWdlciBleHRlbmRzIER1bW15SW5wdXRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IodGFic3RlciwgZWxlbWVudCwgc2V0Rm9jdXNlZCwgc3lzKSB7XG4gICAgc3VwZXIodGFic3RlciwgZWxlbWVudCwgRHVtbXlJbnB1dE1hbmFnZXJQcmlvcml0aWVzLlJvb3QsIHN5cywgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB0aGlzLl9vbkR1bW15SW5wdXRGb2N1cyA9IGR1bW15SW5wdXQgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKGR1bW15SW5wdXQudXNlRGVmYXVsdEFjdGlvbikge1xuICAgICAgICAvLyBXaGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIGxhc3QgZm9jdXNhYmxlIGVsZW1lbnQsIHdlIHdhbnQgdG8gbGV0IHRoZSBicm93c2VyXG4gICAgICAgIC8vIHRvIG1vdmUgdGhlIGZvY3VzIG91dHNpZGUgb2YgdGhlIHBhZ2UuIEluIG9yZGVyIHRvIGRvIHRoYXQgd2UncmUgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBjYWxsaW5nIGZvY3VzKCkgb2YgdGhlIGR1bW15IGlucHV0IGZyb20gdGhlIFRhYiBrZXkgaGFuZGxlciBhbmQgYWxsb3dpbmdcbiAgICAgICAgLy8gdGhlIGRlZmF1bHQgYWN0aW9uIHRvIG1vdmUgdGhlIGZvY3VzIG91dC5cbiAgICAgICAgdGhpcy5fc2V0Rm9jdXNlZChmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgb25seSB3YXkgYSBkdW1teSBpbnB1dCBnZXRzIGZvY3VzZWQgaXMgZHVyaW5nIHRoZSBrZXlib2FyZCBuYXZpZ2F0aW9uLlxuICAgICAgICB0aGlzLl90YWJzdGVyLmtleWJvYXJkTmF2aWdhdGlvbi5zZXROYXZpZ2F0aW5nV2l0aEtleWJvYXJkKHRydWUpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZWxlbWVudC5nZXQoKTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLl9zZXRGb2N1c2VkKHRydWUpO1xuICAgICAgICAgIGNvbnN0IHRvRm9jdXMgPSB0aGlzLl90YWJzdGVyLmZvY3VzZWRFbGVtZW50LmdldEZpcnN0T3JMYXN0VGFiYmFibGUoZHVtbXlJbnB1dC5pc0ZpcnN0LCB7XG4gICAgICAgICAgICBjb250YWluZXI6IGVsZW1lbnQsXG4gICAgICAgICAgICBpZ25vcmVBY2Nlc3NpYmlsaXR5OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHRvRm9jdXMpIHtcbiAgICAgICAgICAgIG5hdGl2ZUZvY3VzKHRvRm9jdXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoX2EgPSBkdW1teUlucHV0LmlucHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmx1cigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fc2V0SGFuZGxlcnModGhpcy5fb25EdW1teUlucHV0Rm9jdXMpO1xuICAgIHRoaXMuX3RhYnN0ZXIgPSB0YWJzdGVyO1xuICAgIHRoaXMuX3NldEZvY3VzZWQgPSBzZXRGb2N1c2VkO1xuICB9XG59XG5jbGFzcyBSb290IGV4dGVuZHMgVGFic3RlclBhcnQge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyLCBlbGVtZW50LCBvbkRpc3Bvc2UsIHByb3BzLCBzeXMpIHtcbiAgICBzdXBlcih0YWJzdGVyLCBlbGVtZW50LCBwcm9wcyk7XG4gICAgdGhpcy5faXNGb2N1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fc2V0Rm9jdXNlZCA9IGhhc0ZvY3VzZWQgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHRoaXMuX3NldEZvY3VzZWRUaW1lcikge1xuICAgICAgICB0aGlzLl90YWJzdGVyLmdldFdpbmRvdygpLmNsZWFyVGltZW91dCh0aGlzLl9zZXRGb2N1c2VkVGltZXIpO1xuICAgICAgICBkZWxldGUgdGhpcy5fc2V0Rm9jdXNlZFRpbWVyO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzRm9jdXNlZCA9PT0gaGFzRm9jdXNlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZWxlbWVudC5nZXQoKTtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGlmIChoYXNGb2N1c2VkKSB7XG4gICAgICAgICAgdGhpcy5faXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAoX2EgPSB0aGlzLl9kdW1teU1hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRUYWJiYWJsZShmYWxzZSk7XG4gICAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBSb290Rm9jdXNFdmVudCh7XG4gICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldEZvY3VzZWRUaW1lciA9IHRoaXMuX3RhYnN0ZXIuZ2V0V2luZG93KCkuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc2V0Rm9jdXNlZFRpbWVyO1xuICAgICAgICAgICAgdGhpcy5faXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLl9kdW1teU1hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRUYWJiYWJsZSh0cnVlKTtcbiAgICAgICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgUm9vdEJsdXJFdmVudCh7XG4gICAgICAgICAgICAgIGVsZW1lbnRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25Gb2N1c0luID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZ2V0UGFyZW50ID0gdGhpcy5fdGFic3Rlci5nZXRQYXJlbnQ7XG4gICAgICBjb25zdCByb290RWxlbWVudCA9IHRoaXMuX2VsZW1lbnQuZ2V0KCk7XG4gICAgICBsZXQgY3VyRWxlbWVudCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoY3VyRWxlbWVudCA9PT0gcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLl9zZXRGb2N1c2VkKHRydWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdXJFbGVtZW50ID0gY3VyRWxlbWVudCAmJiBnZXRQYXJlbnQoY3VyRWxlbWVudCk7XG4gICAgICB9IHdoaWxlIChjdXJFbGVtZW50KTtcbiAgICB9O1xuICAgIHRoaXMuX29uRm9jdXNPdXQgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9zZXRGb2N1c2VkKGZhbHNlKTtcbiAgICB9O1xuICAgIHRoaXMuX29uRGlzcG9zZSA9IG9uRGlzcG9zZTtcbiAgICBjb25zdCB3aW4gPSB0YWJzdGVyLmdldFdpbmRvdztcbiAgICB0aGlzLnVpZCA9IGdldEVsZW1lbnRVSWQod2luLCBlbGVtZW50KTtcbiAgICB0aGlzLl9zeXMgPSBzeXM7XG4gICAgaWYgKHRhYnN0ZXIuY29udHJvbFRhYiB8fCB0YWJzdGVyLnJvb3REdW1teUlucHV0cykge1xuICAgICAgdGhpcy5hZGREdW1teUlucHV0cygpO1xuICAgIH1cbiAgICBjb25zdCB3ID0gd2luKCk7XG4gICAgY29uc3QgZG9jID0gdy5kb2N1bWVudDtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihLRVlCT1JHX0ZPQ1VTSU4sIHRoaXMuX29uRm9jdXNJbik7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoS0VZQk9SR19GT0NVU09VVCwgdGhpcy5fb25Gb2N1c091dCk7XG4gICAgdGhpcy5fYWRkKCk7XG4gIH1cbiAgYWRkRHVtbXlJbnB1dHMoKSB7XG4gICAgaWYgKCF0aGlzLl9kdW1teU1hbmFnZXIpIHtcbiAgICAgIHRoaXMuX2R1bW15TWFuYWdlciA9IG5ldyBSb290RHVtbXlNYW5hZ2VyKHRoaXMuX3RhYnN0ZXIsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX3NldEZvY3VzZWQsIHRoaXMuX3N5cyk7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuX29uRGlzcG9zZSh0aGlzKTtcbiAgICBjb25zdCB3aW4gPSB0aGlzLl90YWJzdGVyLmdldFdpbmRvdygpO1xuICAgIGNvbnN0IGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihLRVlCT1JHX0ZPQ1VTSU4sIHRoaXMuX29uRm9jdXNJbik7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoS0VZQk9SR19GT0NVU09VVCwgdGhpcy5fb25Gb2N1c091dCk7XG4gICAgaWYgKHRoaXMuX3NldEZvY3VzZWRUaW1lcikge1xuICAgICAgd2luLmNsZWFyVGltZW91dCh0aGlzLl9zZXRGb2N1c2VkVGltZXIpO1xuICAgICAgZGVsZXRlIHRoaXMuX3NldEZvY3VzZWRUaW1lcjtcbiAgICB9XG4gICAgKF9hID0gdGhpcy5fZHVtbXlNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xuICAgIHRoaXMuX3JlbW92ZSgpO1xuICB9XG4gIG1vdmVPdXRXaXRoRGVmYXVsdEFjdGlvbihpc0JhY2t3YXJkLCByZWxhdGVkRXZlbnQpIHtcbiAgICBjb25zdCBkdW1teU1hbmFnZXIgPSB0aGlzLl9kdW1teU1hbmFnZXI7XG4gICAgaWYgKGR1bW15TWFuYWdlcikge1xuICAgICAgZHVtbXlNYW5hZ2VyLm1vdmVPdXRXaXRoRGVmYXVsdEFjdGlvbihpc0JhY2t3YXJkLCByZWxhdGVkRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIFJvb3REdW1teU1hbmFnZXIubW92ZVdpdGhQaGFudG9tRHVtbXkodGhpcy5fdGFic3RlciwgZWwsIHRydWUsIGlzQmFja3dhcmQsIHJlbGF0ZWRFdmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9hZGQoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBfc2V0SW5mb3JtYXRpdmVTdHlsZSQzKHRoaXMuX2VsZW1lbnQsIGZhbHNlLCB0aGlzLnVpZCk7XG4gICAgfVxuICB9XG4gIF9yZW1vdmUoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBfc2V0SW5mb3JtYXRpdmVTdHlsZSQzKHRoaXMuX2VsZW1lbnQsIHRydWUpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUm9vdEFQSSB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIsIGF1dG9Sb290KSB7XG4gICAgdGhpcy5fYXV0b1Jvb3RXYWl0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcm9vdHMgPSB7fTtcbiAgICB0aGlzLl9mb3JjZUR1bW15ID0gZmFsc2U7XG4gICAgdGhpcy5yb290QnlJZCA9IHt9O1xuICAgIHRoaXMuX2F1dG9Sb290Q3JlYXRlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZG9jID0gdGhpcy5fd2luKCkuZG9jdW1lbnQ7XG4gICAgICBjb25zdCBib2R5ID0gZG9jLmJvZHk7XG4gICAgICBpZiAoYm9keSkge1xuICAgICAgICB0aGlzLl9hdXRvUm9vdFVud2FpdChkb2MpO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuX2F1dG9Sb290O1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBzZXRUYWJzdGVyQXR0cmlidXRlKGJvZHksIHtcbiAgICAgICAgICAgIHJvb3Q6IHByb3BzXG4gICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgdXBkYXRlVGFic3RlckJ5QXR0cmlidXRlKHRoaXMuX3RhYnN0ZXIsIGJvZHkpO1xuICAgICAgICAgIHJldHVybiAoX2EgPSBnZXRUYWJzdGVyT25FbGVtZW50KHRoaXMuX3RhYnN0ZXIsIGJvZHkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eucm9vdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdGhpcy5fYXV0b1Jvb3RXYWl0aW5nKSB7XG4gICAgICAgIHRoaXMuX2F1dG9Sb290V2FpdGluZyA9IHRydWU7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCB0aGlzLl9hdXRvUm9vdENyZWF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgdGhpcy5fb25Sb290RGlzcG9zZSA9IHJvb3QgPT4ge1xuICAgICAgZGVsZXRlIHRoaXMuX3Jvb3RzW3Jvb3QuaWRdO1xuICAgIH07XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gICAgdGhpcy5fd2luID0gdGFic3Rlci5nZXRXaW5kb3c7XG4gICAgdGhpcy5fYXV0b1Jvb3QgPSBhdXRvUm9vdDtcbiAgICB0YWJzdGVyLnF1ZXVlSW5pdCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fYXV0b1Jvb3QpIHtcbiAgICAgICAgdGhpcy5fYXV0b1Jvb3RDcmVhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfYXV0b1Jvb3RVbndhaXQoZG9jKSB7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsIHRoaXMuX2F1dG9Sb290Q3JlYXRlKTtcbiAgICB0aGlzLl9hdXRvUm9vdFdhaXRpbmcgPSBmYWxzZTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgIHRoaXMuX2F1dG9Sb290VW53YWl0KHdpbi5kb2N1bWVudCk7XG4gICAgZGVsZXRlIHRoaXMuX2F1dG9Sb290O1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3Jvb3RzKS5mb3JFYWNoKHJvb3RJZCA9PiB7XG4gICAgICBpZiAodGhpcy5fcm9vdHNbcm9vdElkXSkge1xuICAgICAgICB0aGlzLl9yb290c1tyb290SWRdLmRpc3Bvc2UoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Jvb3RzW3Jvb3RJZF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5yb290QnlJZCA9IHt9O1xuICB9XG4gIGNyZWF0ZVJvb3QoZWxlbWVudCwgcHJvcHMsIHN5cykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JykgO1xuICAgIGNvbnN0IG5ld1Jvb3QgPSBuZXcgUm9vdCh0aGlzLl90YWJzdGVyLCBlbGVtZW50LCB0aGlzLl9vblJvb3REaXNwb3NlLCBwcm9wcywgc3lzKTtcbiAgICB0aGlzLl9yb290c1tuZXdSb290LmlkXSA9IG5ld1Jvb3Q7XG4gICAgaWYgKHRoaXMuX2ZvcmNlRHVtbXkpIHtcbiAgICAgIG5ld1Jvb3QuYWRkRHVtbXlJbnB1dHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1Jvb3Q7XG4gIH1cbiAgYWRkRHVtbXlJbnB1dHMoKSB7XG4gICAgdGhpcy5fZm9yY2VEdW1teSA9IHRydWU7XG4gICAgY29uc3Qgcm9vdHMgPSB0aGlzLl9yb290cztcbiAgICBmb3IgKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKHJvb3RzKSkge1xuICAgICAgcm9vdHNbaWRdLmFkZER1bW15SW5wdXRzKCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXRSb290QnlVSWQoZ2V0V2luZG93LCBpZCkge1xuICAgIGNvbnN0IHRhYnN0ZXIgPSBnZXRXaW5kb3coKS5fX3RhYnN0ZXJJbnN0YW5jZTtcbiAgICByZXR1cm4gdGFic3RlciAmJiB0YWJzdGVyLnJvb3Qucm9vdEJ5SWRbaWRdO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaGVzIHRoZSB0YWJzdGVyIGNvbnRleHQgZm9yIGFuIGVsZW1lbnQgd2Fsa2luZyB1cCBpdHMgYW5jZXN0b3JzXG4gICAqXG4gICAqIEBwYXJhbSB0YWJzdGVyIFRhYnN0ZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdGhlIHRhYnN0ZXIgY29udGV4dCBzaG91bGQgcmVwcmVzZW50XG4gICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIGVsZW1lbnQgaXMgbm90IGEgY2hpbGQgb2YgYSB0YWJzdGVyIHJvb3QsIG90aGVyd2lzZSBhbGwgYXBwbGljYWJsZSB0YWJzdGVyIGJlaGF2aW91cnMgYW5kIGNvbmZpZ3VyYXRpb25zXG4gICAqL1xuICBzdGF0aWMgZ2V0VGFic3RlckNvbnRleHQodGFic3RlciwgZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGlmICghZWxlbWVudC5vd25lckRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjaGVja1J0bCxcbiAgICAgIHJlZmVyZW5jZUVsZW1lbnRcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBnZXRQYXJlbnQgPSB0YWJzdGVyLmdldFBhcmVudDtcbiAgICAvLyBOb3JtYWxseSwgdGhlIGluaXRpYWxpemF0aW9uIHN0YXJ0cyBvbiB0aGUgbmV4dCB0aWNrIGFmdGVyIHRoZSB0YWJzdGVyXG4gICAgLy8gaW5zdGFuY2UgY3JlYXRpb24uIEhvd2V2ZXIsIGlmIHRoZSBhcHBsaWNhdGlvbiBzdGFydHMgdXNpbmcgaXQgYmVmb3JlXG4gICAgLy8gdGhlIG5leHQgdGljaywgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIGluaXRpYWxpemF0aW9uIGlzIGRvbmUuXG4gICAgdGFic3Rlci5kcmFpbkluaXRRdWV1ZSgpO1xuICAgIGxldCByb290O1xuICAgIGxldCBtb2RhbGl6ZXI7XG4gICAgbGV0IGdyb3VwcGVyO1xuICAgIGxldCBtb3ZlcjtcbiAgICBsZXQgZXhjbHVkZWRGcm9tTW92ZXIgPSBmYWxzZTtcbiAgICBsZXQgZ3JvdXBwZXJCZWZvcmVNb3ZlcjtcbiAgICBsZXQgbW9kYWxpemVySW5Hcm91cHBlcjtcbiAgICBsZXQgZGlyUmlnaHRUb0xlZnQ7XG4gICAgbGV0IHVuY29udHJvbGxlZDtcbiAgICBsZXQgY3VyRWxlbWVudCA9IHJlZmVyZW5jZUVsZW1lbnQgfHwgZWxlbWVudDtcbiAgICBjb25zdCBpZ25vcmVLZXlkb3duID0ge307XG4gICAgd2hpbGUgKGN1ckVsZW1lbnQgJiYgKCFyb290IHx8IGNoZWNrUnRsKSkge1xuICAgICAgY29uc3QgdGFic3Rlck9uRWxlbWVudCA9IGdldFRhYnN0ZXJPbkVsZW1lbnQodGFic3RlciwgY3VyRWxlbWVudCk7XG4gICAgICBpZiAoY2hlY2tSdGwgJiYgZGlyUmlnaHRUb0xlZnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBkaXIgPSBjdXJFbGVtZW50LmRpcjtcbiAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgIGRpclJpZ2h0VG9MZWZ0ID0gZGlyLnRvTG93ZXJDYXNlKCkgPT09IFwicnRsXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGFic3Rlck9uRWxlbWVudCkge1xuICAgICAgICBjdXJFbGVtZW50ID0gZ2V0UGFyZW50KGN1ckVsZW1lbnQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhZ05hbWUgPSBjdXJFbGVtZW50LnRhZ05hbWU7XG4gICAgICBpZiAoKHRhYnN0ZXJPbkVsZW1lbnQudW5jb250cm9sbGVkIHx8IHRhZ05hbWUgPT09IFwiSUZSQU1FXCIgfHwgdGFnTmFtZSA9PT0gXCJXRUJWSUVXXCIpICYmIHRhYnN0ZXIuZm9jdXNhYmxlLmlzVmlzaWJsZShjdXJFbGVtZW50KSkge1xuICAgICAgICB1bmNvbnRyb2xsZWQgPSBjdXJFbGVtZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFtb3ZlciAmJiAoKF9hID0gdGFic3Rlck9uRWxlbWVudC5mb2N1c2FibGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5leGNsdWRlRnJvbU1vdmVyKSAmJiAhZ3JvdXBwZXIpIHtcbiAgICAgICAgZXhjbHVkZWRGcm9tTW92ZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VyTW9kYWxpemVyID0gdGFic3Rlck9uRWxlbWVudC5tb2RhbGl6ZXI7XG4gICAgICBjb25zdCBjdXJHcm91cHBlciA9IHRhYnN0ZXJPbkVsZW1lbnQuZ3JvdXBwZXI7XG4gICAgICBjb25zdCBjdXJNb3ZlciA9IHRhYnN0ZXJPbkVsZW1lbnQubW92ZXI7XG4gICAgICBpZiAoIW1vZGFsaXplciAmJiBjdXJNb2RhbGl6ZXIpIHtcbiAgICAgICAgbW9kYWxpemVyID0gY3VyTW9kYWxpemVyO1xuICAgICAgfVxuICAgICAgaWYgKCFncm91cHBlciAmJiBjdXJHcm91cHBlciAmJiAoIW1vZGFsaXplciB8fCBjdXJNb2RhbGl6ZXIpKSB7XG4gICAgICAgIGlmIChtb2RhbGl6ZXIpIHtcbiAgICAgICAgICAvLyBNb2RhbGl6ZXIgZG9taW5hdGVzIHRoZSBncm91cHBlciB3aGVuIHRoZXkgYXJlIG9uIHRoZSBzYW1lIG5vZGUgYW5kIHRoZSBncm91cHBlciBpcyBhY3RpdmUuXG4gICAgICAgICAgaWYgKCFjdXJHcm91cHBlci5pc0FjdGl2ZSgpICYmIGN1ckdyb3VwcGVyLmdldFByb3BzKCkudGFiYmFiaWxpdHkgJiYgbW9kYWxpemVyLnVzZXJJZCAhPT0gKChfYiA9IHRhYnN0ZXIubW9kYWxpemVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWN0aXZlSWQpKSB7XG4gICAgICAgICAgICBtb2RhbGl6ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBncm91cHBlciA9IGN1ckdyb3VwcGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RhbGl6ZXJJbkdyb3VwcGVyID0gY3VyR3JvdXBwZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JvdXBwZXIgPSBjdXJHcm91cHBlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFtb3ZlciAmJiBjdXJNb3ZlciAmJiAoIW1vZGFsaXplciB8fCBjdXJNb2RhbGl6ZXIpICYmICghY3VyR3JvdXBwZXIgfHwgY3VyRWxlbWVudCAhPT0gZWxlbWVudCkgJiYgY3VyRWxlbWVudC5jb250YWlucyhlbGVtZW50KSAvLyBNb3ZlciBtYWtlcyBzZW5zZSBvbmx5IGZvciByZWFsbHkgaW5zaWRlIGVsZW1lbnRzLCBub3QgZm9yIHZpcnV0YWwgb3V0IG9mIHRoZSBET00gb3JkZXIgY2hpbGRyZW4uXG4gICAgICApIHtcbiAgICAgICAgbW92ZXIgPSBjdXJNb3ZlcjtcbiAgICAgICAgZ3JvdXBwZXJCZWZvcmVNb3ZlciA9ICEhZ3JvdXBwZXIgJiYgZ3JvdXBwZXIgIT09IGN1ckdyb3VwcGVyO1xuICAgICAgfVxuICAgICAgaWYgKHRhYnN0ZXJPbkVsZW1lbnQucm9vdCkge1xuICAgICAgICByb290ID0gdGFic3Rlck9uRWxlbWVudC5yb290O1xuICAgICAgfVxuICAgICAgaWYgKChfYyA9IHRhYnN0ZXJPbkVsZW1lbnQuZm9jdXNhYmxlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaWdub3JlS2V5ZG93bikge1xuICAgICAgICBPYmplY3QuYXNzaWduKGlnbm9yZUtleWRvd24sIHRhYnN0ZXJPbkVsZW1lbnQuZm9jdXNhYmxlLmlnbm9yZUtleWRvd24pO1xuICAgICAgfVxuICAgICAgY3VyRWxlbWVudCA9IGdldFBhcmVudChjdXJFbGVtZW50KTtcbiAgICB9XG4gICAgLy8gTm8gcm9vdCBlbGVtZW50IGNvdWxkIGJlIGZvdW5kLCB0cnkgdG8gZ2V0IGFuIGF1dG8gcm9vdFxuICAgIGlmICghcm9vdCkge1xuICAgICAgY29uc3Qgcm9vdEFQSSA9IHRhYnN0ZXIucm9vdDtcbiAgICAgIGNvbnN0IGF1dG9Sb290ID0gcm9vdEFQSS5fYXV0b1Jvb3Q7XG4gICAgICBpZiAoYXV0b1Jvb3QpIHtcbiAgICAgICAgaWYgKChfZCA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmJvZHkpIHtcbiAgICAgICAgICByb290ID0gcm9vdEFQSS5fYXV0b1Jvb3RDcmVhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ3JvdXBwZXIgJiYgIW1vdmVyKSB7XG4gICAgICBncm91cHBlckJlZm9yZU1vdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICFyb290KSB7XG4gICAgICBpZiAobW9kYWxpemVyIHx8IGdyb3VwcGVyIHx8IG1vdmVyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUYWJzdGVyIFJvb3QgaXMgcmVxdWlyZWQgZm9yIE1vdmVyLCBHcm91cHBlciBhbmQgTW9kYWxpemVyIHRvIHdvcmsuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzaG91bGRJZ25vcmVLZXlkb3duID0gZXZlbnQgPT4gISFpZ25vcmVLZXlkb3duW2V2ZW50LmtleV07XG4gICAgcmV0dXJuIHJvb3QgPyB7XG4gICAgICByb290LFxuICAgICAgbW9kYWxpemVyLFxuICAgICAgZ3JvdXBwZXIsXG4gICAgICBtb3ZlcixcbiAgICAgIGdyb3VwcGVyQmVmb3JlTW92ZXIsXG4gICAgICBtb2RhbGl6ZXJJbkdyb3VwcGVyLFxuICAgICAgcnRsOiBjaGVja1J0bCA/ICEhZGlyUmlnaHRUb0xlZnQgOiB1bmRlZmluZWQsXG4gICAgICB1bmNvbnRyb2xsZWQsXG4gICAgICBleGNsdWRlZEZyb21Nb3ZlcixcbiAgICAgIGlnbm9yZUtleWRvd246IHNob3VsZElnbm9yZUtleWRvd25cbiAgICB9IDogdW5kZWZpbmVkO1xuICB9XG4gIHN0YXRpYyBnZXRSb290KHRhYnN0ZXIsIGVsZW1lbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZ2V0UGFyZW50ID0gdGFic3Rlci5nZXRQYXJlbnQ7XG4gICAgZm9yIChsZXQgZWwgPSBlbGVtZW50OyBlbDsgZWwgPSBnZXRQYXJlbnQoZWwpKSB7XG4gICAgICBjb25zdCByb290ID0gKF9hID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0YWJzdGVyLCBlbCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yb290O1xuICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgb25Sb290KHJvb3QsIHJlbW92ZWQpIHtcbiAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgZGVsZXRlIHRoaXMucm9vdEJ5SWRbcm9vdC51aWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJvb3RCeUlkW3Jvb3QudWlkXSA9IHJvb3Q7XG4gICAgfVxuICB9XG59XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmNvbnN0IF9jb250YWluZXJIaXN0b3J5TGVuZ3RoID0gMTA7XG5jbGFzcyBEZWxvc2VySXRlbUJhc2Uge31cbmNsYXNzIERlbG9zZXJJdGVtIGV4dGVuZHMgRGVsb3Nlckl0ZW1CYXNlIHtcbiAgY29uc3RydWN0b3IodGFic3RlciwgZGVsb3Nlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy51aWQgPSBkZWxvc2VyLnVpZDtcbiAgICB0aGlzLl90YWJzdGVyID0gdGFic3RlcjtcbiAgICB0aGlzLl9kZWxvc2VyID0gZGVsb3NlcjtcbiAgfVxuICBiZWxvbmdzVG8oZGVsb3Nlcikge1xuICAgIHJldHVybiBkZWxvc2VyID09PSB0aGlzLl9kZWxvc2VyO1xuICB9XG4gIHVuc2hpZnQoZWxlbWVudCkge1xuICAgIHRoaXMuX2RlbG9zZXIudW5zaGlmdChlbGVtZW50KTtcbiAgfVxuICBhc3luYyBmb2N1c0F2YWlsYWJsZSgpIHtcbiAgICBjb25zdCBhdmFpbGFibGUgPSB0aGlzLl9kZWxvc2VyLmZpbmRBdmFpbGFibGUoKTtcbiAgICBjb25zdCBkZWxvc2VyRWxlbWVudCA9IHRoaXMuX2RlbG9zZXIuZ2V0RWxlbWVudCgpO1xuICAgIGlmIChhdmFpbGFibGUgJiYgZGVsb3NlckVsZW1lbnQpIHtcbiAgICAgIGlmICghZGVsb3NlckVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgVGFic3Rlck1vdmVGb2N1c0V2ZW50KHtcbiAgICAgICAgYnk6IFwiZGVsb3NlclwiLFxuICAgICAgICBvd25lcjogZGVsb3NlckVsZW1lbnQsXG4gICAgICAgIG5leHQ6IGF2YWlsYWJsZVxuICAgICAgfSkpKSB7XG4gICAgICAgIC8vIERlZmF1bHQgYWN0aW9uIGlzIHByZXZlbnRlZCwgZG9uJ3QgbG9vayBmdXJ0aGVyLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl90YWJzdGVyLmZvY3VzZWRFbGVtZW50LmZvY3VzKGF2YWlsYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyByZXNldEZvY3VzKCkge1xuICAgIGNvbnN0IGdldFdpbmRvdyA9IHRoaXMuX3RhYnN0ZXIuZ2V0V2luZG93O1xuICAgIHJldHVybiBnZXRQcm9taXNlKGdldFdpbmRvdykucmVzb2x2ZSh0aGlzLl9kZWxvc2VyLnJlc2V0Rm9jdXMoKSk7XG4gIH1cbn1cbmNsYXNzIERlbG9zZXJIaXN0b3J5QnlSb290QmFzZSB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIsIHJvb3RVSWQpIHtcbiAgICB0aGlzLl9oaXN0b3J5ID0gW107XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gICAgdGhpcy5yb290VUlkID0gcm9vdFVJZDtcbiAgfVxuICBnZXRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hpc3RvcnkubGVuZ3RoO1xuICB9XG4gIHJlbW92ZURlbG9zZXIoZGVsb3Nlcikge1xuICAgIHRoaXMuX2hpc3RvcnkgPSB0aGlzLl9oaXN0b3J5LmZpbHRlcihjID0+ICFjLmJlbG9uZ3NUbyhkZWxvc2VyKSk7XG4gIH1cbiAgaGFzRGVsb3NlcihkZWxvc2VyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hpc3Rvcnkuc29tZShkID0+IGQuYmVsb25nc1RvKGRlbG9zZXIpKTtcbiAgfVxufVxuY2xhc3MgRGVsb3Nlckhpc3RvcnlCeVJvb3QgZXh0ZW5kcyBEZWxvc2VySGlzdG9yeUJ5Um9vdEJhc2Uge1xuICB1bnNoaWZ0VG9EZWxvc2VyKGRlbG9zZXIsIGVsZW1lbnQpIHtcbiAgICBsZXQgaXRlbTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2hpc3RvcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLl9oaXN0b3J5W2ldLmJlbG9uZ3NUbyhkZWxvc2VyKSkge1xuICAgICAgICBpdGVtID0gdGhpcy5faGlzdG9yeVtpXTtcbiAgICAgICAgdGhpcy5faGlzdG9yeS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIGl0ZW0gPSBuZXcgRGVsb3Nlckl0ZW0odGhpcy5fdGFic3RlciwgZGVsb3Nlcik7XG4gICAgfVxuICAgIGl0ZW0udW5zaGlmdChlbGVtZW50KTtcbiAgICB0aGlzLl9oaXN0b3J5LnVuc2hpZnQoaXRlbSk7XG4gICAgdGhpcy5faGlzdG9yeS5zcGxpY2UoX2NvbnRhaW5lckhpc3RvcnlMZW5ndGgsIHRoaXMuX2hpc3RvcnkubGVuZ3RoIC0gX2NvbnRhaW5lckhpc3RvcnlMZW5ndGgpO1xuICB9XG4gIGFzeW5jIGZvY3VzQXZhaWxhYmxlKGZyb20pIHtcbiAgICBsZXQgc2tpcCA9ICEhZnJvbTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5faGlzdG9yeSkge1xuICAgICAgaWYgKGZyb20gJiYgaS5iZWxvbmdzVG8oZnJvbSkpIHtcbiAgICAgICAgc2tpcCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFza2lwKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGkuZm9jdXNBdmFpbGFibGUoKTtcbiAgICAgICAgLy8gUmVzdWx0IGlzIG51bGwgd2hlbiB0aGUgZGVmYXVsdCBhY3Rpb24gaXMgcHJldmVudGVkIGJ5IHRoZSBhcHBsaWNhdGlvblxuICAgICAgICAvLyBhbmQgd2UgZG9uJ3QgbmVlZCB0byBsb29rIGZ1cnRoZXIuXG4gICAgICAgIGlmIChyZXN1bHQgfHwgcmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcmVzZXRGb2N1cyhmcm9tKSB7XG4gICAgbGV0IHNraXAgPSAhIWZyb207XG4gICAgY29uc3QgcmVzZXRRdWV1ZSA9IHt9O1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLl9oaXN0b3J5KSB7XG4gICAgICBpZiAoZnJvbSAmJiBpLmJlbG9uZ3NUbyhmcm9tKSkge1xuICAgICAgICBza2lwID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXNraXAgJiYgIXJlc2V0UXVldWVbaS51aWRdKSB7XG4gICAgICAgIHJlc2V0UXVldWVbaS51aWRdID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm90aGluZyBpcyBmb3VuZCwgYXQgbGVhc3QgdHJ5IHRvIHJlc2V0LlxuICAgIGZvciAoY29uc3QgaWQgb2YgT2JqZWN0LmtleXMocmVzZXRRdWV1ZSkpIHtcbiAgICAgIGlmIChhd2FpdCByZXNldFF1ZXVlW2lkXS5yZXNldEZvY3VzKCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuY2xhc3MgRGVsb3Nlckhpc3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyKSB7XG4gICAgdGhpcy5faGlzdG9yeSA9IFtdO1xuICAgIHRoaXMuX3RhYnN0ZXIgPSB0YWJzdGVyO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5faGlzdG9yeSA9IFtdO1xuICB9XG4gIHByb2Nlc3MoZWxlbWVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBjdHggPSBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRoaXMuX3RhYnN0ZXIsIGVsZW1lbnQpO1xuICAgIGNvbnN0IHJvb3RVSWQgPSBjdHggJiYgY3R4LnJvb3QudWlkO1xuICAgIGNvbnN0IGRlbG9zZXIgPSBEZWxvc2VyQVBJLmdldERlbG9zZXIodGhpcy5fdGFic3RlciwgZWxlbWVudCk7XG4gICAgaWYgKCFyb290VUlkIHx8ICFkZWxvc2VyKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5QnlSb290ID0gdGhpcy5tYWtlKHJvb3RVSWQsICgpID0+IG5ldyBEZWxvc2VySGlzdG9yeUJ5Um9vdCh0aGlzLl90YWJzdGVyLCByb290VUlkKSk7XG4gICAgaWYgKCFjdHggfHwgIWN0eC5tb2RhbGl6ZXIgfHwgKChfYSA9IGN0eC5tb2RhbGl6ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0FjdGl2ZSgpKSkge1xuICAgICAgaGlzdG9yeUJ5Um9vdC51bnNoaWZ0VG9EZWxvc2VyKGRlbG9zZXIsIGVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZGVsb3NlcjtcbiAgfVxuICBtYWtlKHJvb3RVSWQsIGNyZWF0ZUluc3RhbmNlKSB7XG4gICAgbGV0IGhpc3RvcnlCeVJvb3Q7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9oaXN0b3J5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBoYnIgPSB0aGlzLl9oaXN0b3J5W2ldO1xuICAgICAgaWYgKGhici5yb290VUlkID09PSByb290VUlkKSB7XG4gICAgICAgIGhpc3RvcnlCeVJvb3QgPSBoYnI7XG4gICAgICAgIHRoaXMuX2hpc3Rvcnkuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFoaXN0b3J5QnlSb290KSB7XG4gICAgICBoaXN0b3J5QnlSb290ID0gY3JlYXRlSW5zdGFuY2UoKTtcbiAgICB9XG4gICAgdGhpcy5faGlzdG9yeS51bnNoaWZ0KGhpc3RvcnlCeVJvb3QpO1xuICAgIHRoaXMuX2hpc3Rvcnkuc3BsaWNlKF9jb250YWluZXJIaXN0b3J5TGVuZ3RoLCB0aGlzLl9oaXN0b3J5Lmxlbmd0aCAtIF9jb250YWluZXJIaXN0b3J5TGVuZ3RoKTtcbiAgICByZXR1cm4gaGlzdG9yeUJ5Um9vdDtcbiAgfVxuICByZW1vdmVEZWxvc2VyKGRlbG9zZXIpIHtcbiAgICB0aGlzLl9oaXN0b3J5LmZvckVhY2goaSA9PiB7XG4gICAgICBpLnJlbW92ZURlbG9zZXIoZGVsb3Nlcik7XG4gICAgfSk7XG4gICAgdGhpcy5faGlzdG9yeSA9IHRoaXMuX2hpc3RvcnkuZmlsdGVyKGkgPT4gaS5nZXRMZW5ndGgoKSA+IDApO1xuICB9XG4gIGFzeW5jIGZvY3VzQXZhaWxhYmxlKGZyb20pIHtcbiAgICBsZXQgc2tpcCA9ICEhZnJvbTtcbiAgICBmb3IgKGNvbnN0IGggb2YgdGhpcy5faGlzdG9yeSkge1xuICAgICAgaWYgKGZyb20gJiYgaC5oYXNEZWxvc2VyKGZyb20pKSB7XG4gICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghc2tpcCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoLmZvY3VzQXZhaWxhYmxlKGZyb20pO1xuICAgICAgICAvLyBSZXN1bHQgaXMgbnVsbCB3aGVuIHRoZSBkZWZhdWx0IGFjdGlvbiBpcyBwcmV2ZW50ZWQgYnkgdGhlIGFwcGxpY2F0aW9uXG4gICAgICAgIC8vIGFuZCB3ZSBkb24ndCBuZWVkIHRvIGxvb2sgZnVydGhlci5cbiAgICAgICAgaWYgKHJlc3VsdCB8fCByZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyByZXNldEZvY3VzKGZyb20pIHtcbiAgICBsZXQgc2tpcCA9ICEhZnJvbTtcbiAgICBmb3IgKGNvbnN0IGggb2YgdGhpcy5faGlzdG9yeSkge1xuICAgICAgaWYgKGZyb20gJiYgaC5oYXNEZWxvc2VyKGZyb20pKSB7XG4gICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghc2tpcCAmJiAoYXdhaXQgaC5yZXNldEZvY3VzKGZyb20pKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBfc2V0SW5mb3JtYXRpdmVTdHlsZSQyKHdlYWtFbGVtZW50LCByZW1vdmUsIGlzQWN0aXZlLCBzbmFwc2hvdEluZGV4KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB3ZWFrRWxlbWVudC5nZXQoKTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiLS10YWJzdGVyLWRlbG9zZXJcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS10YWJzdGVyLWRlbG9zZXJcIiwgKGlzQWN0aXZlID8gXCJhY3RpdmVcIiA6IFwiaW5hY3RpdmVcIikgKyBcIixcIiArIChcInNuYXBzaG90LVwiICsgc25hcHNob3RJbmRleCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYnVpbGRFbGVtZW50U2VsZWN0b3IoZWxlbWVudCwgd2l0aENsYXNzLCB3aXRoSW5kZXgpIHtcbiAgY29uc3Qgc2VsZWN0b3IgPSBbXTtcbiAgY29uc3QgZXNjYXBlUmVnRXhwID0gLyg6fFxcLnxcXFt8XFxdfCx8PXxAKS9nO1xuICBjb25zdCBlc2NhcGVSZXBsYWNlVmFsdWUgPSBcIlxcXFwkMVwiO1xuICBjb25zdCBlbGVtZW50SWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImlkXCIpO1xuICBpZiAoZWxlbWVudElkKSB7XG4gICAgc2VsZWN0b3IucHVzaChcIiNcIiArIGVsZW1lbnRJZC5yZXBsYWNlKGVzY2FwZVJlZ0V4cCwgZXNjYXBlUmVwbGFjZVZhbHVlKSk7XG4gIH1cbiAgaWYgKHdpdGhDbGFzcyAhPT0gZmFsc2UgJiYgZWxlbWVudC5jbGFzc05hbWUpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdChcIiBcIikuZm9yRWFjaChjbHMgPT4ge1xuICAgICAgY2xzID0gY2xzLnRyaW0oKTtcbiAgICAgIGlmIChjbHMpIHtcbiAgICAgICAgc2VsZWN0b3IucHVzaChcIi5cIiArIGNscy5yZXBsYWNlKGVzY2FwZVJlZ0V4cCwgZXNjYXBlUmVwbGFjZVZhbHVlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IGVsO1xuICBpZiAod2l0aEluZGV4ICE9PSBmYWxzZSAmJiBzZWxlY3Rvci5sZW5ndGggPT09IDApIHtcbiAgICBlbCA9IGVsZW1lbnQ7XG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICBpbmRleCsrO1xuICAgICAgZWwgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgICBzZWxlY3Rvci51bnNoaWZ0KFwiOm50aC1jaGlsZChcIiArIGluZGV4ICsgXCIpXCIpO1xuICB9XG4gIHNlbGVjdG9yLnVuc2hpZnQoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICByZXR1cm4gc2VsZWN0b3Iuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkU2VsZWN0b3IoZWxlbWVudCkge1xuICBpZiAoIWRvY3VtZW50Q29udGFpbnMoZWxlbWVudC5vd25lckRvY3VtZW50LCBlbGVtZW50KSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3Qgc2VsZWN0b3IgPSBbYnVpbGRFbGVtZW50U2VsZWN0b3IoZWxlbWVudCldO1xuICBsZXQgbm9kZSA9IGRvbS5nZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICB3aGlsZSAobm9kZSAmJiBub2RlLm5vZGVUeXBlICE9PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAvLyBTdG9wIGF0IHRoZSBzaGFkb3cgcm9vdCBhcyBjcm9zcyBzaGFkb3cgc2VsZWN0b3JzIHdvbid0IHdvcmsuXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICBjb25zdCBpc0JvZHkgPSBub2RlLnRhZ05hbWUgPT09IFwiQk9EWVwiO1xuICAgICAgc2VsZWN0b3IudW5zaGlmdChidWlsZEVsZW1lbnRTZWxlY3Rvcihub2RlLCBmYWxzZSwgIWlzQm9keSkpO1xuICAgICAgaWYgKGlzQm9keSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZSA9IGRvbS5nZXRQYXJlbnROb2RlKG5vZGUpO1xuICB9XG4gIHJldHVybiBzZWxlY3Rvci5qb2luKFwiIFwiKTtcbn1cbmNsYXNzIERlbG9zZXIgZXh0ZW5kcyBUYWJzdGVyUGFydCB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIsIGVsZW1lbnQsIG9uRGlzcG9zZSwgcHJvcHMpIHtcbiAgICBzdXBlcih0YWJzdGVyLCBlbGVtZW50LCBwcm9wcyk7XG4gICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9oaXN0b3J5ID0gW1tdXTtcbiAgICB0aGlzLl9zbmFwc2hvdEluZGV4ID0gMDtcbiAgICB0aGlzLmlzQWN0aXZlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzQWN0aXZlO1xuICAgIH07XG4gICAgdGhpcy5zZXRTbmFwc2hvdCA9IGluZGV4ID0+IHtcbiAgICAgIHRoaXMuX3NuYXBzaG90SW5kZXggPSBpbmRleDtcbiAgICAgIGlmICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IGluZGV4ICsgMSkge1xuICAgICAgICB0aGlzLl9oaXN0b3J5LnNwbGljZShpbmRleCArIDEsIHRoaXMuX2hpc3RvcnkubGVuZ3RoIC0gaW5kZXggLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5faGlzdG9yeVtpbmRleF0pIHtcbiAgICAgICAgdGhpcy5faGlzdG9yeVtpbmRleF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBfc2V0SW5mb3JtYXRpdmVTdHlsZSQyKHRoaXMuX2VsZW1lbnQsIGZhbHNlLCB0aGlzLl9pc0FjdGl2ZSwgdGhpcy5fc25hcHNob3RJbmRleCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmZvY3VzRmlyc3QgPSAoKSA9PiB7XG4gICAgICBjb25zdCBlID0gdGhpcy5fZWxlbWVudC5nZXQoKTtcbiAgICAgIHJldHVybiAhIWUgJiYgdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC5mb2N1c0ZpcnN0KHtcbiAgICAgICAgY29udGFpbmVyOiBlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuZm9jdXNEZWZhdWx0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgZSA9IHRoaXMuX2VsZW1lbnQuZ2V0KCk7XG4gICAgICByZXR1cm4gISFlICYmIHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZm9jdXNEZWZhdWx0KGUpO1xuICAgIH07XG4gICAgdGhpcy5yZXNldEZvY3VzID0gKCkgPT4ge1xuICAgICAgY29uc3QgZSA9IHRoaXMuX2VsZW1lbnQuZ2V0KCk7XG4gICAgICByZXR1cm4gISFlICYmIHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQucmVzZXRGb2N1cyhlKTtcbiAgICB9O1xuICAgIHRoaXMuY2xlYXJIaXN0b3J5ID0gcHJlc2VydmVFeGlzdGluZyA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZWxlbWVudC5nZXQoKTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9oaXN0b3J5W3RoaXMuX3NuYXBzaG90SW5kZXhdID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hpc3RvcnlbdGhpcy5fc25hcHNob3RJbmRleF0gPSB0aGlzLl9oaXN0b3J5W3RoaXMuX3NuYXBzaG90SW5kZXhdLmZpbHRlcih3ZSA9PiB7XG4gICAgICAgIGNvbnN0IGUgPSB3ZS5nZXQoKTtcbiAgICAgICAgcmV0dXJuIGUgJiYgcHJlc2VydmVFeGlzdGluZyA/IGRvbS5ub2RlQ29udGFpbnMoZWxlbWVudCwgZSkgOiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy51aWQgPSBnZXRFbGVtZW50VUlkKHRhYnN0ZXIuZ2V0V2luZG93LCBlbGVtZW50KTtcbiAgICB0aGlzLnN0cmF0ZWd5ID0gcHJvcHMuc3RyYXRlZ3kgfHwgRGVsb3NlclN0cmF0ZWdpZXMuQXV0bztcbiAgICB0aGlzLl9vbkRpc3Bvc2UgPSBvbkRpc3Bvc2U7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBfc2V0SW5mb3JtYXRpdmVTdHlsZSQyKHRoaXMuX2VsZW1lbnQsIGZhbHNlLCB0aGlzLl9pc0FjdGl2ZSwgdGhpcy5fc25hcHNob3RJbmRleCk7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fcmVtb3ZlKCk7XG4gICAgdGhpcy5fb25EaXNwb3NlKHRoaXMpO1xuICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5fc25hcHNob3RJbmRleCA9IDA7XG4gICAgdGhpcy5fcHJvcHMgPSB7fTtcbiAgICB0aGlzLl9oaXN0b3J5ID0gW107XG4gIH1cbiAgc2V0QWN0aXZlKGFjdGl2ZSkge1xuICAgIHRoaXMuX2lzQWN0aXZlID0gYWN0aXZlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgX3NldEluZm9ybWF0aXZlU3R5bGUkMih0aGlzLl9lbGVtZW50LCBmYWxzZSwgdGhpcy5faXNBY3RpdmUsIHRoaXMuX3NuYXBzaG90SW5kZXgpO1xuICAgIH1cbiAgfVxuICBnZXRBY3Rpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb2N1c0RlZmF1bHQ6IHRoaXMuZm9jdXNEZWZhdWx0LFxuICAgICAgZm9jdXNGaXJzdDogdGhpcy5mb2N1c0ZpcnN0LFxuICAgICAgcmVzZXRGb2N1czogdGhpcy5yZXNldEZvY3VzLFxuICAgICAgY2xlYXJIaXN0b3J5OiB0aGlzLmNsZWFySGlzdG9yeSxcbiAgICAgIHNldFNuYXBzaG90OiB0aGlzLnNldFNuYXBzaG90LFxuICAgICAgaXNBY3RpdmU6IHRoaXMuaXNBY3RpdmVcbiAgICB9O1xuICB9XG4gIHVuc2hpZnQoZWxlbWVudCkge1xuICAgIGxldCBjdXIgPSB0aGlzLl9oaXN0b3J5W3RoaXMuX3NuYXBzaG90SW5kZXhdO1xuICAgIGN1ciA9IHRoaXMuX2hpc3RvcnlbdGhpcy5fc25hcHNob3RJbmRleF0gPSBjdXIuZmlsdGVyKHdlID0+IHtcbiAgICAgIGNvbnN0IGUgPSB3ZS5nZXQoKTtcbiAgICAgIHJldHVybiBlICYmIGUgIT09IGVsZW1lbnQ7XG4gICAgfSk7XG4gICAgY3VyLnVuc2hpZnQobmV3IFdlYWtIVE1MRWxlbWVudCh0aGlzLl90YWJzdGVyLmdldFdpbmRvdywgZWxlbWVudCwgYnVpbGRTZWxlY3RvcihlbGVtZW50KSkpO1xuICAgIHdoaWxlIChjdXIubGVuZ3RoID4gX2NvbnRhaW5lckhpc3RvcnlMZW5ndGgpIHtcbiAgICAgIGN1ci5wb3AoKTtcbiAgICB9XG4gIH1cbiAgZmluZEF2YWlsYWJsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZWxlbWVudC5nZXQoKTtcbiAgICBpZiAoIWVsZW1lbnQgfHwgIXRoaXMuX3RhYnN0ZXIuZm9jdXNhYmxlLmlzVmlzaWJsZShlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCByZXN0b3JlRm9jdXNPcmRlciA9IHRoaXMuX3Byb3BzLnJlc3RvcmVGb2N1c09yZGVyO1xuICAgIGxldCBhdmFpbGFibGUgPSBudWxsO1xuICAgIGNvbnN0IGN0eCA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGhpcy5fdGFic3RlciwgZWxlbWVudCk7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByb290ID0gY3R4LnJvb3Q7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSByb290LmdldEVsZW1lbnQoKTtcbiAgICBpZiAoIXJvb3RFbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJlc3RvcmVGb2N1c09yZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3RvcmVGb2N1c09yZGVyID0gcm9vdC5nZXRQcm9wcygpLnJlc3RvcmVGb2N1c09yZGVyO1xuICAgIH1cbiAgICBpZiAocmVzdG9yZUZvY3VzT3JkZXIgPT09IFJlc3RvcmVGb2N1c09yZGVycy5Sb290RGVmYXVsdCkge1xuICAgICAgYXZhaWxhYmxlID0gdGhpcy5fdGFic3Rlci5mb2N1c2FibGUuZmluZERlZmF1bHQoe1xuICAgICAgICBjb250YWluZXI6IHJvb3RFbGVtZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFhdmFpbGFibGUgJiYgcmVzdG9yZUZvY3VzT3JkZXIgPT09IFJlc3RvcmVGb2N1c09yZGVycy5Sb290Rmlyc3QpIHtcbiAgICAgIGF2YWlsYWJsZSA9IHRoaXMuX2ZpbmRGaXJzdChyb290RWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChhdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiBhdmFpbGFibGU7XG4gICAgfVxuICAgIGNvbnN0IGF2YWlsYWJsZUluSGlzdG9yeSA9IHRoaXMuX2ZpbmRJbkhpc3RvcnkoKTtcbiAgICBpZiAoYXZhaWxhYmxlSW5IaXN0b3J5ICYmIHJlc3RvcmVGb2N1c09yZGVyID09PSBSZXN0b3JlRm9jdXNPcmRlcnMuSGlzdG9yeSkge1xuICAgICAgcmV0dXJuIGF2YWlsYWJsZUluSGlzdG9yeTtcbiAgICB9XG4gICAgY29uc3QgYXZhaWxhYmxlRGVmYXVsdCA9IHRoaXMuX3RhYnN0ZXIuZm9jdXNhYmxlLmZpbmREZWZhdWx0KHtcbiAgICAgIGNvbnRhaW5lcjogZWxlbWVudFxuICAgIH0pO1xuICAgIGlmIChhdmFpbGFibGVEZWZhdWx0ICYmIHJlc3RvcmVGb2N1c09yZGVyID09PSBSZXN0b3JlRm9jdXNPcmRlcnMuRGVsb3NlckRlZmF1bHQpIHtcbiAgICAgIHJldHVybiBhdmFpbGFibGVEZWZhdWx0O1xuICAgIH1cbiAgICBjb25zdCBhdmFpbGFibGVGaXJzdCA9IHRoaXMuX2ZpbmRGaXJzdChlbGVtZW50KTtcbiAgICBpZiAoYXZhaWxhYmxlRmlyc3QgJiYgcmVzdG9yZUZvY3VzT3JkZXIgPT09IFJlc3RvcmVGb2N1c09yZGVycy5EZWxvc2VyRmlyc3QpIHtcbiAgICAgIHJldHVybiBhdmFpbGFibGVGaXJzdDtcbiAgICB9XG4gICAgcmV0dXJuIGF2YWlsYWJsZURlZmF1bHQgfHwgYXZhaWxhYmxlSW5IaXN0b3J5IHx8IGF2YWlsYWJsZUZpcnN0IHx8IG51bGw7XG4gIH1cbiAgY3VzdG9tRm9jdXNMb3N0SGFuZGxlcihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRGVsb3NlckZvY3VzTG9zdEV2ZW50KHRoaXMuZ2V0QWN0aW9ucygpKSk7XG4gIH1cbiAgX2ZpbmRJbkhpc3RvcnkoKSB7XG4gICAgY29uc3QgY3VyID0gdGhpcy5faGlzdG9yeVt0aGlzLl9zbmFwc2hvdEluZGV4XS5zbGljZSgwKTtcbiAgICB0aGlzLmNsZWFySGlzdG9yeSh0cnVlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgd2UgPSBjdXJbaV07XG4gICAgICBjb25zdCBlID0gd2UuZ2V0KCk7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZWxlbWVudC5nZXQoKTtcbiAgICAgIGlmIChlICYmIGVsZW1lbnQgJiYgZG9tLm5vZGVDb250YWlucyhlbGVtZW50LCBlKSkge1xuICAgICAgICBpZiAodGhpcy5fdGFic3Rlci5mb2N1c2FibGUuaXNGb2N1c2FibGUoZSkpIHtcbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdGhpcy5fcHJvcHMubm9TZWxlY3RvckNoZWNrKSB7XG4gICAgICAgIC8vIEVsZW1lbnQgaXMgbm90IGluIHRoZSBET00sIHRyeSB0byBsb2NhdGUgdGhlIG5vZGUgYnkgaXQnc1xuICAgICAgICAvLyBzZWxlY3Rvci4gVGhpcyBtaWdodCByZXR1cm4gbm90IGV4YWN0bHkgdGhlIHJpZ2h0IG5vZGUsXG4gICAgICAgIC8vIGJ1dCBpdCB3b3VsZCBiZSBlYXNpbHkgZml4YWJsZSBieSBoYXZpbmcgbW9yZSBkZXRhaWxlZCBzZWxlY3RvcnMuXG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gd2UuZ2V0RGF0YSgpO1xuICAgICAgICBpZiAoc2VsZWN0b3IgJiYgZWxlbWVudCkge1xuICAgICAgICAgIGxldCBlbHM7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVscyA9IGRvbS5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnQub3duZXJEb2N1bWVudCwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIHVubGVzcyB0aGVyZSBpcyBzb21lIGJ1ZyBpbiBidWlsZEVsZW1lbnRTZWxlY3RvcigpLlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcXVlcnlTZWxlY3RvckFsbCgnJHtzZWxlY3Rvcn0nKWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9IGVsc1tpXTtcbiAgICAgICAgICAgIGlmIChlbCAmJiB0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5pc0ZvY3VzYWJsZShlbCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfZmluZEZpcnN0KGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5fdGFic3Rlci5rZXlib2FyZE5hdmlnYXRpb24uaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkKCkpIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5fdGFic3Rlci5mb2N1c2FibGUuZmluZEZpcnN0KHtcbiAgICAgICAgY29udGFpbmVyOiBlbGVtZW50LFxuICAgICAgICB1c2VBY3RpdmVNb2RhbGl6ZXI6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX3JlbW92ZSgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIF9zZXRJbmZvcm1hdGl2ZVN0eWxlJDIodGhpcy5fZWxlbWVudCwgdHJ1ZSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBEZWxvc2VyQVBJIHtcbiAgY29uc3RydWN0b3IodGFic3RlciwgcHJvcHMpIHtcbiAgICAvKipcbiAgICAgKiBUcmFja3MgaWYgZm9jdXMgaXMgaW5zaWRlIGEgZGVsb3NlclxuICAgICAqL1xuICAgIHRoaXMuX2luRGVsb3NlciA9IGZhbHNlO1xuICAgIHRoaXMuX2lzUmVzdG9yaW5nRm9jdXMgPSBmYWxzZTtcbiAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX29uUmVzdG9yZUZvY3VzID0gZXZlbnQgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IChfYSA9IERlbG9zZXJBUEkuZ2V0RGVsb3Nlcih0aGlzLl90YWJzdGVyLCB0YXJnZXQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZEF2YWlsYWJsZSgpO1xuICAgICAgICBpZiAoYXZhaWxhYmxlKSB7XG4gICAgICAgICAgdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC5mb2N1cyhhdmFpbGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25Gb2N1cyA9IGUgPT4ge1xuICAgICAgaWYgKHRoaXMuX3Jlc3RvcmVGb2N1c1RpbWVyKSB7XG4gICAgICAgIHRoaXMuX3dpbigpLmNsZWFyVGltZW91dCh0aGlzLl9yZXN0b3JlRm9jdXNUaW1lcik7XG4gICAgICAgIHRoaXMuX3Jlc3RvcmVGb2N1c1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKCFlKSB7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlUmVzdG9yZUZvY3VzKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlbG9zZXIgPSB0aGlzLl9oaXN0b3J5LnByb2Nlc3MoZSk7XG4gICAgICBpZiAoZGVsb3Nlcikge1xuICAgICAgICB0aGlzLl9hY3RpdmF0ZShkZWxvc2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RlYWN0aXZhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX29uRGVsb3NlckRpc3Bvc2UgPSBkZWxvc2VyID0+IHtcbiAgICAgIHRoaXMuX2hpc3RvcnkucmVtb3ZlRGVsb3NlcihkZWxvc2VyKTtcbiAgICAgIGlmIChkZWxvc2VyLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVSZXN0b3JlRm9jdXMoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX3RhYnN0ZXIgPSB0YWJzdGVyO1xuICAgIHRoaXMuX3dpbiA9IHRhYnN0ZXIuZ2V0V2luZG93O1xuICAgIHRoaXMuX2hpc3RvcnkgPSBuZXcgRGVsb3Nlckhpc3RvcnkodGFic3Rlcik7XG4gICAgdGFic3Rlci5xdWV1ZUluaXQoKCkgPT4ge1xuICAgICAgdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC5zdWJzY3JpYmUodGhpcy5fb25Gb2N1cyk7XG4gICAgICBjb25zdCBkb2MgPSB0aGlzLl93aW4oKS5kb2N1bWVudDtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKERlbG9zZXJSZXN0b3JlRm9jdXNFdmVudE5hbWUsIHRoaXMuX29uUmVzdG9yZUZvY3VzKTtcbiAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb20uZ2V0QWN0aXZlRWxlbWVudChkb2MpO1xuICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudCAhPT0gZG9jLmJvZHkpIHtcbiAgICAgICAgLy8gQWRkaW5nIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnQgdG8gdGhlIGRlbG9zZXIgaGlzdG9yeS5cbiAgICAgICAgdGhpcy5fb25Gb2N1cyhhY3RpdmVFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBhdXRvRGVsb3NlciA9IHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wcy5hdXRvRGVsb3NlcjtcbiAgICBpZiAoYXV0b0RlbG9zZXIpIHtcbiAgICAgIHRoaXMuX2F1dG9EZWxvc2VyID0gYXV0b0RlbG9zZXI7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgY29uc3Qgd2luID0gdGhpcy5fd2luKCk7XG4gICAgaWYgKHRoaXMuX3Jlc3RvcmVGb2N1c1RpbWVyKSB7XG4gICAgICB3aW4uY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc3RvcmVGb2N1c1RpbWVyKTtcbiAgICAgIHRoaXMuX3Jlc3RvcmVGb2N1c1RpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYXV0b0RlbG9zZXJJbnN0YW5jZSkge1xuICAgICAgdGhpcy5fYXV0b0RlbG9zZXJJbnN0YW5jZS5kaXNwb3NlKCk7XG4gICAgICBkZWxldGUgdGhpcy5fYXV0b0RlbG9zZXJJbnN0YW5jZTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9hdXRvRGVsb3NlcjtcbiAgICB9XG4gICAgdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC51bnN1YnNjcmliZSh0aGlzLl9vbkZvY3VzKTtcbiAgICB3aW4uZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihEZWxvc2VyUmVzdG9yZUZvY3VzRXZlbnROYW1lLCB0aGlzLl9vblJlc3RvcmVGb2N1cyk7XG4gICAgdGhpcy5faGlzdG9yeS5kaXNwb3NlKCk7XG4gICAgZGVsZXRlIHRoaXMuX2N1ckRlbG9zZXI7XG4gIH1cbiAgY3JlYXRlRGVsb3NlcihlbGVtZW50LCBwcm9wcykge1xuICAgIHZhciBfYTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIDtcbiAgICBjb25zdCBkZWxvc2VyID0gbmV3IERlbG9zZXIodGhpcy5fdGFic3RlciwgZWxlbWVudCwgdGhpcy5fb25EZWxvc2VyRGlzcG9zZSwgcHJvcHMpO1xuICAgIGlmIChkb20ubm9kZUNvbnRhaW5zKGVsZW1lbnQsIChfYSA9IHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZ2V0Rm9jdXNlZEVsZW1lbnQoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCkpIHtcbiAgICAgIHRoaXMuX2FjdGl2YXRlKGRlbG9zZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZGVsb3NlcjtcbiAgfVxuICBnZXRBY3Rpb25zKGVsZW1lbnQpIHtcbiAgICBmb3IgKGxldCBlID0gZWxlbWVudDsgZTsgZSA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGUpKSB7XG4gICAgICBjb25zdCB0YWJzdGVyT25FbGVtZW50ID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0aGlzLl90YWJzdGVyLCBlKTtcbiAgICAgIGlmICh0YWJzdGVyT25FbGVtZW50ICYmIHRhYnN0ZXJPbkVsZW1lbnQuZGVsb3Nlcikge1xuICAgICAgICByZXR1cm4gdGFic3Rlck9uRWxlbWVudC5kZWxvc2VyLmdldEFjdGlvbnMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBwYXVzZSgpIHtcbiAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuX3Jlc3RvcmVGb2N1c1RpbWVyKSB7XG4gICAgICB0aGlzLl93aW4oKS5jbGVhclRpbWVvdXQodGhpcy5fcmVzdG9yZUZvY3VzVGltZXIpO1xuICAgICAgdGhpcy5fcmVzdG9yZUZvY3VzVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHJlc3VtZShyZXN0b3JlKSB7XG4gICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICBpZiAocmVzdG9yZSkge1xuICAgICAgdGhpcy5fc2NoZWR1bGVSZXN0b3JlRm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyBhbmQgc2V0cyB0aGUgY3VycmVudCBkZWxvc2VyXG4gICAqL1xuICBfYWN0aXZhdGUoZGVsb3Nlcikge1xuICAgIGNvbnN0IGN1ckRlbG9zZXIgPSB0aGlzLl9jdXJEZWxvc2VyO1xuICAgIGlmIChjdXJEZWxvc2VyICE9PSBkZWxvc2VyKSB7XG4gICAgICB0aGlzLl9pbkRlbG9zZXIgPSB0cnVlO1xuICAgICAgY3VyRGVsb3NlciA9PT0gbnVsbCB8fCBjdXJEZWxvc2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJEZWxvc2VyLnNldEFjdGl2ZShmYWxzZSk7XG4gICAgICBkZWxvc2VyLnNldEFjdGl2ZSh0cnVlKTtcbiAgICAgIHRoaXMuX2N1ckRlbG9zZXIgPSBkZWxvc2VyO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gZm9jdXMgc2hvdWxkIG5vIGxvbmdlciBiZSBpbiBhIGRlbG9zZXJcbiAgICovXG4gIF9kZWFjdGl2YXRlKCkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLl9pbkRlbG9zZXIgPSBmYWxzZTtcbiAgICAoX2EgPSB0aGlzLl9jdXJEZWxvc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKGZhbHNlKTtcbiAgICB0aGlzLl9jdXJEZWxvc2VyID0gdW5kZWZpbmVkO1xuICB9XG4gIF9zY2hlZHVsZVJlc3RvcmVGb2N1cyhmb3JjZSkge1xuICAgIGlmICh0aGlzLl9pc1BhdXNlZCB8fCB0aGlzLl9pc1Jlc3RvcmluZ0ZvY3VzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3RvcmVGb2N1cyA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRoaXMuX3Jlc3RvcmVGb2N1c1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgY29uc3QgbGFzdEZvY3VzZWQgPSB0aGlzLl90YWJzdGVyLmZvY3VzZWRFbGVtZW50LmdldExhc3RGb2N1c2VkRWxlbWVudCgpO1xuICAgICAgaWYgKCFmb3JjZSAmJiAodGhpcy5faXNSZXN0b3JpbmdGb2N1cyB8fCAhdGhpcy5faW5EZWxvc2VyIHx8IGxhc3RGb2N1c2VkICYmICFpc0Rpc3BsYXlOb25lKGxhc3RGb2N1c2VkKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VyRGVsb3NlciA9IHRoaXMuX2N1ckRlbG9zZXI7XG4gICAgICBsZXQgaXNNYW51YWwgPSBmYWxzZTtcbiAgICAgIGlmIChjdXJEZWxvc2VyKSB7XG4gICAgICAgIGlmIChsYXN0Rm9jdXNlZCAmJiBjdXJEZWxvc2VyLmN1c3RvbUZvY3VzTG9zdEhhbmRsZXIobGFzdEZvY3VzZWQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJEZWxvc2VyLnN0cmF0ZWd5ID09PSBEZWxvc2VyU3RyYXRlZ2llcy5NYW51YWwpIHtcbiAgICAgICAgICBpc01hbnVhbCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgY3VyRGVsb3NlckVsZW1lbnQgPSBjdXJEZWxvc2VyLmdldEVsZW1lbnQoKTtcbiAgICAgICAgICBjb25zdCBlbCA9IGN1ckRlbG9zZXIuZmluZEF2YWlsYWJsZSgpO1xuICAgICAgICAgIGlmIChlbCAmJiAoIShjdXJEZWxvc2VyRWxlbWVudCA9PT0gbnVsbCB8fCBjdXJEZWxvc2VyRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VyRGVsb3NlckVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgVGFic3Rlck1vdmVGb2N1c0V2ZW50KHtcbiAgICAgICAgICAgIGJ5OiBcImRlbG9zZXJcIixcbiAgICAgICAgICAgIG93bmVyOiBjdXJEZWxvc2VyRWxlbWVudCxcbiAgICAgICAgICAgIG5leHQ6IGVsXG4gICAgICAgICAgfSkpKSB8fCB0aGlzLl90YWJzdGVyLmZvY3VzZWRFbGVtZW50LmZvY3VzKGVsKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2RlYWN0aXZhdGUoKTtcbiAgICAgIGlmIChpc01hbnVhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9pc1Jlc3RvcmluZ0ZvY3VzID0gdHJ1ZTtcbiAgICAgIC8vIGZvY3VzQXZhaWxhYmxlIHJldHVybnMgbnVsbCB3aGVuIHRoZSBkZWZhdWx0IGFjdGlvbiBpcyBwcmV2ZW50ZWQgYnkgdGhlIGFwcGxpY2F0aW9uLCBmYWxzZVxuICAgICAgLy8gd2hlbiBub3RoaW5nIHdhcyBmb2N1c2VkIGFuZCB0cnVlIHdoZW4gc29tZXRoaW5nIHdhcyBmb2N1c2VkLlxuICAgICAgaWYgKChhd2FpdCB0aGlzLl9oaXN0b3J5LmZvY3VzQXZhaWxhYmxlKG51bGwpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5faGlzdG9yeS5yZXNldEZvY3VzKG51bGwpO1xuICAgICAgfVxuICAgICAgdGhpcy5faXNSZXN0b3JpbmdGb2N1cyA9IGZhbHNlO1xuICAgIH07XG4gICAgaWYgKGZvcmNlKSB7XG4gICAgICByZXN0b3JlRm9jdXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzdG9yZUZvY3VzVGltZXIgPSB0aGlzLl93aW4oKS5zZXRUaW1lb3V0KHJlc3RvcmVGb2N1cywgMTAwKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldERlbG9zZXIodGFic3RlciwgZWxlbWVudCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgcm9vdDtcbiAgICBmb3IgKGxldCBlID0gZWxlbWVudDsgZTsgZSA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGUpKSB7XG4gICAgICBjb25zdCB0YWJzdGVyT25FbGVtZW50ID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0YWJzdGVyLCBlKTtcbiAgICAgIGlmICh0YWJzdGVyT25FbGVtZW50KSB7XG4gICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgIHJvb3QgPSB0YWJzdGVyT25FbGVtZW50LnJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsb3NlciA9IHRhYnN0ZXJPbkVsZW1lbnQuZGVsb3NlcjtcbiAgICAgICAgaWYgKGRlbG9zZXIpIHtcbiAgICAgICAgICByZXR1cm4gZGVsb3NlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZWxvc2VyQVBJID0gdGFic3Rlci5kZWxvc2VyICYmIHRhYnN0ZXIuZGVsb3NlcjtcbiAgICBpZiAoZGVsb3NlckFQSSkge1xuICAgICAgaWYgKGRlbG9zZXJBUEkuX2F1dG9EZWxvc2VySW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGRlbG9zZXJBUEkuX2F1dG9EZWxvc2VySW5zdGFuY2U7XG4gICAgICB9XG4gICAgICBjb25zdCBhdXRvRGVsb3NlclByb3BzID0gZGVsb3NlckFQSS5fYXV0b0RlbG9zZXI7XG4gICAgICBpZiAocm9vdCAmJiAhZGVsb3NlckFQSS5fYXV0b0RlbG9zZXJJbnN0YW5jZSAmJiBhdXRvRGVsb3NlclByb3BzKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSAoX2EgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ib2R5O1xuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgIGRlbG9zZXJBUEkuX2F1dG9EZWxvc2VySW5zdGFuY2UgPSBuZXcgRGVsb3Nlcih0YWJzdGVyLCBib2R5LCB0YWJzdGVyLmRlbG9zZXIuX29uRGVsb3NlckRpc3Bvc2UsIGF1dG9EZWxvc2VyUHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVsb3NlckFQSS5fYXV0b0RlbG9zZXJJbnN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBzdGF0aWMgZ2V0SGlzdG9yeShpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZS5faGlzdG9yeTtcbiAgfVxuICBzdGF0aWMgZm9yY2VSZXN0b3JlRm9jdXMoaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZS5fc2NoZWR1bGVSZXN0b3JlRm9jdXModHJ1ZSk7XG4gIH1cbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY2xhc3MgU3Vic2NyaWJhYmxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gW107XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgICBkZWxldGUgdGhpcy5fdmFsO1xuICB9XG4gIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgICBjb25zdCBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICB9XG4gIHN1YnNjcmliZUZpcnN0KGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgY2FsbGJhY2tzLnVuc2hpZnQoY2FsbGJhY2spO1xuICB9XG4gIHVuc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9jYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuICBzZXRWYWwodmFsLCBkZXRhaWwpIHtcbiAgICBpZiAodGhpcy5fdmFsID09PSB2YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdmFsID0gdmFsO1xuICAgIHRoaXMuX2NhbGxDYWxsYmFja3ModmFsLCBkZXRhaWwpO1xuICB9XG4gIGdldFZhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsO1xuICB9XG4gIHRyaWdnZXIodmFsLCBkZXRhaWwpIHtcbiAgICB0aGlzLl9jYWxsQ2FsbGJhY2tzKHZhbCwgZGV0YWlsKTtcbiAgfVxuICBfY2FsbENhbGxiYWNrcyh2YWwsIGRldGFpbCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHZhbCwgZGV0YWlsKSk7XG4gIH1cbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY29uc3QgX3RyYW5zYWN0aW9uVGltZW91dCA9IDE1MDA7XG5jb25zdCBfcGluZ1RpbWVvdXQgPSAzMDAwO1xuY29uc3QgX3RhcmdldElkVXAgPSBcInVwXCI7XG5jb25zdCBDcm9zc09yaWdpblRyYW5zYWN0aW9uVHlwZXMgPSB7XG4gIEJvb3RzdHJhcDogMSxcbiAgRm9jdXNFbGVtZW50OiAyLFxuICBTdGF0ZTogMyxcbiAgR2V0RWxlbWVudDogNCxcbiAgUmVzdG9yZUZvY3VzSW5EZWxvc2VyOiA1LFxuICBQaW5nOiA2XG59O1xuY2xhc3MgQ3Jvc3NPcmlnaW5EZWxvc2VySXRlbSBleHRlbmRzIERlbG9zZXJJdGVtQmFzZSB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIsIGRlbG9zZXIsIHRyYXNhY3Rpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kZWxvc2VyID0gZGVsb3NlcjtcbiAgICB0aGlzLl90cmFuc2FjdGlvbnMgPSB0cmFzYWN0aW9ucztcbiAgfVxuICBiZWxvbmdzVG8oZGVsb3Nlcikge1xuICAgIHJldHVybiBkZWxvc2VyLmRlbG9zZXJVSWQgPT09IHRoaXMuX2RlbG9zZXIuZGVsb3NlclVJZDtcbiAgfVxuICBhc3luYyBmb2N1c0F2YWlsYWJsZSgpIHtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgLi4udGhpcy5fZGVsb3NlcixcbiAgICAgIHJlc2V0OiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9ucy5iZWdpblRyYW5zYWN0aW9uKFJlc3RvcmVGb2N1c0luRGVsb3NlclRyYW5zYWN0aW9uLCBkYXRhKS50aGVuKHZhbHVlID0+ICEhdmFsdWUpO1xuICB9XG4gIGFzeW5jIHJlc2V0Rm9jdXMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIC4uLnRoaXMuX2RlbG9zZXIsXG4gICAgICByZXNldDogdHJ1ZVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9ucy5iZWdpblRyYW5zYWN0aW9uKFJlc3RvcmVGb2N1c0luRGVsb3NlclRyYW5zYWN0aW9uLCBkYXRhKS50aGVuKHZhbHVlID0+ICEhdmFsdWUpO1xuICB9XG59XG5jbGFzcyBDcm9zc09yaWdpbkRlbG9zZXJIaXN0b3J5QnlSb290IGV4dGVuZHMgRGVsb3Nlckhpc3RvcnlCeVJvb3RCYXNlIHtcbiAgY29uc3RydWN0b3IodGFic3Rlciwgcm9vdFVJZCwgdHJhbnNhY3Rpb25zKSB7XG4gICAgc3VwZXIodGFic3Rlciwgcm9vdFVJZCk7XG4gICAgdGhpcy5fdHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zO1xuICB9XG4gIHVuc2hpZnQoZGVsb3Nlcikge1xuICAgIGxldCBpdGVtO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faGlzdG9yeS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuX2hpc3RvcnlbaV0uYmVsb25nc1RvKGRlbG9zZXIpKSB7XG4gICAgICAgIGl0ZW0gPSB0aGlzLl9oaXN0b3J5W2ldO1xuICAgICAgICB0aGlzLl9oaXN0b3J5LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXRlbSkge1xuICAgICAgaXRlbSA9IG5ldyBDcm9zc09yaWdpbkRlbG9zZXJJdGVtKHRoaXMuX3RhYnN0ZXIsIGRlbG9zZXIsIHRoaXMuX3RyYW5zYWN0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMuX2hpc3RvcnkudW5zaGlmdChpdGVtKTtcbiAgICB0aGlzLl9oaXN0b3J5LnNwbGljZSgxMCwgdGhpcy5faGlzdG9yeS5sZW5ndGggLSAxMCk7XG4gIH1cbiAgYXN5bmMgZm9jdXNBdmFpbGFibGUoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuX2hpc3RvcnkpIHtcbiAgICAgIGlmIChhd2FpdCBpLmZvY3VzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyByZXNldEZvY3VzKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLl9oaXN0b3J5KSB7XG4gICAgICBpZiAoYXdhaXQgaS5yZXNldEZvY3VzKCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuY2xhc3MgQ3Jvc3NPcmlnaW5UcmFuc2FjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIsIGdldE93bmVyLCBrbm93blRhcmdldHMsIHZhbHVlLCB0aW1lb3V0LCBzZW50VG8sIHRhcmdldElkLCBzZW5kVXApIHtcbiAgICB0aGlzLl9pblByb2dyZXNzID0ge307XG4gICAgdGhpcy5faXNEb25lID0gZmFsc2U7XG4gICAgdGhpcy5faXNTZWxmUmVzcG9uZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3NlbnRDb3VudCA9IDA7XG4gICAgdGhpcy50YWJzdGVyID0gdGFic3RlcjtcbiAgICB0aGlzLm93bmVyID0gZ2V0T3duZXI7XG4gICAgdGhpcy5vd25lcklkID0gZ2V0V2luZG93VUlkKGdldE93bmVyKCkpO1xuICAgIHRoaXMuaWQgPSBnZXRVSWQoZ2V0T3duZXIoKSk7XG4gICAgdGhpcy5iZWdpbkRhdGEgPSB2YWx1ZTtcbiAgICB0aGlzLl9rbm93blRhcmdldHMgPSBrbm93blRhcmdldHM7XG4gICAgdGhpcy5fc2VudFRvID0gc2VudFRvIHx8IHtcbiAgICAgIFt0aGlzLm93bmVySWRdOiB0cnVlXG4gICAgfTtcbiAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XG4gICAgdGhpcy5zZW5kVXAgPSBzZW5kVXA7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICB0aGlzLl9wcm9taXNlID0gbmV3IChnZXRQcm9taXNlKGdldE93bmVyKSkoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gIH1cbiAgZ2V0VGFyZ2V0cyhrbm93blRhcmdldHMpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXRJZCA9PT0gX3RhcmdldElkVXAgPyB0aGlzLnNlbmRVcCA/IHtcbiAgICAgIFtfdGFyZ2V0SWRVcF06IHtcbiAgICAgICAgc2VuZDogdGhpcy5zZW5kVXBcbiAgICAgIH1cbiAgICB9IDogbnVsbCA6IHRoaXMudGFyZ2V0SWQgPyBrbm93blRhcmdldHNbdGhpcy50YXJnZXRJZF0gPyB7XG4gICAgICBbdGhpcy50YXJnZXRJZF06IHtcbiAgICAgICAgc2VuZDoga25vd25UYXJnZXRzW3RoaXMudGFyZ2V0SWRdLnNlbmRcbiAgICAgIH1cbiAgICB9IDogbnVsbCA6IE9iamVjdC5rZXlzKGtub3duVGFyZ2V0cykubGVuZ3RoID09PSAwICYmIHRoaXMuc2VuZFVwID8ge1xuICAgICAgW190YXJnZXRJZFVwXToge1xuICAgICAgICBzZW5kOiB0aGlzLnNlbmRVcFxuICAgICAgfVxuICAgIH0gOiBPYmplY3Qua2V5cyhrbm93blRhcmdldHMpLmxlbmd0aCA+IDAgPyBrbm93blRhcmdldHMgOiBudWxsO1xuICB9XG4gIGJlZ2luKHNlbGZSZXNwb25zZSkge1xuICAgIGNvbnN0IHRhcmdldHMgPSB0aGlzLmdldFRhcmdldHModGhpcy5fa25vd25UYXJnZXRzKTtcbiAgICBjb25zdCBzZW50VG8gPSB7XG4gICAgICAuLi50aGlzLl9zZW50VG9cbiAgICB9O1xuICAgIGlmICh0YXJnZXRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKHRhcmdldHMpKSB7XG4gICAgICAgIHNlbnRUb1tpZF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgdHJhbnNhY3Rpb246IHRoaXMuaWQsXG4gICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICBpc1Jlc3BvbnNlOiBmYWxzZSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIG93bmVyOiB0aGlzLm93bmVySWQsXG4gICAgICBzZW50dG86IHNlbnRUbyxcbiAgICAgIHRpbWVvdXQ6IHRoaXMudGltZW91dCxcbiAgICAgIGJlZ2luRGF0YTogdGhpcy5iZWdpbkRhdGFcbiAgICB9O1xuICAgIGlmICh0aGlzLnRhcmdldElkKSB7XG4gICAgICBkYXRhLnRhcmdldCA9IHRoaXMudGFyZ2V0SWQ7XG4gICAgfVxuICAgIGlmIChzZWxmUmVzcG9uc2UpIHtcbiAgICAgIHRoaXMuX2lzU2VsZlJlc3BvbmRpbmcgPSB0cnVlO1xuICAgICAgc2VsZlJlc3BvbnNlKGRhdGEpLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICB0aGlzLl9pc1NlbGZSZXNwb25kaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmVuZERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kRGF0YSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbmREYXRhIHx8IHRoaXMuX3NlbnRDb3VudCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0cykge1xuICAgICAgZm9yIChjb25zdCBpZCBvZiBPYmplY3Qua2V5cyh0YXJnZXRzKSkge1xuICAgICAgICBpZiAoIShpZCBpbiB0aGlzLl9zZW50VG8pKSB7XG4gICAgICAgICAgdGhpcy5fc2VuZCh0YXJnZXRzW2lkXS5zZW5kLCBpZCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX3NlbnRDb3VudCA9PT0gMCAmJiAhdGhpcy5faXNTZWxmUmVzcG9uZGluZykge1xuICAgICAgdGhpcy5lbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gIH1cbiAgX3NlbmQoc2VuZCwgdGFyZ2V0SWQsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5faW5Qcm9ncmVzc1t0YXJnZXRJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5faW5Qcm9ncmVzc1t0YXJnZXRJZF0gPSB0cnVlO1xuICAgICAgdGhpcy5fc2VudENvdW50Kys7XG4gICAgICBzZW5kKGRhdGEpO1xuICAgIH1cbiAgfVxuICBlbmQoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5faXNEb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2lzRG9uZSA9IHRydWU7XG4gICAgaWYgKHRoaXMuZW5kRGF0YSA9PT0gdW5kZWZpbmVkICYmIGVycm9yKSB7XG4gICAgICBpZiAodGhpcy5fcmVqZWN0KSB7XG4gICAgICAgIHRoaXMuX3JlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9yZXNvbHZlKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuZW5kRGF0YSk7XG4gICAgfVxuICB9XG4gIG9uUmVzcG9uc2UoZGF0YSkge1xuICAgIGNvbnN0IGVuZERhdGEgPSBkYXRhLmVuZERhdGE7XG4gICAgaWYgKGVuZERhdGEgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5lbmREYXRhKSB7XG4gICAgICB0aGlzLmVuZERhdGEgPSBlbmREYXRhO1xuICAgIH1cbiAgICBjb25zdCBpblByb2dyZXNzSWQgPSBkYXRhLnRhcmdldCA9PT0gX3RhcmdldElkVXAgPyBfdGFyZ2V0SWRVcCA6IGRhdGEub3duZXI7XG4gICAgaWYgKHRoaXMuX2luUHJvZ3Jlc3NbaW5Qcm9ncmVzc0lkXSkge1xuICAgICAgdGhpcy5faW5Qcm9ncmVzc1tpblByb2dyZXNzSWRdID0gZmFsc2U7XG4gICAgICB0aGlzLl9zZW50Q291bnQtLTtcbiAgICAgIGlmICh0aGlzLmVuZERhdGEgfHwgdGhpcy5fc2VudENvdW50ID09PSAwICYmICF0aGlzLl9pc1NlbGZSZXNwb25kaW5nKSB7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jbGFzcyBCb290c3RyYXBUcmFuc2FjdGlvbiBleHRlbmRzIENyb3NzT3JpZ2luVHJhbnNhY3Rpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IENyb3NzT3JpZ2luVHJhbnNhY3Rpb25UeXBlcy5Cb290c3RyYXA7XG4gIH1cbiAgc3RhdGljIHNob3VsZEZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBhc3luYyBtYWtlUmVzcG9uc2UodGFic3Rlcikge1xuICAgIHJldHVybiB7XG4gICAgICBpc05hdmlnYXRpbmdXaXRoS2V5Ym9hcmQ6IHRhYnN0ZXIua2V5Ym9hcmROYXZpZ2F0aW9uLmlzTmF2aWdhdGluZ1dpdGhLZXlib2FyZCgpXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgRm9jdXNFbGVtZW50VHJhbnNhY3Rpb24gZXh0ZW5kcyBDcm9zc09yaWdpblRyYW5zYWN0aW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSBDcm9zc09yaWdpblRyYW5zYWN0aW9uVHlwZXMuRm9jdXNFbGVtZW50O1xuICB9XG4gIHN0YXRpYyBzaG91bGRTZWxmUmVzcG9uZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgc2hvdWxkRm9yd2FyZCh0YWJzdGVyLCBkYXRhLCBnZXRPd25lcikge1xuICAgIGNvbnN0IGVsID0gR2V0RWxlbWVudFRyYW5zYWN0aW9uLmZpbmRFbGVtZW50KHRhYnN0ZXIsIGdldE93bmVyLCBkYXRhLmJlZ2luRGF0YSk7XG4gICAgcmV0dXJuICFlbCB8fCAhdGFic3Rlci5mb2N1c2FibGUuaXNGb2N1c2FibGUoZWwpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBtYWtlUmVzcG9uc2UodGFic3RlciwgZGF0YSwgZ2V0T3duZXIsIG93bmVySWQsIHRyYW5zYWN0aW9ucywgZm9yd2FyZFJlc3VsdCkge1xuICAgIGNvbnN0IGVsID0gR2V0RWxlbWVudFRyYW5zYWN0aW9uLmZpbmRFbGVtZW50KHRhYnN0ZXIsIGdldE93bmVyLCBkYXRhLmJlZ2luRGF0YSk7XG4gICAgcmV0dXJuICEhZWwgJiYgdGFic3Rlci5mb2N1c2VkRWxlbWVudC5mb2N1cyhlbCwgdHJ1ZSkgfHwgISEoYXdhaXQgZm9yd2FyZFJlc3VsdCk7XG4gIH1cbn1cbmNvbnN0IENyb3NzT3JpZ2luU3RhdGVzID0ge1xuICBGb2N1c2VkOiAxLFxuICBCbHVycmVkOiAyLFxuICBPYnNlcnZlZDogMyxcbiAgRGVhZFdpbmRvdzogNCxcbiAgS2V5Ym9hcmROYXZpZ2F0aW9uOiA1LFxuICBPdXRsaW5lOiA2XG59O1xuY2xhc3MgU3RhdGVUcmFuc2FjdGlvbiBleHRlbmRzIENyb3NzT3JpZ2luVHJhbnNhY3Rpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IENyb3NzT3JpZ2luVHJhbnNhY3Rpb25UeXBlcy5TdGF0ZTtcbiAgfVxuICBzdGF0aWMgc2hvdWxkU2VsZlJlc3BvbmQodGFic3RlciwgZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnN0YXRlICE9PSBDcm9zc09yaWdpblN0YXRlcy5EZWFkV2luZG93ICYmIGRhdGEuc3RhdGUgIT09IENyb3NzT3JpZ2luU3RhdGVzLktleWJvYXJkTmF2aWdhdGlvbjtcbiAgfVxuICBzdGF0aWMgYXN5bmMgbWFrZVJlc3BvbnNlKHRhYnN0ZXIsIGRhdGEsIGdldE93bmVyLCBvd25lcklkLCB0cmFuc2FjdGlvbnMsIGZvcndhcmRSZXN1bHQsIGlzU2VsZlJlc3BvbnNlKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gZGF0YS50aW1lc3RhbXA7XG4gICAgY29uc3QgYmVnaW5EYXRhID0gZGF0YS5iZWdpbkRhdGE7XG4gICAgaWYgKHRpbWVzdGFtcCAmJiBiZWdpbkRhdGEpIHtcbiAgICAgIHN3aXRjaCAoYmVnaW5EYXRhLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgQ3Jvc3NPcmlnaW5TdGF0ZXMuRm9jdXNlZDpcbiAgICAgICAgICByZXR1cm4gU3RhdGVUcmFuc2FjdGlvbi5fbWFrZUZvY3VzZWRSZXNwb25zZSh0YWJzdGVyLCB0aW1lc3RhbXAsIGJlZ2luRGF0YSwgdHJhbnNhY3Rpb25zLCBpc1NlbGZSZXNwb25zZSk7XG4gICAgICAgIGNhc2UgQ3Jvc3NPcmlnaW5TdGF0ZXMuQmx1cnJlZDpcbiAgICAgICAgICByZXR1cm4gU3RhdGVUcmFuc2FjdGlvbi5fbWFrZUJsdXJyZWRSZXNwb25zZSh0YWJzdGVyLCB0aW1lc3RhbXAsIGJlZ2luRGF0YSwgdHJhbnNhY3Rpb25zLmN0eCk7XG4gICAgICAgIGNhc2UgQ3Jvc3NPcmlnaW5TdGF0ZXMuT2JzZXJ2ZWQ6XG4gICAgICAgICAgcmV0dXJuIFN0YXRlVHJhbnNhY3Rpb24uX21ha2VPYnNlcnZlZFJlc3BvbnNlKHRhYnN0ZXIsIGJlZ2luRGF0YSk7XG4gICAgICAgIGNhc2UgQ3Jvc3NPcmlnaW5TdGF0ZXMuRGVhZFdpbmRvdzpcbiAgICAgICAgICByZXR1cm4gU3RhdGVUcmFuc2FjdGlvbi5fbWFrZURlYWRXaW5kb3dSZXNwb25zZSh0YWJzdGVyLCBiZWdpbkRhdGEsIHRyYW5zYWN0aW9ucywgZm9yd2FyZFJlc3VsdCk7XG4gICAgICAgIGNhc2UgQ3Jvc3NPcmlnaW5TdGF0ZXMuS2V5Ym9hcmROYXZpZ2F0aW9uOlxuICAgICAgICAgIHJldHVybiBTdGF0ZVRyYW5zYWN0aW9uLl9tYWtlS2V5Ym9hcmROYXZpZ2F0aW9uUmVzcG9uc2UodGFic3RlciwgdHJhbnNhY3Rpb25zLmN0eCwgYmVnaW5EYXRhLmlzTmF2aWdhdGluZ1dpdGhLZXlib2FyZCk7XG4gICAgICAgIGNhc2UgQ3Jvc3NPcmlnaW5TdGF0ZXMuT3V0bGluZTpcbiAgICAgICAgICByZXR1cm4gU3RhdGVUcmFuc2FjdGlvbi5fbWFrZU91dGxpbmVSZXNwb25zZSh0YWJzdGVyLCB0cmFuc2FjdGlvbnMuY3R4LCBiZWdpbkRhdGEub3V0bGluZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVFbGVtZW50KHRhYnN0ZXIsIGJlZ2luRGF0YSkge1xuICAgIHJldHVybiBiZWdpbkRhdGEudWlkID8gbmV3IENyb3NzT3JpZ2luRWxlbWVudCh0YWJzdGVyLCBiZWdpbkRhdGEudWlkLCBiZWdpbkRhdGEub3duZXJVSWQsIGJlZ2luRGF0YS5pZCwgYmVnaW5EYXRhLnJvb3RVSWQsIGJlZ2luRGF0YS5vYnNlcnZlZE5hbWUsIGJlZ2luRGF0YS5vYnNlcnZlZERldGFpbHMpIDogbnVsbDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgX21ha2VGb2N1c2VkUmVzcG9uc2UodGFic3RlciwgdGltZXN0YW1wLCBiZWdpbkRhdGEsIHRyYW5zYWN0aW9ucywgaXNTZWxmUmVzcG9uc2UpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gU3RhdGVUcmFuc2FjdGlvbi5jcmVhdGVFbGVtZW50KHRhYnN0ZXIsIGJlZ2luRGF0YSk7XG4gICAgaWYgKGJlZ2luRGF0YSAmJiBiZWdpbkRhdGEub3duZXJVSWQgJiYgZWxlbWVudCkge1xuICAgICAgdHJhbnNhY3Rpb25zLmN0eC5mb2N1c093bmVyID0gYmVnaW5EYXRhLm93bmVyVUlkO1xuICAgICAgdHJhbnNhY3Rpb25zLmN0eC5mb2N1c093bmVyVGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgaWYgKCFpc1NlbGZSZXNwb25zZSAmJiBiZWdpbkRhdGEucm9vdFVJZCAmJiBiZWdpbkRhdGEuZGVsb3NlclVJZCkge1xuICAgICAgICBjb25zdCBkZWxvc2VyQVBJID0gdGFic3Rlci5kZWxvc2VyO1xuICAgICAgICBpZiAoZGVsb3NlckFQSSkge1xuICAgICAgICAgIGNvbnN0IGhpc3RvcnkgPSBEZWxvc2VyQVBJLmdldEhpc3RvcnkoZGVsb3NlckFQSSk7XG4gICAgICAgICAgY29uc3QgZGVsb3NlciA9IHtcbiAgICAgICAgICAgIG93bmVyVUlkOiBiZWdpbkRhdGEub3duZXJVSWQsXG4gICAgICAgICAgICBkZWxvc2VyVUlkOiBiZWdpbkRhdGEuZGVsb3NlclVJZCxcbiAgICAgICAgICAgIHJvb3RVSWQ6IGJlZ2luRGF0YS5yb290VUlkXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBoaXN0b3J5SXRlbSA9IGhpc3RvcnkubWFrZShiZWdpbkRhdGEucm9vdFVJZCwgKCkgPT4gbmV3IENyb3NzT3JpZ2luRGVsb3Nlckhpc3RvcnlCeVJvb3QodGFic3RlciwgZGVsb3Nlci5yb290VUlkLCB0cmFuc2FjdGlvbnMpKTtcbiAgICAgICAgICBoaXN0b3J5SXRlbS51bnNoaWZ0KGRlbG9zZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBDcm9zc09yaWdpbkZvY3VzZWRFbGVtZW50U3RhdGUuc2V0VmFsKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgIHRhYnN0ZXIuY3Jvc3NPcmlnaW4uZm9jdXNlZEVsZW1lbnQsIGVsZW1lbnQsIHtcbiAgICAgICAgaXNGb2N1c2VkUHJvZ3JhbW1hdGljYWxseTogYmVnaW5EYXRhLmlzRm9jdXNlZFByb2dyYW1tYXRpY2FsbHlcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgX21ha2VCbHVycmVkUmVzcG9uc2UodGFic3RlciwgdGltZXN0YW1wLCBiZWdpbkRhdGEsIGNvbnRleHQpIHtcbiAgICBpZiAoYmVnaW5EYXRhICYmIChiZWdpbkRhdGEub3duZXJVSWQgPT09IGNvbnRleHQuZm9jdXNPd25lciB8fCBiZWdpbkRhdGEuZm9yY2UpICYmICghY29udGV4dC5mb2N1c093bmVyVGltZXN0YW1wIHx8IGNvbnRleHQuZm9jdXNPd25lclRpbWVzdGFtcCA8IHRpbWVzdGFtcCkpIHtcbiAgICAgIENyb3NzT3JpZ2luRm9jdXNlZEVsZW1lbnRTdGF0ZS5zZXRWYWwoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgdGFic3Rlci5jcm9zc09yaWdpbi5mb2N1c2VkRWxlbWVudCwgdW5kZWZpbmVkLCB7fSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0YXRpYyBhc3luYyBfbWFrZU9ic2VydmVkUmVzcG9uc2UodGFic3RlciwgYmVnaW5EYXRhKSB7XG4gICAgY29uc3QgbmFtZSA9IGJlZ2luRGF0YS5vYnNlcnZlZE5hbWU7XG4gICAgY29uc3QgZWxlbWVudCA9IFN0YXRlVHJhbnNhY3Rpb24uY3JlYXRlRWxlbWVudCh0YWJzdGVyLCBiZWdpbkRhdGEpO1xuICAgIGlmIChuYW1lICYmIGVsZW1lbnQpIHtcbiAgICAgIENyb3NzT3JpZ2luT2JzZXJ2ZWRFbGVtZW50U3RhdGUudHJpZ2dlcihcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICB0YWJzdGVyLmNyb3NzT3JpZ2luLm9ic2VydmVkRWxlbWVudCwgZWxlbWVudCwge1xuICAgICAgICBuYW1lczogW25hbWVdLFxuICAgICAgICBkZXRhaWxzOiBiZWdpbkRhdGEub2JzZXJ2ZWREZXRhaWxzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIGFzeW5jIF9tYWtlRGVhZFdpbmRvd1Jlc3BvbnNlKHRhYnN0ZXIsIGJlZ2luRGF0YSwgdHJhbnNhY3Rpb25zLCBmb3J3YXJkUmVzdWx0KSB7XG4gICAgY29uc3QgZGVhZFVJZCA9IGJlZ2luRGF0YSAmJiBiZWdpbkRhdGEub3duZXJVSWQ7XG4gICAgaWYgKGRlYWRVSWQpIHtcbiAgICAgIHRyYW5zYWN0aW9ucy5yZW1vdmVUYXJnZXQoZGVhZFVJZCk7XG4gICAgfVxuICAgIHJldHVybiBmb3J3YXJkUmVzdWx0LnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKGRlYWRVSWQgPT09IHRyYW5zYWN0aW9ucy5jdHguZm9jdXNPd25lcikge1xuICAgICAgICBjb25zdCBkZWxvc2VyQVBJID0gdGFic3Rlci5kZWxvc2VyO1xuICAgICAgICBpZiAoZGVsb3NlckFQSSkge1xuICAgICAgICAgIERlbG9zZXJBUEkuZm9yY2VSZXN0b3JlRm9jdXMoZGVsb3NlckFQSSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBhc3luYyBfbWFrZUtleWJvYXJkTmF2aWdhdGlvblJlc3BvbnNlKHRhYnN0ZXIsIGNvbnRleHQsIGlzTmF2aWdhdGluZ1dpdGhLZXlib2FyZCkge1xuICAgIGlmIChpc05hdmlnYXRpbmdXaXRoS2V5Ym9hcmQgIT09IHVuZGVmaW5lZCAmJiB0YWJzdGVyLmtleWJvYXJkTmF2aWdhdGlvbi5pc05hdmlnYXRpbmdXaXRoS2V5Ym9hcmQoKSAhPT0gaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkKSB7XG4gICAgICBjb250ZXh0Lmlnbm9yZUtleWJvYXJkTmF2aWdhdGlvblN0YXRlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHRhYnN0ZXIua2V5Ym9hcmROYXZpZ2F0aW9uLnNldE5hdmlnYXRpbmdXaXRoS2V5Ym9hcmQoaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkKTtcbiAgICAgIGNvbnRleHQuaWdub3JlS2V5Ym9hcmROYXZpZ2F0aW9uU3RhdGVVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIGFzeW5jIF9tYWtlT3V0bGluZVJlc3BvbnNlKHRhYnN0ZXIsIGNvbnRleHQsIHByb3BzKSB7XG4gICAgaWYgKGNvbnRleHQub3JpZ091dGxpbmVTZXR1cCkge1xuICAgICAgY29udGV4dC5vcmlnT3V0bGluZVNldHVwLmNhbGwoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgdGFic3Rlci5vdXRsaW5lLCBwcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jbGFzcyBHZXRFbGVtZW50VHJhbnNhY3Rpb24gZXh0ZW5kcyBDcm9zc09yaWdpblRyYW5zYWN0aW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSBDcm9zc09yaWdpblRyYW5zYWN0aW9uVHlwZXMuR2V0RWxlbWVudDtcbiAgfVxuICBzdGF0aWMgc2hvdWxkU2VsZlJlc3BvbmQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIGZpbmRFbGVtZW50KHRhYnN0ZXIsIGdldE93bmVyLCBkYXRhKSB7XG4gICAgbGV0IGVsZW1lbnQ7XG4gICAgaWYgKGRhdGEgJiYgKCFkYXRhLm93bmVySWQgfHwgZGF0YS5vd25lcklkID09PSBnZXRXaW5kb3dVSWQoZ2V0T3duZXIoKSkpKSB7XG4gICAgICBpZiAoZGF0YS5pZCkge1xuICAgICAgICBlbGVtZW50ID0gZG9tLmdldEVsZW1lbnRCeUlkKGdldE93bmVyKCkuZG9jdW1lbnQsIGRhdGEuaWQpO1xuICAgICAgICBpZiAoZWxlbWVudCAmJiBkYXRhLnJvb3RJZCkge1xuICAgICAgICAgIGNvbnN0IGN0eCA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGFic3RlciwgZWxlbWVudCk7XG4gICAgICAgICAgaWYgKCFjdHggfHwgY3R4LnJvb3QudWlkICE9PSBkYXRhLnJvb3RJZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudWlkKSB7XG4gICAgICAgIGNvbnN0IHJlZiA9IGdldEluc3RhbmNlQ29udGV4dChnZXRPd25lcikuZWxlbWVudEJ5VUlkW2RhdGEudWlkXTtcbiAgICAgICAgZWxlbWVudCA9IHJlZiAmJiByZWYuZ2V0KCk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEub2JzZXJ2ZWROYW1lKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGVsZW1lbnQgPSB0YWJzdGVyLm9ic2VydmVkRWxlbWVudC5nZXRFbGVtZW50KGRhdGEub2JzZXJ2ZWROYW1lLCBkYXRhLmFjY2Vzc2liaWxpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudCB8fCBudWxsO1xuICB9XG4gIHN0YXRpYyBnZXRFbGVtZW50RGF0YSh0YWJzdGVyLCBlbGVtZW50LCBnZXRPd25lciwgY29udGV4dCwgb3duZXJVSWQpIHtcbiAgICBjb25zdCBkZWxvc2VyID0gRGVsb3NlckFQSS5nZXREZWxvc2VyKHRhYnN0ZXIsIGVsZW1lbnQpO1xuICAgIGNvbnN0IGN0eCA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGFic3RlciwgZWxlbWVudCk7XG4gICAgY29uc3QgdGFic3Rlck9uRWxlbWVudCA9IGdldFRhYnN0ZXJPbkVsZW1lbnQodGFic3RlciwgZWxlbWVudCk7XG4gICAgY29uc3Qgb2JzZXJ2ZWQgPSB0YWJzdGVyT25FbGVtZW50ICYmIHRhYnN0ZXJPbkVsZW1lbnQub2JzZXJ2ZWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVpZDogZ2V0RWxlbWVudFVJZChnZXRPd25lciwgZWxlbWVudCksXG4gICAgICBvd25lclVJZCxcbiAgICAgIGlkOiBlbGVtZW50LmlkIHx8IHVuZGVmaW5lZCxcbiAgICAgIHJvb3RVSWQ6IGN0eCA/IGN0eC5yb290LnVpZCA6IHVuZGVmaW5lZCxcbiAgICAgIGRlbG9zZXJVSWQ6IGRlbG9zZXIgPyBnZXREZWxvc2VyVUlEKGdldE93bmVyLCBjb250ZXh0LCBkZWxvc2VyKSA6IHVuZGVmaW5lZCxcbiAgICAgIG9ic2VydmVkTmFtZTogb2JzZXJ2ZWQgJiYgb2JzZXJ2ZWQubmFtZXMgJiYgb2JzZXJ2ZWQubmFtZXNbMF0sXG4gICAgICBvYnNlcnZlZERldGFpbHM6IG9ic2VydmVkICYmIG9ic2VydmVkLmRldGFpbHNcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBhc3luYyBtYWtlUmVzcG9uc2UodGFic3RlciwgZGF0YSwgZ2V0T3duZXIsIG93bmVyVUlkLCB0cmFuc2FjdGlvbnMsIGZvcndhcmRSZXN1bHQpIHtcbiAgICBjb25zdCBiZWdpbkRhdGEgPSBkYXRhLmJlZ2luRGF0YTtcbiAgICBsZXQgZWxlbWVudDtcbiAgICBsZXQgZGF0YU91dDtcbiAgICBpZiAoYmVnaW5EYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVsZW1lbnQgPSB0YWJzdGVyLmZvY3VzZWRFbGVtZW50LmdldEZvY3VzZWRFbGVtZW50KCk7XG4gICAgfSBlbHNlIGlmIChiZWdpbkRhdGEpIHtcbiAgICAgIGVsZW1lbnQgPSBHZXRFbGVtZW50VHJhbnNhY3Rpb24uZmluZEVsZW1lbnQodGFic3RlciwgZ2V0T3duZXIsIGJlZ2luRGF0YSkgfHwgdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIWVsZW1lbnQgJiYgYmVnaW5EYXRhKSB7XG4gICAgICBjb25zdCBuYW1lID0gYmVnaW5EYXRhLm9ic2VydmVkTmFtZTtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBkYXRhLnRpbWVvdXQ7XG4gICAgICBjb25zdCBhY2Nlc3NpYmlsaXR5ID0gYmVnaW5EYXRhLmFjY2Vzc2liaWxpdHk7XG4gICAgICBpZiAobmFtZSAmJiB0aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGUgPSBhd2FpdCBuZXcgKGdldFByb21pc2UoZ2V0T3duZXIpKShyZXNvbHZlID0+IHtcbiAgICAgICAgICBsZXQgaXNXYWl0RWxlbWVudFJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgICAgbGV0IGlzRm9yd2FyZFJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgICAgbGV0IGlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgIHRhYnN0ZXIub2JzZXJ2ZWRFbGVtZW50LndhaXRFbGVtZW50KG5hbWUsIHRpbWVvdXQsIGFjY2Vzc2liaWxpdHkpLnJlc3VsdC50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIGlzV2FpdEVsZW1lbnRSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIWlzUmVzb2x2ZWQgJiYgKHZhbHVlIHx8IGlzRm9yd2FyZFJlc29sdmVkKSkge1xuICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yd2FyZFJlc3VsdC50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIGlzRm9yd2FyZFJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghaXNSZXNvbHZlZCAmJiAodmFsdWUgfHwgaXNXYWl0RWxlbWVudFJlc29sdmVkKSkge1xuICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGUuZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQgPSBlLmVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5jcm9zc09yaWdpbikge1xuICAgICAgICAgIGRhdGFPdXQgPSBlLmNyb3NzT3JpZ2luO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50ID8gR2V0RWxlbWVudFRyYW5zYWN0aW9uLmdldEVsZW1lbnREYXRhKHRhYnN0ZXIsIGVsZW1lbnQsIGdldE93bmVyLCB0cmFuc2FjdGlvbnMuY3R4LCBvd25lclVJZCkgOiBkYXRhT3V0O1xuICB9XG59XG5jbGFzcyBSZXN0b3JlRm9jdXNJbkRlbG9zZXJUcmFuc2FjdGlvbiBleHRlbmRzIENyb3NzT3JpZ2luVHJhbnNhY3Rpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IENyb3NzT3JpZ2luVHJhbnNhY3Rpb25UeXBlcy5SZXN0b3JlRm9jdXNJbkRlbG9zZXI7XG4gIH1cbiAgc3RhdGljIGFzeW5jIG1ha2VSZXNwb25zZSh0YWJzdGVyLCBkYXRhLCBnZXRPd25lciwgb3duZXJJZCwgdHJhbnNhY3Rpb25zLCBmb3J3YXJkUmVzdWx0KSB7XG4gICAgY29uc3QgZm9yd2FyZFJldCA9IGF3YWl0IGZvcndhcmRSZXN1bHQ7XG4gICAgY29uc3QgYmVnaW4gPSAhZm9yd2FyZFJldCAmJiBkYXRhLmJlZ2luRGF0YTtcbiAgICBjb25zdCB1aWQgPSBiZWdpbiAmJiBiZWdpbi5kZWxvc2VyVUlkO1xuICAgIGNvbnN0IGRlbG9zZXIgPSB1aWQgJiYgdHJhbnNhY3Rpb25zLmN0eC5kZWxvc2VyQnlVSWRbdWlkXTtcbiAgICBjb25zdCBkZWxvc2VyQVBJID0gdGFic3Rlci5kZWxvc2VyO1xuICAgIGlmIChiZWdpbiAmJiBkZWxvc2VyICYmIGRlbG9zZXJBUEkpIHtcbiAgICAgIGNvbnN0IGhpc3RvcnkgPSBEZWxvc2VyQVBJLmdldEhpc3RvcnkoZGVsb3NlckFQSSk7XG4gICAgICByZXR1cm4gYmVnaW4ucmVzZXQgPyBoaXN0b3J5LnJlc2V0Rm9jdXMoZGVsb3NlcikgOiBoaXN0b3J5LmZvY3VzQXZhaWxhYmxlKGRlbG9zZXIpO1xuICAgIH1cbiAgICByZXR1cm4gISFmb3J3YXJkUmV0O1xuICB9XG59XG5jbGFzcyBQaW5nVHJhbnNhY3Rpb24gZXh0ZW5kcyBDcm9zc09yaWdpblRyYW5zYWN0aW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSBDcm9zc09yaWdpblRyYW5zYWN0aW9uVHlwZXMuUGluZztcbiAgfVxuICBzdGF0aWMgc2hvdWxkRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGFzeW5jIG1ha2VSZXNwb25zZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgQ3Jvc3NPcmlnaW5UcmFuc2FjdGlvbnMge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyLCBnZXRPd25lciwgY29udGV4dCkge1xuICAgIHRoaXMuX2tub3duVGFyZ2V0cyA9IHt9O1xuICAgIHRoaXMuX3RyYW5zYWN0aW9ucyA9IHt9O1xuICAgIHRoaXMuX2lzRGVmYXVsdFNlbmRVcCA9IGZhbHNlO1xuICAgIHRoaXMuaXNTZXRVcCA9IGZhbHNlO1xuICAgIHRoaXMuX29uTWVzc2FnZSA9IGUgPT4ge1xuICAgICAgaWYgKGUuZGF0YS5vd25lciA9PT0gdGhpcy5fb3duZXJVSWQgfHwgIXRoaXMuX3RhYnN0ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgIGNvbnN0IGRhdGEgPSBlLmRhdGE7XG4gICAgICBsZXQgdHJhbnNhY3Rpb25JZDtcbiAgICAgIGlmICghZGF0YSB8fCAhKHRyYW5zYWN0aW9uSWQgPSBkYXRhLnRyYW5zYWN0aW9uKSB8fCAhZGF0YS50eXBlIHx8ICFkYXRhLnRpbWVzdGFtcCB8fCAhZGF0YS5vd25lciB8fCAhZGF0YS5zZW50dG8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGtub3duVGFyZ2V0ID0gdGhpcy5fa25vd25UYXJnZXRzW2RhdGEub3duZXJdO1xuICAgICAgaWYgKCFrbm93blRhcmdldCAmJiBlLnNlbmQgJiYgZGF0YS5vd25lciAhPT0gdGhpcy5fb3duZXJVSWQpIHtcbiAgICAgICAga25vd25UYXJnZXQgPSB0aGlzLl9rbm93blRhcmdldHNbZGF0YS5vd25lcl0gPSB7XG4gICAgICAgICAgc2VuZDogZS5zZW5kXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoa25vd25UYXJnZXQpIHtcbiAgICAgICAga25vd25UYXJnZXQubGFzdCA9IERhdGUubm93KCk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5pc1Jlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLl90cmFuc2FjdGlvbnNbdHJhbnNhY3Rpb25JZF07XG4gICAgICAgIGlmICh0ICYmIHQudHJhbnNhY3Rpb24gJiYgdC50cmFuc2FjdGlvbi50eXBlID09PSBkYXRhLnR5cGUpIHtcbiAgICAgICAgICB0LnRyYW5zYWN0aW9uLm9uUmVzcG9uc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IFRyYW5zYWN0aW9uID0gdGhpcy5fZ2V0VHJhbnNhY3Rpb25DbGFzcyhkYXRhLnR5cGUpO1xuICAgICAgICBjb25zdCBmb3J3YXJkUmVzdWx0ID0gdGhpcy5mb3J3YXJkVHJhbnNhY3Rpb24oZGF0YSk7XG4gICAgICAgIGlmIChUcmFuc2FjdGlvbiAmJiBlLnNlbmQpIHtcbiAgICAgICAgICBUcmFuc2FjdGlvbi5tYWtlUmVzcG9uc2UodGhpcy5fdGFic3RlciwgZGF0YSwgdGhpcy5fb3duZXIsIHRoaXMuX293bmVyVUlkLCB0aGlzLCBmb3J3YXJkUmVzdWx0LCBmYWxzZSkudGhlbihyID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IGRhdGEudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICAgICAgICAgICAgaXNSZXNwb25zZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICBvd25lcjogdGhpcy5fb3duZXJVSWQsXG4gICAgICAgICAgICAgIHRpbWVvdXQ6IGRhdGEudGltZW91dCxcbiAgICAgICAgICAgICAgc2VudHRvOiB7fSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiBkYXRhLnRhcmdldCA9PT0gX3RhcmdldElkVXAgPyBfdGFyZ2V0SWRVcCA6IGRhdGEub3duZXIsXG4gICAgICAgICAgICAgIGVuZERhdGE6IHJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBlLnNlbmQocmVzcG9uc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vblBhZ2VIaWRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZGVhZCgpO1xuICAgIH07XG4gICAgdGhpcy5fb25Ccm93c2VyTWVzc2FnZSA9IGUgPT4ge1xuICAgICAgaWYgKGUuc291cmNlID09PSB0aGlzLl9vd25lcigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICBjb25zdCBzZW5kID0gZGF0YSA9PiB7XG4gICAgICAgIGlmIChlLnNvdXJjZSAmJiBlLnNvdXJjZS5wb3N0TWVzc2FnZSkge1xuICAgICAgICAgIGUuc291cmNlLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KGRhdGEpLCBcIipcIik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9vbk1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IEpTT04ucGFyc2UoZS5kYXRhKSxcbiAgICAgICAgICBzZW5kXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIElnbm9yZSAqL1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gICAgdGhpcy5fb3duZXIgPSBnZXRPd25lcjtcbiAgICB0aGlzLl9vd25lclVJZCA9IGdldFdpbmRvd1VJZChnZXRPd25lcigpKTtcbiAgICB0aGlzLmN0eCA9IGNvbnRleHQ7XG4gIH1cbiAgc2V0dXAoc2VuZFVwKSB7XG4gICAgaWYgKHRoaXMuaXNTZXRVcCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDcm9zc09yaWdpbiBpcyBhbHJlYWR5IHNldCB1cC5cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNTZXRVcCA9IHRydWU7XG4gICAgICB0aGlzLnNldFNlbmRVcChzZW5kVXApO1xuICAgICAgdGhpcy5fb3duZXIoKS5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgdGhpcy5fb25QYWdlSGlkZSk7XG4gICAgICB0aGlzLl9waW5nKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9vbk1lc3NhZ2U7XG4gIH1cbiAgc2V0U2VuZFVwKHNlbmRVcCkge1xuICAgIGlmICghdGhpcy5pc1NldFVwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDcm9zc09yaWdpbiBpcyBub3Qgc2V0IHVwLlwiKTtcbiAgICB9XG4gICAgdGhpcy5zZW5kVXAgPSBzZW5kVXAgfHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IG93bmVyID0gdGhpcy5fb3duZXIoKTtcbiAgICBpZiAoc2VuZFVwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghdGhpcy5faXNEZWZhdWx0U2VuZFVwKSB7XG4gICAgICAgIGlmIChvd25lci5kb2N1bWVudCkge1xuICAgICAgICAgIHRoaXMuX2lzRGVmYXVsdFNlbmRVcCA9IHRydWU7XG4gICAgICAgICAgaWYgKG93bmVyLnBhcmVudCAmJiBvd25lci5wYXJlbnQgIT09IG93bmVyICYmIG93bmVyLnBhcmVudC5wb3N0TWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5zZW5kVXAgPSAoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBvd25lci5wYXJlbnQucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoZGF0YSksIFwiKlwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIG93bmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uQnJvd3Nlck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9pc0RlZmF1bHRTZW5kVXApIHtcbiAgICAgIG93bmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uQnJvd3Nlck1lc3NhZ2UpO1xuICAgICAgdGhpcy5faXNEZWZhdWx0U2VuZFVwID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9vbk1lc3NhZ2U7XG4gIH1cbiAgYXN5bmMgZGlzcG9zZSgpIHtcbiAgICBjb25zdCBvd25lciA9IHRoaXMuX293bmVyKCk7XG4gICAgaWYgKHRoaXMuX3BpbmdUaW1lcikge1xuICAgICAgb3duZXIuY2xlYXJUaW1lb3V0KHRoaXMuX3BpbmdUaW1lcik7XG4gICAgICB0aGlzLl9waW5nVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG93bmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uQnJvd3Nlck1lc3NhZ2UpO1xuICAgIG93bmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCB0aGlzLl9vblBhZ2VIaWRlKTtcbiAgICBhd2FpdCB0aGlzLl9kZWFkKCk7XG4gICAgZGVsZXRlIHRoaXMuX2RlYWRQcm9taXNlO1xuICAgIGZvciAoY29uc3QgaWQgb2YgT2JqZWN0LmtleXModGhpcy5fdHJhbnNhY3Rpb25zKSkge1xuICAgICAgY29uc3QgdCA9IHRoaXMuX3RyYW5zYWN0aW9uc1tpZF07XG4gICAgICBpZiAodC50aW1lcikge1xuICAgICAgICBvd25lci5jbGVhclRpbWVvdXQodC50aW1lcik7XG4gICAgICAgIGRlbGV0ZSB0LnRpbWVyO1xuICAgICAgfVxuICAgICAgdC50cmFuc2FjdGlvbi5lbmQoKTtcbiAgICB9XG4gICAgdGhpcy5fa25vd25UYXJnZXRzID0ge307XG4gICAgZGVsZXRlIHRoaXMuc2VuZFVwO1xuICB9XG4gIGJlZ2luVHJhbnNhY3Rpb24oVHJhbnNhY3Rpb24sIHZhbHVlLCB0aW1lb3V0LCBzZW50VG8sIHRhcmdldElkLCB3aXRoUmVqZWN0KSB7XG4gICAgaWYgKCF0aGlzLl9vd25lcikge1xuICAgICAgcmV0dXJuIGdldFByb21pc2UodGhpcy5fb3duZXIpLnJlamVjdCgpO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbih0aGlzLl90YWJzdGVyLCB0aGlzLl9vd25lciwgdGhpcy5fa25vd25UYXJnZXRzLCB2YWx1ZSwgdGltZW91dCwgc2VudFRvLCB0YXJnZXRJZCwgdGhpcy5zZW5kVXApO1xuICAgIGxldCBzZWxmUmVzcG9uc2U7XG4gICAgaWYgKFRyYW5zYWN0aW9uLnNob3VsZFNlbGZSZXNwb25kICYmIFRyYW5zYWN0aW9uLnNob3VsZFNlbGZSZXNwb25kKHRoaXMuX3RhYnN0ZXIsIHZhbHVlLCB0aGlzLl9vd25lciwgdGhpcy5fb3duZXJVSWQpKSB7XG4gICAgICBzZWxmUmVzcG9uc2UgPSBkYXRhID0+IHtcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uLm1ha2VSZXNwb25zZSh0aGlzLl90YWJzdGVyLCBkYXRhLCB0aGlzLl9vd25lciwgdGhpcy5fb3duZXJVSWQsIHRoaXMsIGdldFByb21pc2UodGhpcy5fb3duZXIpLnJlc29sdmUodW5kZWZpbmVkKSwgdHJ1ZSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYmVnaW5UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgdGltZW91dCwgc2VsZlJlc3BvbnNlLCB3aXRoUmVqZWN0KTtcbiAgfVxuICByZW1vdmVUYXJnZXQodWlkKSB7XG4gICAgZGVsZXRlIHRoaXMuX2tub3duVGFyZ2V0c1t1aWRdO1xuICB9XG4gIF9iZWdpblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCB0aW1lb3V0LCBzZWxmUmVzcG9uc2UsIHdpdGhSZWplY3QpIHtcbiAgICBjb25zdCBvd25lciA9IHRoaXMuX293bmVyKCk7XG4gICAgY29uc3Qgd3JhcHBlciA9IHtcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgdGltZXI6IG93bmVyLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkZWxldGUgd3JhcHBlci50aW1lcjtcbiAgICAgICAgdHJhbnNhY3Rpb24uZW5kKFwiQ3Jvc3Mgb3JpZ2luIHRyYW5zYWN0aW9uIHRpbWVkIG91dC5cIik7XG4gICAgICB9LCBfdHJhbnNhY3Rpb25UaW1lb3V0ICsgKHRpbWVvdXQgfHwgMCkpXG4gICAgfTtcbiAgICB0aGlzLl90cmFuc2FjdGlvbnNbdHJhbnNhY3Rpb24uaWRdID0gd3JhcHBlcjtcbiAgICBjb25zdCByZXQgPSB0cmFuc2FjdGlvbi5iZWdpbihzZWxmUmVzcG9uc2UpO1xuICAgIHJldC5jYXRjaCgoKSA9PiB7XG4gICAgICAvKiovXG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBpZiAod3JhcHBlci50aW1lcikge1xuICAgICAgICBvd25lci5jbGVhclRpbWVvdXQod3JhcHBlci50aW1lcik7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5fdHJhbnNhY3Rpb25zW3RyYW5zYWN0aW9uLmlkXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0LnRoZW4odmFsdWUgPT4gdmFsdWUsIHdpdGhSZWplY3QgPyB1bmRlZmluZWQgOiAoKSA9PiB1bmRlZmluZWQpO1xuICB9XG4gIGZvcndhcmRUcmFuc2FjdGlvbihcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgZGF0YVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICApIHtcbiAgICBjb25zdCBvd25lciA9IHRoaXMuX293bmVyO1xuICAgIGxldCB0YXJnZXRJZCA9IGRhdGEudGFyZ2V0O1xuICAgIGlmICh0YXJnZXRJZCA9PT0gdGhpcy5fb3duZXJVSWQpIHtcbiAgICAgIHJldHVybiBnZXRQcm9taXNlKG93bmVyKS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IFRyYW5zYWN0aW9uID0gdGhpcy5fZ2V0VHJhbnNhY3Rpb25DbGFzcyhkYXRhLnR5cGUpO1xuICAgIGlmIChUcmFuc2FjdGlvbikge1xuICAgICAgaWYgKFRyYW5zYWN0aW9uLnNob3VsZEZvcndhcmQgPT09IHVuZGVmaW5lZCB8fCBUcmFuc2FjdGlvbi5zaG91bGRGb3J3YXJkKHRoaXMuX3RhYnN0ZXIsIGRhdGEsIG93bmVyLCB0aGlzLl9vd25lclVJZCkpIHtcbiAgICAgICAgY29uc3Qgc2VudFRvID0gZGF0YS5zZW50dG87XG4gICAgICAgIGlmICh0YXJnZXRJZCA9PT0gX3RhcmdldElkVXApIHtcbiAgICAgICAgICB0YXJnZXRJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBzZW50VG9bdGhpcy5fb3duZXJVSWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc2VudFRvW190YXJnZXRJZFVwXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JlZ2luVHJhbnNhY3Rpb24obmV3IFRyYW5zYWN0aW9uKHRoaXMuX3RhYnN0ZXIsIG93bmVyLCB0aGlzLl9rbm93blRhcmdldHMsIGRhdGEuYmVnaW5EYXRhLCBkYXRhLnRpbWVvdXQsIHNlbnRUbywgdGFyZ2V0SWQsIHRoaXMuc2VuZFVwKSwgZGF0YS50aW1lb3V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRQcm9taXNlKG93bmVyKS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZXRQcm9taXNlKG93bmVyKS5yZWplY3QoYFVua25vd24gdHJhbnNhY3Rpb24gdHlwZSAke2RhdGEudHlwZX1gKTtcbiAgfVxuICBfZ2V0VHJhbnNhY3Rpb25DbGFzcyh0eXBlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBDcm9zc09yaWdpblRyYW5zYWN0aW9uVHlwZXMuQm9vdHN0cmFwOlxuICAgICAgICByZXR1cm4gQm9vdHN0cmFwVHJhbnNhY3Rpb247XG4gICAgICBjYXNlIENyb3NzT3JpZ2luVHJhbnNhY3Rpb25UeXBlcy5Gb2N1c0VsZW1lbnQ6XG4gICAgICAgIHJldHVybiBGb2N1c0VsZW1lbnRUcmFuc2FjdGlvbjtcbiAgICAgIGNhc2UgQ3Jvc3NPcmlnaW5UcmFuc2FjdGlvblR5cGVzLlN0YXRlOlxuICAgICAgICByZXR1cm4gU3RhdGVUcmFuc2FjdGlvbjtcbiAgICAgIGNhc2UgQ3Jvc3NPcmlnaW5UcmFuc2FjdGlvblR5cGVzLkdldEVsZW1lbnQ6XG4gICAgICAgIHJldHVybiBHZXRFbGVtZW50VHJhbnNhY3Rpb247XG4gICAgICBjYXNlIENyb3NzT3JpZ2luVHJhbnNhY3Rpb25UeXBlcy5SZXN0b3JlRm9jdXNJbkRlbG9zZXI6XG4gICAgICAgIHJldHVybiBSZXN0b3JlRm9jdXNJbkRlbG9zZXJUcmFuc2FjdGlvbjtcbiAgICAgIGNhc2UgQ3Jvc3NPcmlnaW5UcmFuc2FjdGlvblR5cGVzLlBpbmc6XG4gICAgICAgIHJldHVybiBQaW5nVHJhbnNhY3Rpb247XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX2RlYWQoKSB7XG4gICAgaWYgKCF0aGlzLl9kZWFkUHJvbWlzZSAmJiB0aGlzLmN0eC5mb2N1c093bmVyID09PSB0aGlzLl9vd25lclVJZCkge1xuICAgICAgdGhpcy5fZGVhZFByb21pc2UgPSB0aGlzLmJlZ2luVHJhbnNhY3Rpb24oU3RhdGVUcmFuc2FjdGlvbiwge1xuICAgICAgICBvd25lclVJZDogdGhpcy5fb3duZXJVSWQsXG4gICAgICAgIHN0YXRlOiBDcm9zc09yaWdpblN0YXRlcy5EZWFkV2luZG93XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RlYWRQcm9taXNlKSB7XG4gICAgICBhd2FpdCB0aGlzLl9kZWFkUHJvbWlzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX3BpbmcoKSB7XG4gICAgaWYgKHRoaXMuX3BpbmdUaW1lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZGVhZFdpbmRvd3M7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0YXJnZXRzID0gT2JqZWN0LmtleXModGhpcy5fa25vd25UYXJnZXRzKS5maWx0ZXIodWlkID0+IG5vdyAtICh0aGlzLl9rbm93blRhcmdldHNbdWlkXS5sYXN0IHx8IDApID4gX3BpbmdUaW1lb3V0KTtcbiAgICBpZiAodGhpcy5zZW5kVXApIHtcbiAgICAgIHRhcmdldHMucHVzaChfdGFyZ2V0SWRVcCk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRzLmxlbmd0aCkge1xuICAgICAgYXdhaXQgZ2V0UHJvbWlzZSh0aGlzLl9vd25lcikuYWxsKHRhcmdldHMubWFwKHVpZCA9PiB0aGlzLmJlZ2luVHJhbnNhY3Rpb24oUGluZ1RyYW5zYWN0aW9uLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1aWQsIHRydWUpLnRoZW4oKCkgPT4gdHJ1ZSwgKCkgPT4ge1xuICAgICAgICBpZiAodWlkICE9PSBfdGFyZ2V0SWRVcCkge1xuICAgICAgICAgIGlmICghZGVhZFdpbmRvd3MpIHtcbiAgICAgICAgICAgIGRlYWRXaW5kb3dzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlYWRXaW5kb3dzW3VpZF0gPSB0cnVlO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9rbm93blRhcmdldHNbdWlkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KSkpO1xuICAgIH1cbiAgICBpZiAoZGVhZFdpbmRvd3MpIHtcbiAgICAgIGNvbnN0IGZvY3VzZWQgPSBhd2FpdCB0aGlzLmJlZ2luVHJhbnNhY3Rpb24oR2V0RWxlbWVudFRyYW5zYWN0aW9uLCB1bmRlZmluZWQpO1xuICAgICAgaWYgKCFmb2N1c2VkICYmIHRoaXMuY3R4LmZvY3VzT3duZXIgJiYgdGhpcy5jdHguZm9jdXNPd25lciBpbiBkZWFkV2luZG93cykge1xuICAgICAgICBhd2FpdCB0aGlzLmJlZ2luVHJhbnNhY3Rpb24oU3RhdGVUcmFuc2FjdGlvbiwge1xuICAgICAgICAgIG93bmVyVUlkOiB0aGlzLl9vd25lclVJZCxcbiAgICAgICAgICBzdGF0ZTogQ3Jvc3NPcmlnaW5TdGF0ZXMuQmx1cnJlZCxcbiAgICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGVsb3NlckFQSSA9IHRoaXMuX3RhYnN0ZXIuZGVsb3NlcjtcbiAgICAgICAgaWYgKGRlbG9zZXJBUEkpIHtcbiAgICAgICAgICBEZWxvc2VyQVBJLmZvcmNlUmVzdG9yZUZvY3VzKGRlbG9zZXJBUEkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3BpbmdUaW1lciA9IHRoaXMuX293bmVyKCkuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9waW5nVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9waW5nKCk7XG4gICAgfSwgX3BpbmdUaW1lb3V0KTtcbiAgfVxufVxuY2xhc3MgQ3Jvc3NPcmlnaW5FbGVtZW50IHtcbiAgY29uc3RydWN0b3IodGFic3RlciwgdWlkLCBvd25lcklkLCBpZCwgcm9vdElkLCBvYnNlcnZlZE5hbWUsIG9ic2VydmVkRGV0YWlscykge1xuICAgIHRoaXMuX3RhYnN0ZXIgPSB0YWJzdGVyO1xuICAgIHRoaXMudWlkID0gdWlkO1xuICAgIHRoaXMub3duZXJJZCA9IG93bmVySWQ7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMucm9vdElkID0gcm9vdElkO1xuICAgIHRoaXMub2JzZXJ2ZWROYW1lID0gb2JzZXJ2ZWROYW1lO1xuICAgIHRoaXMub2JzZXJ2ZWREZXRhaWxzID0gb2JzZXJ2ZWREZXRhaWxzO1xuICB9XG4gIGZvY3VzKG5vRm9jdXNlZFByb2dyYW1tYXRpY2FsbHlGbGFnLCBub0FjY2Vzc2libGVDaGVjaykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgcmV0dXJuIHRoaXMuX3RhYnN0ZXIuY3Jvc3NPcmlnaW4uZm9jdXNlZEVsZW1lbnQuZm9jdXModGhpcywgbm9Gb2N1c2VkUHJvZ3JhbW1hdGljYWxseUZsYWcsIG5vQWNjZXNzaWJsZUNoZWNrKTtcbiAgfVxufVxuY2xhc3MgQ3Jvc3NPcmlnaW5Gb2N1c2VkRWxlbWVudFN0YXRlIGV4dGVuZHMgU3Vic2NyaWJhYmxlIHtcbiAgY29uc3RydWN0b3IodHJhbnNhY3Rpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl90cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnM7XG4gIH1cbiAgYXN5bmMgZm9jdXMoZWxlbWVudCwgbm9Gb2N1c2VkUHJvZ3JhbW1hdGljYWxseUZsYWcsIG5vQWNjZXNzaWJsZUNoZWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvY3VzKHtcbiAgICAgIHVpZDogZWxlbWVudC51aWQsXG4gICAgICBpZDogZWxlbWVudC5pZCxcbiAgICAgIHJvb3RJZDogZWxlbWVudC5yb290SWQsXG4gICAgICBvd25lcklkOiBlbGVtZW50Lm93bmVySWQsXG4gICAgICBvYnNlcnZlZE5hbWU6IGVsZW1lbnQub2JzZXJ2ZWROYW1lXG4gICAgfSwgbm9Gb2N1c2VkUHJvZ3JhbW1hdGljYWxseUZsYWcsIG5vQWNjZXNzaWJsZUNoZWNrKTtcbiAgfVxuICBhc3luYyBmb2N1c0J5SWQoZWxlbWVudElkLCByb290SWQsIG5vRm9jdXNlZFByb2dyYW1tYXRpY2FsbHlGbGFnLCBub0FjY2Vzc2libGVDaGVjaykge1xuICAgIHJldHVybiB0aGlzLl9mb2N1cyh7XG4gICAgICBpZDogZWxlbWVudElkLFxuICAgICAgcm9vdElkXG4gICAgfSwgbm9Gb2N1c2VkUHJvZ3JhbW1hdGljYWxseUZsYWcsIG5vQWNjZXNzaWJsZUNoZWNrKTtcbiAgfVxuICBhc3luYyBmb2N1c0J5T2JzZXJ2ZWROYW1lKG9ic2VydmVkTmFtZSwgdGltZW91dCwgcm9vdElkLCBub0ZvY3VzZWRQcm9ncmFtbWF0aWNhbGx5RmxhZywgbm9BY2Nlc3NpYmxlQ2hlY2spIHtcbiAgICByZXR1cm4gdGhpcy5fZm9jdXMoe1xuICAgICAgb2JzZXJ2ZWROYW1lLFxuICAgICAgcm9vdElkXG4gICAgfSwgbm9Gb2N1c2VkUHJvZ3JhbW1hdGljYWxseUZsYWcsIG5vQWNjZXNzaWJsZUNoZWNrLCB0aW1lb3V0KTtcbiAgfVxuICBhc3luYyBfZm9jdXMoZWxlbWVudERhdGEsIG5vRm9jdXNlZFByb2dyYW1tYXRpY2FsbHlGbGFnLCBub0FjY2Vzc2libGVDaGVjaywgdGltZW91dCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbnMuYmVnaW5UcmFuc2FjdGlvbihGb2N1c0VsZW1lbnRUcmFuc2FjdGlvbiwge1xuICAgICAgLi4uZWxlbWVudERhdGEsXG4gICAgICBub0ZvY3VzZWRQcm9ncmFtbWF0aWNhbGx5RmxhZyxcbiAgICAgIG5vQWNjZXNzaWJsZUNoZWNrXG4gICAgfSwgdGltZW91dCkudGhlbih2YWx1ZSA9PiAhIXZhbHVlKTtcbiAgfVxuICBzdGF0aWMgc2V0VmFsKGluc3RhbmNlLCB2YWwsIGRldGFpbCkge1xuICAgIGluc3RhbmNlLnNldFZhbCh2YWwsIGRldGFpbCk7XG4gIH1cbn1cbmNsYXNzIENyb3NzT3JpZ2luT2JzZXJ2ZWRFbGVtZW50U3RhdGUgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyLCB0cmFuc2FjdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2xhc3RSZXF1ZXN0Rm9jdXNJZCA9IDA7XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gICAgdGhpcy5fdHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zO1xuICB9XG4gIGFzeW5jIGdldEVsZW1lbnQob2JzZXJ2ZWROYW1lLCBhY2Nlc3NpYmlsaXR5KSB7XG4gICAgcmV0dXJuIHRoaXMud2FpdEVsZW1lbnQob2JzZXJ2ZWROYW1lLCAwLCBhY2Nlc3NpYmlsaXR5KTtcbiAgfVxuICBhc3luYyB3YWl0RWxlbWVudChvYnNlcnZlZE5hbWUsIHRpbWVvdXQsIGFjY2Vzc2liaWxpdHkpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25zLmJlZ2luVHJhbnNhY3Rpb24oR2V0RWxlbWVudFRyYW5zYWN0aW9uLCB7XG4gICAgICBvYnNlcnZlZE5hbWUsXG4gICAgICBhY2Nlc3NpYmlsaXR5XG4gICAgfSwgdGltZW91dCkudGhlbih2YWx1ZSA9PiB2YWx1ZSA/IFN0YXRlVHJhbnNhY3Rpb24uY3JlYXRlRWxlbWVudCh0aGlzLl90YWJzdGVyLCB2YWx1ZSkgOiBudWxsKTtcbiAgfVxuICBhc3luYyByZXF1ZXN0Rm9jdXMob2JzZXJ2ZWROYW1lLCB0aW1lb3V0KSB7XG4gICAgY29uc3QgcmVxdWVzdElkID0gKyt0aGlzLl9sYXN0UmVxdWVzdEZvY3VzSWQ7XG4gICAgcmV0dXJuIHRoaXMud2FpdEVsZW1lbnQob2JzZXJ2ZWROYW1lLCB0aW1lb3V0LCBPYnNlcnZlZEVsZW1lbnRBY2Nlc3NpYmlsaXRpZXMuRm9jdXNhYmxlKS50aGVuKGVsZW1lbnQgPT4gdGhpcy5fbGFzdFJlcXVlc3RGb2N1c0lkID09PSByZXF1ZXN0SWQgJiYgZWxlbWVudCA/XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICB0aGlzLl90YWJzdGVyLmNyb3NzT3JpZ2luLmZvY3VzZWRFbGVtZW50LmZvY3VzKGVsZW1lbnQsIHRydWUpIDogZmFsc2UpO1xuICB9XG4gIHN0YXRpYyB0cmlnZ2VyKGluc3RhbmNlLCBlbGVtZW50LCBkZXRhaWxzKSB7XG4gICAgaW5zdGFuY2UudHJpZ2dlcihlbGVtZW50LCBkZXRhaWxzKTtcbiAgfVxufVxuY2xhc3MgQ3Jvc3NPcmlnaW5BUEkge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyKSB7XG4gICAgdGhpcy5faW5pdCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHRhYnN0ZXIgPSB0aGlzLl90YWJzdGVyO1xuICAgICAgdGFic3Rlci5rZXlib2FyZE5hdmlnYXRpb24uc3Vic2NyaWJlKHRoaXMuX29uS2V5Ym9hcmROYXZpZ2F0aW9uU3RhdGVDaGFuZ2VkKTtcbiAgICAgIHRhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuc3Vic2NyaWJlKHRoaXMuX29uRm9jdXMpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgIHRhYnN0ZXIub2JzZXJ2ZWRFbGVtZW50LnN1YnNjcmliZSh0aGlzLl9vbk9ic2VydmVkKTtcbiAgICAgIGlmICghdGhpcy5fY3R4Lm9yaWdPdXRsaW5lU2V0dXApIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgdGhpcy5fY3R4Lm9yaWdPdXRsaW5lU2V0dXAgPSB0YWJzdGVyLm91dGxpbmUuc2V0dXA7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIHRhYnN0ZXIub3V0bGluZS5zZXR1cCA9IHRoaXMuX291dGxpbmVTZXR1cDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RyYW5zYWN0aW9ucy5iZWdpblRyYW5zYWN0aW9uKEJvb3RzdHJhcFRyYW5zYWN0aW9uLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBfdGFyZ2V0SWRVcCkudGhlbihkYXRhID0+IHtcbiAgICAgICAgaWYgKGRhdGEgJiYgdGhpcy5fdGFic3Rlci5rZXlib2FyZE5hdmlnYXRpb24uaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkKCkgIT09IGRhdGEuaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkKSB7XG4gICAgICAgICAgdGhpcy5fY3R4Lmlnbm9yZUtleWJvYXJkTmF2aWdhdGlvblN0YXRlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl90YWJzdGVyLmtleWJvYXJkTmF2aWdhdGlvbi5zZXROYXZpZ2F0aW5nV2l0aEtleWJvYXJkKGRhdGEuaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkKTtcbiAgICAgICAgICB0aGlzLl9jdHguaWdub3JlS2V5Ym9hcmROYXZpZ2F0aW9uU3RhdGVVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLl9vbktleWJvYXJkTmF2aWdhdGlvblN0YXRlQ2hhbmdlZCA9IHZhbHVlID0+IHtcbiAgICAgIGlmICghdGhpcy5fY3R4Lmlnbm9yZUtleWJvYXJkTmF2aWdhdGlvblN0YXRlVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9ucy5iZWdpblRyYW5zYWN0aW9uKFN0YXRlVHJhbnNhY3Rpb24sIHtcbiAgICAgICAgICBzdGF0ZTogQ3Jvc3NPcmlnaW5TdGF0ZXMuS2V5Ym9hcmROYXZpZ2F0aW9uLFxuICAgICAgICAgIG93bmVyVUlkOiBnZXRXaW5kb3dVSWQodGhpcy5fd2luKCkpLFxuICAgICAgICAgIGlzTmF2aWdhdGluZ1dpdGhLZXlib2FyZDogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbkZvY3VzID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCB3aW4gPSB0aGlzLl93aW4oKTtcbiAgICAgIGNvbnN0IG93bmVyVUlkID0gZ2V0V2luZG93VUlkKHdpbik7XG4gICAgICBpZiAodGhpcy5fYmx1clRpbWVyKSB7XG4gICAgICAgIHdpbi5jbGVhclRpbWVvdXQodGhpcy5fYmx1clRpbWVyKTtcbiAgICAgICAgdGhpcy5fYmx1clRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25zLmJlZ2luVHJhbnNhY3Rpb24oU3RhdGVUcmFuc2FjdGlvbiwge1xuICAgICAgICAgIC4uLkdldEVsZW1lbnRUcmFuc2FjdGlvbi5nZXRFbGVtZW50RGF0YSh0aGlzLl90YWJzdGVyLCBlbGVtZW50LCB0aGlzLl93aW4sIHRoaXMuX2N0eCwgb3duZXJVSWQpLFxuICAgICAgICAgIHN0YXRlOiBDcm9zc09yaWdpblN0YXRlcy5Gb2N1c2VkXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYmx1clRpbWVyID0gd2luLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2JsdXJUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAodGhpcy5fY3R4LmZvY3VzT3duZXIgJiYgdGhpcy5fY3R4LmZvY3VzT3duZXIgPT09IG93bmVyVUlkKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2FjdGlvbnMuYmVnaW5UcmFuc2FjdGlvbihHZXRFbGVtZW50VHJhbnNhY3Rpb24sIHVuZGVmaW5lZCkudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgIGlmICghdmFsdWUgJiYgdGhpcy5fY3R4LmZvY3VzT3duZXIgPT09IG93bmVyVUlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25zLmJlZ2luVHJhbnNhY3Rpb24oU3RhdGVUcmFuc2FjdGlvbiwge1xuICAgICAgICAgICAgICAgICAgb3duZXJVSWQsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogQ3Jvc3NPcmlnaW5TdGF0ZXMuQmx1cnJlZCxcbiAgICAgICAgICAgICAgICAgIGZvcmNlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25PYnNlcnZlZCA9IChlbGVtZW50LCBkZXRhaWxzKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBkID0gR2V0RWxlbWVudFRyYW5zYWN0aW9uLmdldEVsZW1lbnREYXRhKHRoaXMuX3RhYnN0ZXIsIGVsZW1lbnQsIHRoaXMuX3dpbiwgdGhpcy5fY3R4LCBnZXRXaW5kb3dVSWQodGhpcy5fd2luKCkpKTtcbiAgICAgIGQuc3RhdGUgPSBDcm9zc09yaWdpblN0YXRlcy5PYnNlcnZlZDtcbiAgICAgIGQub2JzZXJ2ZWROYW1lID0gKF9hID0gZGV0YWlscy5uYW1lcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdO1xuICAgICAgZC5vYnNlcnZlZERldGFpbHMgPSBkZXRhaWxzLmRldGFpbHM7XG4gICAgICB0aGlzLl90cmFuc2FjdGlvbnMuYmVnaW5UcmFuc2FjdGlvbihTdGF0ZVRyYW5zYWN0aW9uLCBkKTtcbiAgICB9O1xuICAgIHRoaXMuX291dGxpbmVTZXR1cCA9IHByb3BzID0+IHtcbiAgICAgIHRoaXMuX3RyYW5zYWN0aW9ucy5iZWdpblRyYW5zYWN0aW9uKFN0YXRlVHJhbnNhY3Rpb24sIHtcbiAgICAgICAgc3RhdGU6IENyb3NzT3JpZ2luU3RhdGVzLk91dGxpbmUsXG4gICAgICAgIG93bmVyVUlkOiBnZXRXaW5kb3dVSWQodGhpcy5fd2luKCkpLFxuICAgICAgICBvdXRsaW5lOiBwcm9wc1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLl90YWJzdGVyID0gdGFic3RlcjtcbiAgICB0aGlzLl93aW4gPSB0YWJzdGVyLmdldFdpbmRvdztcbiAgICB0aGlzLl9jdHggPSB7XG4gICAgICBpZ25vcmVLZXlib2FyZE5hdmlnYXRpb25TdGF0ZVVwZGF0ZTogZmFsc2UsXG4gICAgICBkZWxvc2VyQnlVSWQ6IHt9XG4gICAgfTtcbiAgICB0aGlzLl90cmFuc2FjdGlvbnMgPSBuZXcgQ3Jvc3NPcmlnaW5UcmFuc2FjdGlvbnModGFic3RlciwgdGhpcy5fd2luLCB0aGlzLl9jdHgpO1xuICAgIHRoaXMuZm9jdXNlZEVsZW1lbnQgPSBuZXcgQ3Jvc3NPcmlnaW5Gb2N1c2VkRWxlbWVudFN0YXRlKHRoaXMuX3RyYW5zYWN0aW9ucyk7XG4gICAgdGhpcy5vYnNlcnZlZEVsZW1lbnQgPSBuZXcgQ3Jvc3NPcmlnaW5PYnNlcnZlZEVsZW1lbnRTdGF0ZSh0YWJzdGVyLCB0aGlzLl90cmFuc2FjdGlvbnMpO1xuICB9XG4gIHNldHVwKHNlbmRVcCkge1xuICAgIGlmICh0aGlzLmlzU2V0VXAoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9ucy5zZXRTZW5kVXAoc2VuZFVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGFic3Rlci5xdWV1ZUluaXQodGhpcy5faW5pdCk7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25zLnNldHVwKHNlbmRVcCk7XG4gICAgfVxuICB9XG4gIGlzU2V0VXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9ucy5pc1NldFVwO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHRhYnN0ZXIgPSB0aGlzLl90YWJzdGVyO1xuICAgIHRhYnN0ZXIua2V5Ym9hcmROYXZpZ2F0aW9uLnVuc3Vic2NyaWJlKHRoaXMuX29uS2V5Ym9hcmROYXZpZ2F0aW9uU3RhdGVDaGFuZ2VkKTtcbiAgICB0YWJzdGVyLmZvY3VzZWRFbGVtZW50LnVuc3Vic2NyaWJlKHRoaXMuX29uRm9jdXMpO1xuICAgIChfYSA9IHRhYnN0ZXIub2JzZXJ2ZWRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudW5zdWJzY3JpYmUodGhpcy5fb25PYnNlcnZlZCk7XG4gICAgdGhpcy5fdHJhbnNhY3Rpb25zLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmZvY3VzZWRFbGVtZW50LmRpc3Bvc2UoKTtcbiAgICB0aGlzLm9ic2VydmVkRWxlbWVudC5kaXNwb3NlKCk7XG4gICAgdGhpcy5fY3R4LmRlbG9zZXJCeVVJZCA9IHt9O1xuICB9XG59XG5mdW5jdGlvbiBnZXREZWxvc2VyVUlEKGdldFdpbmRvdywgY29udGV4dCwgZGVsb3Nlcikge1xuICBjb25zdCBkZWxvc2VyRWxlbWVudCA9IGRlbG9zZXIuZ2V0RWxlbWVudCgpO1xuICBpZiAoZGVsb3NlckVsZW1lbnQpIHtcbiAgICBjb25zdCB1aWQgPSBnZXRFbGVtZW50VUlkKGdldFdpbmRvdywgZGVsb3NlckVsZW1lbnQpO1xuICAgIGlmICghY29udGV4dC5kZWxvc2VyQnlVSWRbdWlkXSkge1xuICAgICAgY29udGV4dC5kZWxvc2VyQnlVSWRbdWlkXSA9IGRlbG9zZXI7XG4gICAgfVxuICAgIHJldHVybiB1aWQ7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY2xhc3MgRm9jdXNhYmxlQVBJIHtcbiAgY29uc3RydWN0b3IodGFic3Rlcikge1xuICAgIHRoaXMuX3RhYnN0ZXIgPSB0YWJzdGVyO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgLyoqL1xuICB9XG4gIGdldFByb3BzKGVsZW1lbnQpIHtcbiAgICBjb25zdCB0YWJzdGVyT25FbGVtZW50ID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0aGlzLl90YWJzdGVyLCBlbGVtZW50KTtcbiAgICByZXR1cm4gdGFic3Rlck9uRWxlbWVudCAmJiB0YWJzdGVyT25FbGVtZW50LmZvY3VzYWJsZSB8fCB7fTtcbiAgfVxuICBpc0ZvY3VzYWJsZShlbCwgaW5jbHVkZVByb2dyYW1tYXRpY2FsbHlGb2N1c2FibGUsIG5vVmlzaWJsZUNoZWNrLCBub0FjY2Vzc2libGVDaGVjaykge1xuICAgIGlmIChtYXRjaGVzU2VsZWN0b3IoZWwsIEZPQ1VTQUJMRV9TRUxFQ1RPUikgJiYgKGluY2x1ZGVQcm9ncmFtbWF0aWNhbGx5Rm9jdXNhYmxlIHx8IGVsLnRhYkluZGV4ICE9PSAtMSkpIHtcbiAgICAgIHJldHVybiAobm9WaXNpYmxlQ2hlY2sgfHwgdGhpcy5pc1Zpc2libGUoZWwpKSAmJiAobm9BY2Nlc3NpYmxlQ2hlY2sgfHwgdGhpcy5pc0FjY2Vzc2libGUoZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlzVmlzaWJsZShlbCkge1xuICAgIGlmICghZWwub3duZXJEb2N1bWVudCB8fCBlbC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzRGlzcGxheU5vbmUoZWwpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSBlbC5vd25lckRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKHJlY3Qud2lkdGggPT09IDAgJiYgcmVjdC5oZWlnaHQgPT09IDApIHtcbiAgICAgIC8vIFRoaXMgbWlnaHQgaGFwcGVuLCBmb3IgZXhhbXBsZSwgaWYgb3VyIDxib2R5PiBpcyBpbiBoaWRkZW4gPGlmcmFtZT4uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlzQWNjZXNzaWJsZShlbCkge1xuICAgIHZhciBfYTtcbiAgICBmb3IgKGxldCBlID0gZWw7IGU7IGUgPSBkb20uZ2V0UGFyZW50RWxlbWVudChlKSkge1xuICAgICAgY29uc3QgdGFic3Rlck9uRWxlbWVudCA9IGdldFRhYnN0ZXJPbkVsZW1lbnQodGhpcy5fdGFic3RlciwgZSk7XG4gICAgICBpZiAodGhpcy5faXNIaWRkZW4oZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgaWdub3JlRGlzYWJsZWQgPSAoX2EgPSB0YWJzdGVyT25FbGVtZW50ID09PSBudWxsIHx8IHRhYnN0ZXJPbkVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhYnN0ZXJPbkVsZW1lbnQuZm9jdXNhYmxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWdub3JlQXJpYURpc2FibGVkO1xuICAgICAgaWYgKCFpZ25vcmVEaXNhYmxlZCAmJiB0aGlzLl9pc0Rpc2FibGVkKGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX2lzRGlzYWJsZWQoZWwpIHtcbiAgICByZXR1cm4gZWwuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XG4gIH1cbiAgX2lzSGlkZGVuKGVsKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGF0dHJWYWwgPSBlbC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgICBpZiAoYXR0clZhbCAmJiBhdHRyVmFsLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiKSB7XG4gICAgICBpZiAoISgoX2EgPSB0aGlzLl90YWJzdGVyLm1vZGFsaXplcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzQXVnbWVudGVkKGVsKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmaW5kRmlyc3Qob3B0aW9ucywgb3V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZEVsZW1lbnQoe1xuICAgICAgLi4ub3B0aW9uc1xuICAgIH0sIG91dCk7XG4gIH1cbiAgZmluZExhc3Qob3B0aW9ucywgb3V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZEVsZW1lbnQoe1xuICAgICAgaXNCYWNrd2FyZDogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9LCBvdXQpO1xuICB9XG4gIGZpbmROZXh0KG9wdGlvbnMsIG91dCkge1xuICAgIHJldHVybiB0aGlzLmZpbmRFbGVtZW50KHtcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9LCBvdXQpO1xuICB9XG4gIGZpbmRQcmV2KG9wdGlvbnMsIG91dCkge1xuICAgIHJldHVybiB0aGlzLmZpbmRFbGVtZW50KHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBpc0JhY2t3YXJkOiB0cnVlXG4gICAgfSwgb3V0KTtcbiAgfVxuICBmaW5kRGVmYXVsdChvcHRpb25zLCBvdXQpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kRWxlbWVudCh7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgYWNjZXB0Q29uZGl0aW9uOiBlbCA9PiB0aGlzLmlzRm9jdXNhYmxlKGVsLCBvcHRpb25zLmluY2x1ZGVQcm9ncmFtbWF0aWNhbGx5Rm9jdXNhYmxlKSAmJiAhIXRoaXMuZ2V0UHJvcHMoZWwpLmlzRGVmYXVsdFxuICAgIH0sIG91dCkgfHwgbnVsbDtcbiAgfVxuICBmaW5kQWxsKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZmluZEVsZW1lbnRzKHRydWUsIG9wdGlvbnMpIHx8IFtdO1xuICB9XG4gIGZpbmRFbGVtZW50KG9wdGlvbnMsIG91dCkge1xuICAgIGNvbnN0IGZvdW5kID0gdGhpcy5fZmluZEVsZW1lbnRzKGZhbHNlLCBvcHRpb25zLCBvdXQpO1xuICAgIHJldHVybiBmb3VuZCA/IGZvdW5kWzBdIDogZm91bmQ7XG4gIH1cbiAgX2ZpbmRFbGVtZW50cyhpc0ZpbmRBbGwsIG9wdGlvbnMsIG91dCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGN1cnJlbnRFbGVtZW50ID0gbnVsbCxcbiAgICAgIGluY2x1ZGVQcm9ncmFtbWF0aWNhbGx5Rm9jdXNhYmxlLFxuICAgICAgdXNlQWN0aXZlTW9kYWxpemVyLFxuICAgICAgaWdub3JlQWNjZXNzaWJpbGl0eSxcbiAgICAgIG1vZGFsaXplcklkLFxuICAgICAgaXNCYWNrd2FyZCxcbiAgICAgIG9uRWxlbWVudFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghb3V0KSB7XG4gICAgICBvdXQgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICBsZXQge1xuICAgICAgYWNjZXB0Q29uZGl0aW9uXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaGFzQ3VzdG9tQ29uZGl0aW9uID0gISFhY2NlcHRDb25kaXRpb247XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIWFjY2VwdENvbmRpdGlvbikge1xuICAgICAgYWNjZXB0Q29uZGl0aW9uID0gZWwgPT4gdGhpcy5pc0ZvY3VzYWJsZShlbCwgaW5jbHVkZVByb2dyYW1tYXRpY2FsbHlGb2N1c2FibGUsIGZhbHNlLCBpZ25vcmVBY2Nlc3NpYmlsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgYWNjZXB0RWxlbWVudFN0YXRlID0ge1xuICAgICAgY29udGFpbmVyLFxuICAgICAgbW9kYWxpemVyVXNlcklkOiBtb2RhbGl6ZXJJZCA9PT0gdW5kZWZpbmVkICYmIHVzZUFjdGl2ZU1vZGFsaXplciA/IChfYSA9IHRoaXMuX3RhYnN0ZXIubW9kYWxpemVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWN0aXZlSWQgOiBtb2RhbGl6ZXJJZCB8fCAoKF9jID0gKF9iID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0aGlzLl90YWJzdGVyLCBjb250YWluZXIpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubW9kYWxpemVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudXNlcklkKSxcbiAgICAgIGZyb206IGN1cnJlbnRFbGVtZW50IHx8IGNvbnRhaW5lcixcbiAgICAgIGlzQmFja3dhcmQsXG4gICAgICBpc0ZpbmRBbGwsXG4gICAgICBhY2NlcHRDb25kaXRpb24sXG4gICAgICBoYXNDdXN0b21Db25kaXRpb24sXG4gICAgICBpbmNsdWRlUHJvZ3JhbW1hdGljYWxseUZvY3VzYWJsZSxcbiAgICAgIGlnbm9yZUFjY2Vzc2liaWxpdHksXG4gICAgICBjYWNoZWRHcm91cHBlcnM6IHt9LFxuICAgICAgY2FjaGVkUmFkaW9Hcm91cHM6IHt9XG4gICAgfTtcbiAgICBjb25zdCB3YWxrZXIgPSBjcmVhdGVFbGVtZW50VHJlZVdhbGtlcihjb250YWluZXIub3duZXJEb2N1bWVudCwgY29udGFpbmVyLCBub2RlID0+IHRoaXMuX2FjY2VwdEVsZW1lbnQobm9kZSwgYWNjZXB0RWxlbWVudFN0YXRlKSk7XG4gICAgaWYgKCF3YWxrZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwcmVwYXJlRm9yTmV4dEVsZW1lbnQgPSBzaG91bGRDb250aW51ZUlmTm90Rm91bmQgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IGZvdW5kRWxlbWVudCA9IChfYSA9IGFjY2VwdEVsZW1lbnRTdGF0ZS5mb3VuZEVsZW1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGFjY2VwdEVsZW1lbnRTdGF0ZS5mb3VuZEJhY2t3YXJkO1xuICAgICAgaWYgKGZvdW5kRWxlbWVudCkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKGZvdW5kRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNGaW5kQWxsKSB7XG4gICAgICAgIGlmIChmb3VuZEVsZW1lbnQpIHtcbiAgICAgICAgICBhY2NlcHRFbGVtZW50U3RhdGUuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBkZWxldGUgYWNjZXB0RWxlbWVudFN0YXRlLmZvdW5kRWxlbWVudDtcbiAgICAgICAgICBkZWxldGUgYWNjZXB0RWxlbWVudFN0YXRlLmZvdW5kQmFja3dhcmQ7XG4gICAgICAgICAgZGVsZXRlIGFjY2VwdEVsZW1lbnRTdGF0ZS5mcm9tQ3R4O1xuICAgICAgICAgIGFjY2VwdEVsZW1lbnRTdGF0ZS5mcm9tID0gZm91bmRFbGVtZW50O1xuICAgICAgICAgIGlmIChvbkVsZW1lbnQgJiYgIW9uRWxlbWVudChmb3VuZEVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIShmb3VuZEVsZW1lbnQgfHwgc2hvdWxkQ29udGludWVJZk5vdEZvdW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEVsZW1lbnQgJiYgb3V0KSB7XG4gICAgICAgICAgb3V0LnVuY29udHJvbGxlZCA9IChfYiA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGhpcy5fdGFic3RlciwgZm91bmRFbGVtZW50KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVuY29udHJvbGxlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISEoc2hvdWxkQ29udGludWVJZk5vdEZvdW5kICYmICFmb3VuZEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKCFjdXJyZW50RWxlbWVudCkge1xuICAgICAgb3V0Lm91dE9mRE9NT3JkZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudEVsZW1lbnQgJiYgZG9tLm5vZGVDb250YWlucyhjb250YWluZXIsIGN1cnJlbnRFbGVtZW50KSkge1xuICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gY3VycmVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIGlmIChpc0JhY2t3YXJkKSB7XG4gICAgICBjb25zdCBsYXN0Q2hpbGQgPSBnZXRMYXN0Q2hpbGQkMihjb250YWluZXIpO1xuICAgICAgaWYgKCFsYXN0Q2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fYWNjZXB0RWxlbWVudChsYXN0Q2hpbGQsIGFjY2VwdEVsZW1lbnRTdGF0ZSkgPT09IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCAmJiAhcHJlcGFyZUZvck5leHRFbGVtZW50KHRydWUpKSB7XG4gICAgICAgIGlmIChhY2NlcHRFbGVtZW50U3RhdGUuc2tpcHBlZEZvY3VzYWJsZSkge1xuICAgICAgICAgIG91dC5vdXRPZkRPTU9yZGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICB9XG4gICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBsYXN0Q2hpbGQ7XG4gICAgfVxuICAgIGRvIHtcbiAgICAgIGlmIChpc0JhY2t3YXJkKSB7XG4gICAgICAgIHdhbGtlci5wcmV2aW91c05vZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHByZXBhcmVGb3JOZXh0RWxlbWVudCgpKTtcbiAgICBpZiAoYWNjZXB0RWxlbWVudFN0YXRlLnNraXBwZWRGb2N1c2FibGUpIHtcbiAgICAgIG91dC5vdXRPZkRPTU9yZGVyID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzLmxlbmd0aCA/IGVsZW1lbnRzIDogbnVsbDtcbiAgfVxuICBfYWNjZXB0RWxlbWVudChlbGVtZW50LCBzdGF0ZSkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmIChzdGF0ZS5mb3VuZCkge1xuICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICB9XG4gICAgY29uc3QgZm91bmRCYWNrd2FyZCA9IHN0YXRlLmZvdW5kQmFja3dhcmQ7XG4gICAgaWYgKGZvdW5kQmFja3dhcmQgJiYgKGVsZW1lbnQgPT09IGZvdW5kQmFja3dhcmQgfHwgIWRvbS5ub2RlQ29udGFpbnMoZm91bmRCYWNrd2FyZCwgZWxlbWVudCkpKSB7XG4gICAgICBzdGF0ZS5mb3VuZCA9IHRydWU7XG4gICAgICBzdGF0ZS5mb3VuZEVsZW1lbnQgPSBmb3VuZEJhY2t3YXJkO1xuICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyID0gc3RhdGUuY29udGFpbmVyO1xuICAgIGlmIChlbGVtZW50ID09PSBjb250YWluZXIpIHtcbiAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgIH1cbiAgICBpZiAoIWRvbS5ub2RlQ29udGFpbnMoY29udGFpbmVyLCBlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVDtcbiAgICB9XG4gICAgaWYgKGdldER1bW15SW5wdXRDb250YWluZXIoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1Q7XG4gICAgfVxuICAgIGlmIChkb20ubm9kZUNvbnRhaW5zKHN0YXRlLnJlamVjdEVsZW1lbnRzRnJvbSwgZWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1Q7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHN0YXRlLmN1cnJlbnRDdHggPSBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRoaXMuX3RhYnN0ZXIsIGVsZW1lbnQpO1xuICAgIC8vIFRhYnN0ZXIgaXMgb3B0IGluLCBpZiBpdCBpcyBub3QgbWFuYWdlZCwgZG9uJ3QgdHJ5IGFuZCBnZXQgZG8gYW55dGhpbmcgc3BlY2lhbFxuICAgIGlmICghY3R4KSB7XG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICB9XG4gICAgaWYgKHNob3VsZElnbm9yZUZvY3VzKGVsZW1lbnQpKSB7XG4gICAgICBpZiAodGhpcy5pc0ZvY3VzYWJsZShlbGVtZW50LCB1bmRlZmluZWQsIHRydWUsIHRydWUpKSB7XG4gICAgICAgIHN0YXRlLnNraXBwZWRGb2N1c2FibGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgfVxuICAgIC8vIFdlIGFzc3VtZSBpZnJhbWVzIGFyZSBmb2N1c2FibGUgYmVjYXVzZSBuYXRpdmUgdGFiIGJlaGF2aW91ciB3b3VsZCB0YWIgaW5zaWRlLlxuICAgIC8vIEJ1dCB3ZSBkbyBpdCBvbmx5IGR1cmluZyB0aGUgc3RhbmRhcmQgc2VhcmNoIHdoZW4gdGhlcmUgaXMgbm8gY3VzdG9tIGFjY2VwdFxuICAgIC8vIGVsZW1lbnQgY29uZGl0aW9uLlxuICAgIGlmICghc3RhdGUuaGFzQ3VzdG9tQ29uZGl0aW9uICYmIChlbGVtZW50LnRhZ05hbWUgPT09IFwiSUZSQU1FXCIgfHwgZWxlbWVudC50YWdOYW1lID09PSBcIldFQlZJRVdcIikpIHtcbiAgICAgIGlmICh0aGlzLmlzVmlzaWJsZShlbGVtZW50KSAmJiAoKF9hID0gY3R4Lm1vZGFsaXplcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVzZXJJZCkgPT09ICgoX2IgPSB0aGlzLl90YWJzdGVyLm1vZGFsaXplcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFjdGl2ZUlkKSkge1xuICAgICAgICBzdGF0ZS5mb3VuZCA9IHRydWU7XG4gICAgICAgIHN0YXRlLnJlamVjdEVsZW1lbnRzRnJvbSA9IHN0YXRlLmZvdW5kRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0YXRlLmlnbm9yZUFjY2Vzc2liaWxpdHkgJiYgIXRoaXMuaXNBY2Nlc3NpYmxlKGVsZW1lbnQpKSB7XG4gICAgICBpZiAodGhpcy5pc0ZvY3VzYWJsZShlbGVtZW50LCBmYWxzZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgc3RhdGUuc2tpcHBlZEZvY3VzYWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBmcm9tQ3R4ID0gc3RhdGUuZnJvbUN0eDtcbiAgICBpZiAoIWZyb21DdHgpIHtcbiAgICAgIGZyb21DdHggPSBzdGF0ZS5mcm9tQ3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0aGlzLl90YWJzdGVyLCBzdGF0ZS5mcm9tKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vdmVyID0gZnJvbUN0eCA9PT0gbnVsbCB8fCBmcm9tQ3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmcm9tQ3R4Lm1vdmVyO1xuICAgIGxldCBncm91cHBlciA9IGN0eC5ncm91cHBlcjtcbiAgICBsZXQgbW92ZXIgPSBjdHgubW92ZXI7XG4gICAgcmVzdWx0ID0gKF9jID0gdGhpcy5fdGFic3Rlci5tb2RhbGl6ZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hY2NlcHRFbGVtZW50KGVsZW1lbnQsIHN0YXRlKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXRlLnNraXBwZWRGb2N1c2FibGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgJiYgKGdyb3VwcGVyIHx8IG1vdmVyIHx8IGZyb21Nb3ZlcikpIHtcbiAgICAgIGNvbnN0IGdyb3VwcGVyRWxlbWVudCA9IGdyb3VwcGVyID09PSBudWxsIHx8IGdyb3VwcGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBncm91cHBlci5nZXRFbGVtZW50KCk7XG4gICAgICBjb25zdCBmcm9tTW92ZXJFbGVtZW50ID0gZnJvbU1vdmVyID09PSBudWxsIHx8IGZyb21Nb3ZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZnJvbU1vdmVyLmdldEVsZW1lbnQoKTtcbiAgICAgIGxldCBtb3ZlckVsZW1lbnQgPSBtb3ZlciA9PT0gbnVsbCB8fCBtb3ZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW92ZXIuZ2V0RWxlbWVudCgpO1xuICAgICAgaWYgKG1vdmVyRWxlbWVudCAmJiBkb20ubm9kZUNvbnRhaW5zKGZyb21Nb3ZlckVsZW1lbnQsIG1vdmVyRWxlbWVudCkgJiYgZG9tLm5vZGVDb250YWlucyhjb250YWluZXIsIGZyb21Nb3ZlckVsZW1lbnQpICYmICghZ3JvdXBwZXJFbGVtZW50IHx8ICFtb3ZlciB8fCBkb20ubm9kZUNvbnRhaW5zKGZyb21Nb3ZlckVsZW1lbnQsIGdyb3VwcGVyRWxlbWVudCkpKSB7XG4gICAgICAgIG1vdmVyID0gZnJvbU1vdmVyO1xuICAgICAgICBtb3ZlckVsZW1lbnQgPSBmcm9tTW92ZXJFbGVtZW50O1xuICAgICAgfVxuICAgICAgaWYgKGdyb3VwcGVyRWxlbWVudCkge1xuICAgICAgICBpZiAoZ3JvdXBwZXJFbGVtZW50ID09PSBjb250YWluZXIgfHwgIWRvbS5ub2RlQ29udGFpbnMoY29udGFpbmVyLCBncm91cHBlckVsZW1lbnQpKSB7XG4gICAgICAgICAgZ3JvdXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIWRvbS5ub2RlQ29udGFpbnMoZ3JvdXBwZXJFbGVtZW50LCBlbGVtZW50KSkge1xuICAgICAgICAgIC8vIF9hY2NlcHRFbGVtZW50KCkgY2FsbGJhY2sgaXMgY2FsbGVkIGR1cmluZyB0aGUgdHJlZSB3YWxraW5nLlxuICAgICAgICAgIC8vIEdpdmVuIHRoZSBwb3RlbnRpYWxpdHkgb2YgdmlydHVhbCBwYXJlbnRzIChkcml2ZW4gYnkgdGhlIGN1c3RvbSBnZXRQYXJlbnQoKSBmdW5jdGlvbiksXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgZ3JvdXBwZXIgZnJvbSB0aGUgY3VycmVudCBlbGVtZW50J3MgY29udGV4dCBpcyBub3QsXG4gICAgICAgICAgLy8gcG9ydGFsaW5nIHVzIG91dCBvZiB0aGUgRE9NIG9yZGVyLlxuICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtb3ZlckVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFkb20ubm9kZUNvbnRhaW5zKGNvbnRhaW5lciwgbW92ZXJFbGVtZW50KSkge1xuICAgICAgICAgIG1vdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKCFkb20ubm9kZUNvbnRhaW5zKG1vdmVyRWxlbWVudCwgZWxlbWVudCkpIHtcbiAgICAgICAgICAvLyBfYWNjZXB0RWxlbWVudCgpIGNhbGxiYWNrIGlzIGNhbGxlZCBkdXJpbmcgdGhlIHRyZWUgd2Fsa2luZy5cbiAgICAgICAgICAvLyBHaXZlbiB0aGUgcG90ZW50aWFsaXR5IG9mIHZpcnR1YWwgcGFyZW50cyAoZHJpdmVuIGJ5IHRoZSBjdXN0b20gZ2V0UGFyZW50KCkgZnVuY3Rpb24pLFxuICAgICAgICAgIC8vIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIG1vdmVyIGZyb20gdGhlIGN1cnJlbnQgZWxlbWVudCdzIGNvbnRleHQgaXMgbm90LFxuICAgICAgICAgIC8vIHBvcnRhbGluZyB1cyBvdXQgb2YgdGhlIERPTSBvcmRlci5cbiAgICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZ3JvdXBwZXIgJiYgbW92ZXIpIHtcbiAgICAgICAgaWYgKG1vdmVyRWxlbWVudCAmJiBncm91cHBlckVsZW1lbnQgJiYgIWRvbS5ub2RlQ29udGFpbnMoZ3JvdXBwZXJFbGVtZW50LCBtb3ZlckVsZW1lbnQpKSB7XG4gICAgICAgICAgbW92ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JvdXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChncm91cHBlcikge1xuICAgICAgICByZXN1bHQgPSBncm91cHBlci5hY2NlcHRFbGVtZW50KGVsZW1lbnQsIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb3Zlcikge1xuICAgICAgICByZXN1bHQgPSBtb3Zlci5hY2NlcHRFbGVtZW50KGVsZW1lbnQsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXN1bHQgPSBzdGF0ZS5hY2NlcHRDb25kaXRpb24oZWxlbWVudCkgPyBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQgOiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gTm9kZUZpbHRlci5GSUxURVJfU0tJUCAmJiB0aGlzLmlzRm9jdXNhYmxlKGVsZW1lbnQsIGZhbHNlLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICBzdGF0ZS5za2lwcGVkRm9jdXNhYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdCA9PT0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUICYmICFzdGF0ZS5mb3VuZCkge1xuICAgICAgaWYgKCFzdGF0ZS5pc0ZpbmRBbGwgJiYgaXNSYWRpbyhlbGVtZW50KSAmJiAhZWxlbWVudC5jaGVja2VkKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gbWltaWMgdGhlIGJyb3dzZXIncyBiZWhhdmlvdXIgdG8gc2tpcCB1bmNoZWNrZWQgcmFkaW8gYnV0dG9ucy5cbiAgICAgICAgY29uc3QgcmFkaW9Hcm91cE5hbWUgPSBlbGVtZW50Lm5hbWU7XG4gICAgICAgIGxldCByYWRpb0dyb3VwID0gc3RhdGUuY2FjaGVkUmFkaW9Hcm91cHNbcmFkaW9Hcm91cE5hbWVdO1xuICAgICAgICBpZiAoIXJhZGlvR3JvdXApIHtcbiAgICAgICAgICByYWRpb0dyb3VwID0gZ2V0UmFkaW9CdXR0b25Hcm91cChlbGVtZW50KTtcbiAgICAgICAgICBpZiAocmFkaW9Hcm91cCkge1xuICAgICAgICAgICAgc3RhdGUuY2FjaGVkUmFkaW9Hcm91cHNbcmFkaW9Hcm91cE5hbWVdID0gcmFkaW9Hcm91cDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChyYWRpb0dyb3VwID09PSBudWxsIHx8IHJhZGlvR3JvdXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhZGlvR3JvdXAuY2hlY2tlZCkgJiYgcmFkaW9Hcm91cC5jaGVja2VkICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgLy8gQ3VycmVudGx5IGZvdW5kIGVsZW1lbnQgaXMgYSByYWRpbyBidXR0b24gaW4gYSBncm91cCB0aGF0IGhhcyBhbm90aGVyIHJhZGlvIGJ1dHRvbiBjaGVja2VkLlxuICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaXNCYWNrd2FyZCkge1xuICAgICAgICAvLyBXaGVuIFRyZWVXYWxrZXIgZ29lcyBiYWNrd2FyZHMsIGl0IHZpc2l0cyB0aGUgY29udGFpbmVyIGZpcnN0LFxuICAgICAgICAvLyB0aGVuIGl0IGdvZXMgaW5zaWRlLiBTbywgaWYgdGhlIGNvbnRhaW5lciBpcyBhY2NlcHRlZCwgd2UgcmVtZW1iZXIgaXQsXG4gICAgICAgIC8vIGJ1dCBhbGxvd2luZyB0aGUgVHJlZVdhbGtlciB0byBjaGVjayBpbnNpZGUuXG4gICAgICAgIHN0YXRlLmZvdW5kQmFja3dhcmQgPSBlbGVtZW50O1xuICAgICAgICByZXN1bHQgPSBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuZm91bmQgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5mb3VuZEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmNvbnN0IEtleXMgPSB7XG4gIFRhYjogXCJUYWJcIixcbiAgRW50ZXI6IFwiRW50ZXJcIixcbiAgRXNjYXBlOiBcIkVzY2FwZVwiLFxuICBQYWdlVXA6IFwiUGFnZVVwXCIsXG4gIFBhZ2VEb3duOiBcIlBhZ2VEb3duXCIsXG4gIEVuZDogXCJFbmRcIixcbiAgSG9tZTogXCJIb21lXCIsXG4gIEFycm93TGVmdDogXCJBcnJvd0xlZnRcIixcbiAgQXJyb3dVcDogXCJBcnJvd1VwXCIsXG4gIEFycm93UmlnaHQ6IFwiQXJyb3dSaWdodFwiLFxuICBBcnJvd0Rvd246IFwiQXJyb3dEb3duXCJcbn07XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGdldFVuY29udHJvbGxlZENvbXBsZXRlbHlDb250YWluZXIodGFic3RlciwgZWxlbWVudCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGdldFBhcmVudCA9IHRhYnN0ZXIuZ2V0UGFyZW50O1xuICBsZXQgZWwgPSBlbGVtZW50O1xuICBkbyB7XG4gICAgY29uc3QgdW5jb250cm9sbGVkT25FbGVtZW50ID0gKF9hID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0YWJzdGVyLCBlbCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bmNvbnRyb2xsZWQ7XG4gICAgaWYgKHVuY29udHJvbGxlZE9uRWxlbWVudCAmJiB0YWJzdGVyLnVuY29udHJvbGxlZC5pc1VuY29udHJvbGxlZENvbXBsZXRlbHkoZWwsICEhdW5jb250cm9sbGVkT25FbGVtZW50LmNvbXBsZXRlbHkpKSB7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICAgIGVsID0gZ2V0UGFyZW50KGVsKTtcbiAgfSB3aGlsZSAoZWwpO1xuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuY29uc3QgQXN5bmNGb2N1c0ludGVudFByaW9yaXR5QnlTb3VyY2UgPSB7XG4gIFtBc3luY0ZvY3VzU291cmNlcy5SZXN0b3Jlcl06IDAsXG4gIFtBc3luY0ZvY3VzU291cmNlcy5EZWxvc2VyXTogMSxcbiAgW0FzeW5jRm9jdXNTb3VyY2VzLkVzY2FwZUdyb3VwcGVyXTogMlxufTtcbmNsYXNzIEZvY3VzZWRFbGVtZW50U3RhdGUgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyLCBnZXRXaW5kb3cpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2luaXQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB3aW4gPSB0aGlzLl93aW4oKTtcbiAgICAgIGNvbnN0IGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICAgIC8vIEFkZCB0aGVzZSBldmVudCBsaXN0ZW5lcnMgYXMgY2FwdHVyZSAtIHdlIHdhbnQgVGFic3RlciB0byBydW4gYmVmb3JlIHVzZXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKEtFWUJPUkdfRk9DVVNJTiwgdGhpcy5fb25Gb2N1c0luLCB0cnVlKTtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKEtFWUJPUkdfRk9DVVNPVVQsIHRoaXMuX29uRm9jdXNPdXQsIHRydWUpO1xuICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93biwgdHJ1ZSk7XG4gICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9tLmdldEFjdGl2ZUVsZW1lbnQoZG9jKTtcbiAgICAgIGlmIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQgIT09IGRvYy5ib2R5KSB7XG4gICAgICAgIHRoaXMuX3NldEZvY3VzZWRFbGVtZW50KGFjdGl2ZUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdWJzY3JpYmUodGhpcy5fb25DaGFuZ2VkKTtcbiAgICB9O1xuICAgIHRoaXMuX29uRm9jdXNJbiA9IGUgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZS5jb21wb3NlZFBhdGgoKVswXTtcbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5fc2V0Rm9jdXNlZEVsZW1lbnQodGFyZ2V0LCBlLmRldGFpbC5yZWxhdGVkVGFyZ2V0LCBlLmRldGFpbC5pc0ZvY3VzZWRQcm9ncmFtbWF0aWNhbGx5KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX29uRm9jdXNPdXQgPSBlID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHRoaXMuX3NldEZvY3VzZWRFbGVtZW50KHVuZGVmaW5lZCwgKF9hID0gZS5kZXRhaWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcmlnaW5hbEV2ZW50LnJlbGF0ZWRUYXJnZXQpO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHRoaXMuX3ZhbGlkYXRlRm9jdXNlZEVsZW1lbnQgPSBlbGVtZW50ID0+IHtcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGlzIGlzIG5vdCBuZWVkZWQgYW55bW9yZSBhbmQgd3JpdGUgdGVzdHMuXG4gICAgfTtcbiAgICB0aGlzLl9vbktleURvd24gPSBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5ICE9PSBLZXlzLlRhYiB8fCBldmVudC5jdHJsS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50ID0gdGhpcy5nZXRWYWwoKTtcbiAgICAgIGlmICghY3VycmVudEVsZW1lbnQgfHwgIWN1cnJlbnRFbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgY3VycmVudEVsZW1lbnQuY29udGVudEVkaXRhYmxlID09PSBcInRydWVcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0YWJzdGVyID0gdGhpcy5fdGFic3RlcjtcbiAgICAgIGNvbnN0IGNvbnRyb2xUYWIgPSB0YWJzdGVyLmNvbnRyb2xUYWI7XG4gICAgICBjb25zdCBjdHggPSBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRhYnN0ZXIsIGN1cnJlbnRFbGVtZW50KTtcbiAgICAgIGlmICghY3R4IHx8IGN0eC5pZ25vcmVLZXlkb3duKGV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpc0JhY2t3YXJkID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICBjb25zdCBuZXh0ID0gRm9jdXNlZEVsZW1lbnRTdGF0ZS5maW5kTmV4dFRhYmJhYmxlKHRhYnN0ZXIsIGN0eCwgdW5kZWZpbmVkLCBjdXJyZW50RWxlbWVudCwgdW5kZWZpbmVkLCBpc0JhY2t3YXJkLCB0cnVlKTtcbiAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gY3R4LnJvb3QuZ2V0RWxlbWVudCgpO1xuICAgICAgaWYgKCFyb290RWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0RWxlbWVudCA9IG5leHQgPT09IG51bGwgfHwgbmV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV4dC5lbGVtZW50O1xuICAgICAgY29uc3QgdW5jb250cm9sbGVkQ29tcGxldGVseUNvbnRhaW5lciA9IGdldFVuY29udHJvbGxlZENvbXBsZXRlbHlDb250YWluZXIodGFic3RlciwgY3VycmVudEVsZW1lbnQpO1xuICAgICAgaWYgKG5leHRFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IG5leHRVbmNvbnRyb2xsZWQgPSBuZXh0LnVuY29udHJvbGxlZDtcbiAgICAgICAgaWYgKGN0eC51bmNvbnRyb2xsZWQgfHwgZG9tLm5vZGVDb250YWlucyhuZXh0VW5jb250cm9sbGVkLCBjdXJyZW50RWxlbWVudCkpIHtcbiAgICAgICAgICBpZiAoIW5leHQub3V0T2ZET01PcmRlciAmJiBuZXh0VW5jb250cm9sbGVkID09PSBjdHgudW5jb250cm9sbGVkIHx8IHVuY29udHJvbGxlZENvbXBsZXRlbHlDb250YWluZXIgJiYgIWRvbS5ub2RlQ29udGFpbnModW5jb250cm9sbGVkQ29tcGxldGVseUNvbnRhaW5lciwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvLCBldmVyeXRoaW5nIHdpbGwgYmUgZG9uZSBieSB0aGUgYnJvd3NlciBvciBzb21ldGhpbmdcbiAgICAgICAgICAgIC8vIHRoYXQgY29udHJvbHMgdGhlIHVuY29udHJvbGxlZCBhcmVhLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBXZSBhcmUgaW4gdW5jb250cm9sbGVkIGFyZWEuIFdlIGFsbG93IHdoYXRldmVyIGNvbnRyb2xzIGl0IHRvIG1vdmVcbiAgICAgICAgICAvLyBmb2N1cywgYnV0IHdlIGFkZCBhIHBoYW50b20gZHVtbXkgdG8gbWFrZSBzdXJlIHRoZSBmb2N1cyBpcyBtb3ZlZFxuICAgICAgICAgIC8vIHRvIHRoZSBjb3JyZWN0IHBsYWNlIGlmIHRoZSB1bmNvbnRyb2xsZWQgYXJlYSBhbGxvd3MgZGVmYXVsdCBhY3Rpb24uXG4gICAgICAgICAgLy8gV2Ugb25seSBuZWVkIHRoYXQgaW4gdGhlIGNvbnRyb2xsZWQgbW9kZSwgYmVjYXVzZSBpbiB1bmNvbnRyb2xsZWRcbiAgICAgICAgICAvLyBtb2RlIHdlIGhhdmUgZHVtbXkgaW5wdXRzIGFyb3VuZCBldmVyeXRoaW5nIHRoYXQgcmVkaXJlY3RzIGZvY3VzLlxuICAgICAgICAgIER1bW15SW5wdXRNYW5hZ2VyLmFkZFBoYW50b21EdW1teVdpdGhUYXJnZXQodGFic3RlciwgY3VycmVudEVsZW1lbnQsIGlzQmFja3dhcmQsIG5leHRFbGVtZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRVbmNvbnRyb2xsZWQgJiYgdGFic3Rlci5mb2N1c2FibGUuaXNWaXNpYmxlKG5leHRVbmNvbnRyb2xsZWQpIHx8IG5leHRFbGVtZW50LnRhZ05hbWUgPT09IFwiSUZSQU1FXCIgJiYgdGFic3Rlci5mb2N1c2FibGUuaXNWaXNpYmxlKG5leHRFbGVtZW50KSkge1xuICAgICAgICAgIC8vIEZvciBpZnJhbWVzIGFuZCB1bmNvbnRyb2xsZWQgYXJlYXMgd2UgYWx3YXlzIHdhbnQgdG8gdXNlIGRlZmF1bHQgYWN0aW9uIHRvXG4gICAgICAgICAgLy8gbW92ZSBmb2N1cyBpbnRvLlxuICAgICAgICAgIGlmIChyb290RWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBUYWJzdGVyTW92ZUZvY3VzRXZlbnQoe1xuICAgICAgICAgICAgYnk6IFwicm9vdFwiLFxuICAgICAgICAgICAgb3duZXI6IHJvb3RFbGVtZW50LFxuICAgICAgICAgICAgbmV4dDogbmV4dEVsZW1lbnQsXG4gICAgICAgICAgICByZWxhdGVkRXZlbnQ6IGV2ZW50XG4gICAgICAgICAgfSkpKSB7XG4gICAgICAgICAgICBEdW1teUlucHV0TWFuYWdlci5tb3ZlV2l0aFBoYW50b21EdW1teSh0YWJzdGVyLCBuZXh0VW5jb250cm9sbGVkICE9PSBudWxsICYmIG5leHRVbmNvbnRyb2xsZWQgIT09IHZvaWQgMCA/IG5leHRVbmNvbnRyb2xsZWQgOiBuZXh0RWxlbWVudCwgZmFsc2UsIGlzQmFja3dhcmQsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sVGFiIHx8IChuZXh0ID09PSBudWxsIHx8IG5leHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5leHQub3V0T2ZET01PcmRlcikpIHtcbiAgICAgICAgICBpZiAocm9vdEVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgVGFic3Rlck1vdmVGb2N1c0V2ZW50KHtcbiAgICAgICAgICAgIGJ5OiBcInJvb3RcIixcbiAgICAgICAgICAgIG93bmVyOiByb290RWxlbWVudCxcbiAgICAgICAgICAgIG5leHQ6IG5leHRFbGVtZW50LFxuICAgICAgICAgICAgcmVsYXRlZEV2ZW50OiBldmVudFxuICAgICAgICAgIH0pKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgbmF0aXZlRm9jdXMobmV4dEVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF1bmNvbnRyb2xsZWRDb21wbGV0ZWx5Q29udGFpbmVyICYmIHJvb3RFbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IFRhYnN0ZXJNb3ZlRm9jdXNFdmVudCh7XG4gICAgICAgICAgYnk6IFwicm9vdFwiLFxuICAgICAgICAgIG93bmVyOiByb290RWxlbWVudCxcbiAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgIHJlbGF0ZWRFdmVudDogZXZlbnRcbiAgICAgICAgfSkpKSB7XG4gICAgICAgICAgY3R4LnJvb3QubW92ZU91dFdpdGhEZWZhdWx0QWN0aW9uKGlzQmFja3dhcmQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25DaGFuZ2VkID0gKGVsZW1lbnQsIGRldGFpbCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgVGFic3RlckZvY3VzSW5FdmVudChkZXRhaWwpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxhc3QgPSAoX2EgPSB0aGlzLl9sYXN0VmFsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCk7XG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgY29uc3QgZCA9IHtcbiAgICAgICAgICAgIC4uLmRldGFpbFxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgbGFzdEN0eCA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGhpcy5fdGFic3RlciwgbGFzdCk7XG4gICAgICAgICAgY29uc3QgbW9kYWxpemVySWQgPSAoX2IgPSBsYXN0Q3R4ID09PSBudWxsIHx8IGxhc3RDdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RDdHgubW9kYWxpemVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudXNlcklkO1xuICAgICAgICAgIGlmIChtb2RhbGl6ZXJJZCkge1xuICAgICAgICAgICAgZC5tb2RhbGl6ZXJJZCA9IG1vZGFsaXplcklkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0LmRpc3BhdGNoRXZlbnQobmV3IFRhYnN0ZXJGb2N1c091dEV2ZW50KGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gICAgdGhpcy5fd2luID0gZ2V0V2luZG93O1xuICAgIHRhYnN0ZXIucXVldWVJbml0KHRoaXMuX2luaXQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgIGNvbnN0IGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihLRVlCT1JHX0ZPQ1VTSU4sIHRoaXMuX29uRm9jdXNJbiwgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoS0VZQk9SR19GT0NVU09VVCwgdGhpcy5fb25Gb2N1c091dCwgdHJ1ZSk7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93biwgdHJ1ZSk7XG4gICAgdGhpcy51bnN1YnNjcmliZSh0aGlzLl9vbkNoYW5nZWQpO1xuICAgIGNvbnN0IGFzeW5jRm9jdXMgPSB0aGlzLl9hc3luY0ZvY3VzO1xuICAgIGlmIChhc3luY0ZvY3VzKSB7XG4gICAgICB3aW4uY2xlYXJUaW1lb3V0KGFzeW5jRm9jdXMudGltZW91dCk7XG4gICAgICBkZWxldGUgdGhpcy5fYXN5bmNGb2N1cztcbiAgICB9XG4gICAgZGVsZXRlIEZvY3VzZWRFbGVtZW50U3RhdGUuX2xhc3RSZXNldEVsZW1lbnQ7XG4gICAgZGVsZXRlIHRoaXMuX25leHRWYWw7XG4gICAgZGVsZXRlIHRoaXMuX2xhc3RWYWw7XG4gIH1cbiAgc3RhdGljIGZvcmdldE1lbW9yaXplZChpbnN0YW5jZSwgcGFyZW50KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgd2VsID0gRm9jdXNlZEVsZW1lbnRTdGF0ZS5fbGFzdFJlc2V0RWxlbWVudDtcbiAgICBsZXQgZWwgPSB3ZWwgJiYgd2VsLmdldCgpO1xuICAgIGlmIChlbCAmJiBkb20ubm9kZUNvbnRhaW5zKHBhcmVudCwgZWwpKSB7XG4gICAgICBkZWxldGUgRm9jdXNlZEVsZW1lbnRTdGF0ZS5fbGFzdFJlc2V0RWxlbWVudDtcbiAgICB9XG4gICAgZWwgPSAoX2IgPSAoX2EgPSBpbnN0YW5jZS5fbmV4dFZhbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVsZW1lbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXQoKTtcbiAgICBpZiAoZWwgJiYgZG9tLm5vZGVDb250YWlucyhwYXJlbnQsIGVsKSkge1xuICAgICAgZGVsZXRlIGluc3RhbmNlLl9uZXh0VmFsO1xuICAgIH1cbiAgICB3ZWwgPSBpbnN0YW5jZS5fbGFzdFZhbDtcbiAgICBlbCA9IHdlbCAmJiB3ZWwuZ2V0KCk7XG4gICAgaWYgKGVsICYmIGRvbS5ub2RlQ29udGFpbnMocGFyZW50LCBlbCkpIHtcbiAgICAgIGRlbGV0ZSBpbnN0YW5jZS5fbGFzdFZhbDtcbiAgICB9XG4gIH1cbiAgZ2V0Rm9jdXNlZEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsKCk7XG4gIH1cbiAgZ2V0TGFzdEZvY3VzZWRFbGVtZW50KCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgZWwgPSAoX2EgPSB0aGlzLl9sYXN0VmFsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCk7XG4gICAgaWYgKCFlbCB8fCBlbCAmJiAhZG9jdW1lbnRDb250YWlucyhlbC5vd25lckRvY3VtZW50LCBlbCkpIHtcbiAgICAgIHRoaXMuX2xhc3RWYWwgPSBlbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9XG4gIGZvY3VzKGVsZW1lbnQsIG5vRm9jdXNlZFByb2dyYW1tYXRpY2FsbHlGbGFnLCBub0FjY2Vzc2libGVDaGVjaywgcHJldmVudFNjcm9sbCkge1xuICAgIGlmICghdGhpcy5fdGFic3Rlci5mb2N1c2FibGUuaXNGb2N1c2FibGUoZWxlbWVudCwgbm9Gb2N1c2VkUHJvZ3JhbW1hdGljYWxseUZsYWcsIGZhbHNlLCBub0FjY2Vzc2libGVDaGVjaykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxlbWVudC5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9jdXNEZWZhdWx0KGNvbnRhaW5lcikge1xuICAgIGNvbnN0IGVsID0gdGhpcy5fdGFic3Rlci5mb2N1c2FibGUuZmluZERlZmF1bHQoe1xuICAgICAgY29udGFpbmVyXG4gICAgfSk7XG4gICAgaWYgKGVsKSB7XG4gICAgICB0aGlzLl90YWJzdGVyLmZvY3VzZWRFbGVtZW50LmZvY3VzKGVsKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0Rmlyc3RPckxhc3RUYWJiYWJsZShpc0ZpcnN0LCBwcm9wcykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXIsXG4gICAgICBpZ25vcmVBY2Nlc3NpYmlsaXR5XG4gICAgfSA9IHByb3BzO1xuICAgIGxldCB0b0ZvY3VzO1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIGNvbnN0IGN0eCA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGhpcy5fdGFic3RlciwgY29udGFpbmVyKTtcbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgdG9Gb2N1cyA9IChfYSA9IEZvY3VzZWRFbGVtZW50U3RhdGUuZmluZE5leHRUYWJiYWJsZSh0aGlzLl90YWJzdGVyLCBjdHgsIGNvbnRhaW5lciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsICFpc0ZpcnN0LCBpZ25vcmVBY2Nlc3NpYmlsaXR5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0b0ZvY3VzICYmICFkb20ubm9kZUNvbnRhaW5zKGNvbnRhaW5lciwgdG9Gb2N1cykpIHtcbiAgICAgIHRvRm9jdXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB0b0ZvY3VzIHx8IHVuZGVmaW5lZDtcbiAgfVxuICBfZm9jdXNGaXJzdE9yTGFzdChpc0ZpcnN0LCBwcm9wcykge1xuICAgIGNvbnN0IHRvRm9jdXMgPSB0aGlzLmdldEZpcnN0T3JMYXN0VGFiYmFibGUoaXNGaXJzdCwgcHJvcHMpO1xuICAgIGlmICh0b0ZvY3VzKSB7XG4gICAgICB0aGlzLmZvY3VzKHRvRm9jdXMsIGZhbHNlLCB0cnVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9jdXNGaXJzdChwcm9wcykge1xuICAgIHJldHVybiB0aGlzLl9mb2N1c0ZpcnN0T3JMYXN0KHRydWUsIHByb3BzKTtcbiAgfVxuICBmb2N1c0xhc3QocHJvcHMpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9jdXNGaXJzdE9yTGFzdChmYWxzZSwgcHJvcHMpO1xuICB9XG4gIHJlc2V0Rm9jdXMoY29udGFpbmVyKSB7XG4gICAgaWYgKCF0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5pc1Zpc2libGUoY29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3RhYnN0ZXIuZm9jdXNhYmxlLmlzRm9jdXNhYmxlKGNvbnRhaW5lciwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGNvbnN0IHByZXZUYWJJbmRleCA9IGNvbnRhaW5lci5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKTtcbiAgICAgIGNvbnN0IHByZXZBcmlhSGlkZGVuID0gY29udGFpbmVyLmdldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgICAgY29udGFpbmVyLnRhYkluZGV4ID0gLTE7XG4gICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgRm9jdXNlZEVsZW1lbnRTdGF0ZS5fbGFzdFJlc2V0RWxlbWVudCA9IG5ldyBXZWFrSFRNTEVsZW1lbnQodGhpcy5fd2luLCBjb250YWluZXIpO1xuICAgICAgdGhpcy5mb2N1cyhjb250YWluZXIsIHRydWUsIHRydWUpO1xuICAgICAgdGhpcy5fc2V0T3JSZW1vdmVBdHRyaWJ1dGUoY29udGFpbmVyLCBcInRhYmluZGV4XCIsIHByZXZUYWJJbmRleCk7XG4gICAgICB0aGlzLl9zZXRPclJlbW92ZUF0dHJpYnV0ZShjb250YWluZXIsIFwiYXJpYS1oaWRkZW5cIiwgcHJldkFyaWFIaWRkZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvY3VzKGNvbnRhaW5lcik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJlcXVlc3RBc3luY0ZvY3VzKHNvdXJjZSwgY2FsbGJhY2ssIGRlbGF5KSB7XG4gICAgY29uc3Qgd2luID0gdGhpcy5fdGFic3Rlci5nZXRXaW5kb3coKTtcbiAgICBjb25zdCBjdXJyZW50QXN5bmNGb2N1cyA9IHRoaXMuX2FzeW5jRm9jdXM7XG4gICAgaWYgKGN1cnJlbnRBc3luY0ZvY3VzKSB7XG4gICAgICBpZiAoQXN5bmNGb2N1c0ludGVudFByaW9yaXR5QnlTb3VyY2Vbc291cmNlXSA+IEFzeW5jRm9jdXNJbnRlbnRQcmlvcml0eUJ5U291cmNlW2N1cnJlbnRBc3luY0ZvY3VzLnNvdXJjZV0pIHtcbiAgICAgICAgLy8gUHJldmlvdXNseSByZWdpc3RlcmVkIGludGVudCBoYXMgaGlnaGVyIHByaW9yaXR5LlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBOZXcgaW50ZW50IGhhcyBoaWdoZXIgcHJpb3JpdHkuXG4gICAgICB3aW4uY2xlYXJUaW1lb3V0KGN1cnJlbnRBc3luY0ZvY3VzLnRpbWVvdXQpO1xuICAgIH1cbiAgICB0aGlzLl9hc3luY0ZvY3VzID0ge1xuICAgICAgc291cmNlLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICB0aW1lb3V0OiB3aW4uc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX2FzeW5jRm9jdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9LCBkZWxheSlcbiAgICB9O1xuICB9XG4gIGNhbmNlbEFzeW5jRm9jdXMoc291cmNlKSB7XG4gICAgY29uc3QgYXN5bmNGb2N1cyA9IHRoaXMuX2FzeW5jRm9jdXM7XG4gICAgaWYgKChhc3luY0ZvY3VzID09PSBudWxsIHx8IGFzeW5jRm9jdXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFzeW5jRm9jdXMuc291cmNlKSA9PT0gc291cmNlKSB7XG4gICAgICB0aGlzLl90YWJzdGVyLmdldFdpbmRvdygpLmNsZWFyVGltZW91dChhc3luY0ZvY3VzLnRpbWVvdXQpO1xuICAgICAgdGhpcy5fYXN5bmNGb2N1cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgX3NldE9yUmVtb3ZlQXR0cmlidXRlKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICBfc2V0Rm9jdXNlZEVsZW1lbnQoZWxlbWVudCwgcmVsYXRlZFRhcmdldCwgaXNGb2N1c2VkUHJvZ3JhbW1hdGljYWxseSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKHRoaXMuX3RhYnN0ZXIuX25vb3ApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGV0YWlsID0ge1xuICAgICAgcmVsYXRlZFRhcmdldFxuICAgIH07XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGxhc3RSZXNldEVsZW1lbnQgPSAoX2EgPSBGb2N1c2VkRWxlbWVudFN0YXRlLl9sYXN0UmVzZXRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCk7XG4gICAgICBGb2N1c2VkRWxlbWVudFN0YXRlLl9sYXN0UmVzZXRFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGxhc3RSZXNldEVsZW1lbnQgPT09IGVsZW1lbnQgfHwgc2hvdWxkSWdub3JlRm9jdXMoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGV0YWlsLmlzRm9jdXNlZFByb2dyYW1tYXRpY2FsbHkgPSBpc0ZvY3VzZWRQcm9ncmFtbWF0aWNhbGx5O1xuICAgICAgY29uc3QgY3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0aGlzLl90YWJzdGVyLCBlbGVtZW50KTtcbiAgICAgIGNvbnN0IG1vZGFsaXplcklkID0gKF9iID0gY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4Lm1vZGFsaXplcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVzZXJJZDtcbiAgICAgIGlmIChtb2RhbGl6ZXJJZCkge1xuICAgICAgICBkZXRhaWwubW9kYWxpemVySWQgPSBtb2RhbGl6ZXJJZDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV4dFZhbCA9IHRoaXMuX25leHRWYWwgPSB7XG4gICAgICBlbGVtZW50OiBlbGVtZW50ID8gbmV3IFdlYWtIVE1MRWxlbWVudCh0aGlzLl93aW4sIGVsZW1lbnQpIDogdW5kZWZpbmVkLFxuICAgICAgZGV0YWlsXG4gICAgfTtcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50ICE9PSB0aGlzLl92YWwpIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlRm9jdXNlZEVsZW1lbnQoZWxlbWVudCk7XG4gICAgfVxuICAgIC8vIF92YWxpZGF0ZUZvY3VzZWRFbGVtZW50KCkgbWlnaHQgY2F1c2UgdGhlIHJlZm9jdXMgd2hpY2ggd2lsbCB0cmlnZ2VyXG4gICAgLy8gYW5vdGhlciBjYWxsIHRvIHRoaXMgZnVuY3Rpb24uIE1ha2luZyBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGNvcnJlY3QuXG4gICAgaWYgKHRoaXMuX25leHRWYWwgPT09IG5leHRWYWwpIHtcbiAgICAgIHRoaXMuc2V0VmFsKGVsZW1lbnQsIGRldGFpbCk7XG4gICAgfVxuICAgIHRoaXMuX25leHRWYWwgPSB1bmRlZmluZWQ7XG4gIH1cbiAgc2V0VmFsKHZhbCwgZGV0YWlsKSB7XG4gICAgc3VwZXIuc2V0VmFsKHZhbCwgZGV0YWlsKTtcbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLl9sYXN0VmFsID0gbmV3IFdlYWtIVE1MRWxlbWVudCh0aGlzLl93aW4sIHZhbCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmaW5kTmV4dFRhYmJhYmxlKHRhYnN0ZXIsIGN0eCwgY29udGFpbmVyLCBjdXJyZW50RWxlbWVudCwgcmVmZXJlbmNlRWxlbWVudCwgaXNCYWNrd2FyZCwgaWdub3JlQWNjZXNzaWJpbGl0eSkge1xuICAgIGNvbnN0IGFjdHVhbENvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBjdHgucm9vdC5nZXRFbGVtZW50KCk7XG4gICAgaWYgKCFhY3R1YWxDb250YWluZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgbmV4dCA9IG51bGw7XG4gICAgY29uc3QgaXNUYWJiaW5nVGltZXIgPSBGb2N1c2VkRWxlbWVudFN0YXRlLl9pc1RhYmJpbmdUaW1lcjtcbiAgICBjb25zdCB3aW4gPSB0YWJzdGVyLmdldFdpbmRvdygpO1xuICAgIGlmIChpc1RhYmJpbmdUaW1lcikge1xuICAgICAgd2luLmNsZWFyVGltZW91dChpc1RhYmJpbmdUaW1lcik7XG4gICAgfVxuICAgIEZvY3VzZWRFbGVtZW50U3RhdGUuaXNUYWJiaW5nID0gdHJ1ZTtcbiAgICBGb2N1c2VkRWxlbWVudFN0YXRlLl9pc1RhYmJpbmdUaW1lciA9IHdpbi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRlbGV0ZSBGb2N1c2VkRWxlbWVudFN0YXRlLl9pc1RhYmJpbmdUaW1lcjtcbiAgICAgIEZvY3VzZWRFbGVtZW50U3RhdGUuaXNUYWJiaW5nID0gZmFsc2U7XG4gICAgfSwgMCk7XG4gICAgY29uc3QgbW9kYWxpemVyID0gY3R4Lm1vZGFsaXplcjtcbiAgICBjb25zdCBncm91cHBlciA9IGN0eC5ncm91cHBlcjtcbiAgICBjb25zdCBtb3ZlciA9IGN0eC5tb3ZlcjtcbiAgICBjb25zdCBjYWxsRmluZE5leHQgPSB3aGF0ID0+IHtcbiAgICAgIG5leHQgPSB3aGF0LmZpbmROZXh0VGFiYmFibGUoY3VycmVudEVsZW1lbnQsIHJlZmVyZW5jZUVsZW1lbnQsIGlzQmFja3dhcmQsIGlnbm9yZUFjY2Vzc2liaWxpdHkpO1xuICAgICAgaWYgKGN1cnJlbnRFbGVtZW50ICYmICEobmV4dCA9PT0gbnVsbCB8fCBuZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXh0LmVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSB3aGF0ICE9PSBtb2RhbGl6ZXIgJiYgZG9tLmdldFBhcmVudEVsZW1lbnQod2hhdC5nZXRFbGVtZW50KCkpO1xuICAgICAgICBpZiAocGFyZW50RWxlbWVudCkge1xuICAgICAgICAgIGNvbnN0IHBhcmVudEN0eCA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGFic3RlciwgY3VycmVudEVsZW1lbnQsIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUVsZW1lbnQ6IHBhcmVudEVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocGFyZW50Q3R4KSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U2NvcGVFbGVtZW50ID0gd2hhdC5nZXRFbGVtZW50KCk7XG4gICAgICAgICAgICBjb25zdCBuZXdDdXJyZW50ID0gaXNCYWNrd2FyZCA/IGN1cnJlbnRTY29wZUVsZW1lbnQgOiBjdXJyZW50U2NvcGVFbGVtZW50ICYmIGdldExhc3RDaGlsZCQyKGN1cnJlbnRTY29wZUVsZW1lbnQpIHx8IGN1cnJlbnRTY29wZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAobmV3Q3VycmVudCkge1xuICAgICAgICAgICAgICBuZXh0ID0gRm9jdXNlZEVsZW1lbnRTdGF0ZS5maW5kTmV4dFRhYmJhYmxlKHRhYnN0ZXIsIHBhcmVudEN0eCwgY29udGFpbmVyLCBuZXdDdXJyZW50LCBwYXJlbnRFbGVtZW50LCBpc0JhY2t3YXJkLCBpZ25vcmVBY2Nlc3NpYmlsaXR5KTtcbiAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICBuZXh0Lm91dE9mRE9NT3JkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoZ3JvdXBwZXIgJiYgbW92ZXIpIHtcbiAgICAgIGNhbGxGaW5kTmV4dChjdHguZ3JvdXBwZXJCZWZvcmVNb3ZlciA/IGdyb3VwcGVyIDogbW92ZXIpO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXBwZXIpIHtcbiAgICAgIGNhbGxGaW5kTmV4dChncm91cHBlcik7XG4gICAgfSBlbHNlIGlmIChtb3Zlcikge1xuICAgICAgY2FsbEZpbmROZXh0KG1vdmVyKTtcbiAgICB9IGVsc2UgaWYgKG1vZGFsaXplcikge1xuICAgICAgY2FsbEZpbmROZXh0KG1vZGFsaXplcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpbmRQcm9wcyA9IHtcbiAgICAgICAgY29udGFpbmVyOiBhY3R1YWxDb250YWluZXIsXG4gICAgICAgIGN1cnJlbnRFbGVtZW50LFxuICAgICAgICByZWZlcmVuY2VFbGVtZW50LFxuICAgICAgICBpZ25vcmVBY2Nlc3NpYmlsaXR5LFxuICAgICAgICB1c2VBY3RpdmVNb2RhbGl6ZXI6IHRydWVcbiAgICAgIH07XG4gICAgICBjb25zdCBmaW5kUHJvcHNPdXQgPSB7fTtcbiAgICAgIGNvbnN0IG5leHRFbGVtZW50ID0gdGFic3Rlci5mb2N1c2FibGVbaXNCYWNrd2FyZCA/IFwiZmluZFByZXZcIiA6IFwiZmluZE5leHRcIl0oZmluZFByb3BzLCBmaW5kUHJvcHNPdXQpO1xuICAgICAgbmV4dCA9IHtcbiAgICAgICAgZWxlbWVudDogbmV4dEVsZW1lbnQsXG4gICAgICAgIG91dE9mRE9NT3JkZXI6IGZpbmRQcm9wc091dC5vdXRPZkRPTU9yZGVyLFxuICAgICAgICB1bmNvbnRyb2xsZWQ6IGZpbmRQcm9wc091dC51bmNvbnRyb2xsZWRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBuZXh0O1xuICB9XG59XG5Gb2N1c2VkRWxlbWVudFN0YXRlLmlzVGFiYmluZyA9IGZhbHNlO1xuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5jbGFzcyBHcm91cHBlckR1bW15TWFuYWdlciBleHRlbmRzIER1bW15SW5wdXRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgZ3JvdXBwZXIsIHRhYnN0ZXIsIHN5cykge1xuICAgIHN1cGVyKHRhYnN0ZXIsIGVsZW1lbnQsIER1bW15SW5wdXRNYW5hZ2VyUHJpb3JpdGllcy5Hcm91cHBlciwgc3lzLCB0cnVlKTtcbiAgICB0aGlzLl9zZXRIYW5kbGVycygoZHVtbXlJbnB1dCwgaXNCYWNrd2FyZCwgcmVsYXRlZFRhcmdldCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGVsZW1lbnQuZ2V0KCk7XG4gICAgICBjb25zdCBpbnB1dCA9IGR1bW15SW5wdXQuaW5wdXQ7XG4gICAgICBpZiAoY29udGFpbmVyICYmIGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGFic3RlciwgaW5wdXQpO1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgICAgbmV4dCA9IChfYSA9IGdyb3VwcGVyLmZpbmROZXh0VGFiYmFibGUocmVsYXRlZFRhcmdldCB8fCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaXNCYWNrd2FyZCwgdHJ1ZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbGVtZW50O1xuICAgICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgbmV4dCA9IChfYiA9IEZvY3VzZWRFbGVtZW50U3RhdGUuZmluZE5leHRUYWJiYWJsZSh0YWJzdGVyLCBjdHgsIHVuZGVmaW5lZCwgZHVtbXlJbnB1dC5pc091dHNpZGUgPyBpbnB1dCA6IGdldEFkamFjZW50RWxlbWVudChjb250YWluZXIsICFpc0JhY2t3YXJkKSwgdW5kZWZpbmVkLCBpc0JhY2t3YXJkLCB0cnVlKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBuYXRpdmVGb2N1cyhuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgR3JvdXBwZXIgZXh0ZW5kcyBUYWJzdGVyUGFydCB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIsIGVsZW1lbnQsIG9uRGlzcG9zZSwgcHJvcHMsIHN5cykge1xuICAgIHN1cGVyKHRhYnN0ZXIsIGVsZW1lbnQsIHByb3BzKTtcbiAgICB0aGlzLl9zaG91bGRUYWJJbnNpZGUgPSBmYWxzZTtcbiAgICB0aGlzLm1ha2VUYWJiYWJsZShmYWxzZSk7XG4gICAgdGhpcy5fb25EaXNwb3NlID0gb25EaXNwb3NlO1xuICAgIGlmICghdGFic3Rlci5jb250cm9sVGFiKSB7XG4gICAgICB0aGlzLmR1bW15TWFuYWdlciA9IG5ldyBHcm91cHBlckR1bW15TWFuYWdlcih0aGlzLl9lbGVtZW50LCB0aGlzLCB0YWJzdGVyLCBzeXMpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLl9vbkRpc3Bvc2UodGhpcyk7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQuZ2V0KCk7XG4gICAgKF9hID0gdGhpcy5kdW1teU1hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XG4gICAgZGVsZXRlIHRoaXMuZHVtbXlNYW5hZ2VyO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgX3NldEluZm9ybWF0aXZlU3R5bGUkMSh0aGlzLl9lbGVtZW50LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX2ZpcnN0O1xuICB9XG4gIGZpbmROZXh0VGFiYmFibGUoY3VycmVudEVsZW1lbnQsIHJlZmVyZW5jZUVsZW1lbnQsIGlzQmFja3dhcmQsIGlnbm9yZUFjY2Vzc2liaWxpdHkpIHtcbiAgICBjb25zdCBncm91cHBlckVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICBpZiAoIWdyb3VwcGVyRWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRJc0R1bW15ID0gZ2V0RHVtbXlJbnB1dENvbnRhaW5lcihjdXJyZW50RWxlbWVudCkgPT09IGdyb3VwcGVyRWxlbWVudDtcbiAgICBpZiAoIXRoaXMuX3Nob3VsZFRhYkluc2lkZSAmJiBjdXJyZW50RWxlbWVudCAmJiBkb20ubm9kZUNvbnRhaW5zKGdyb3VwcGVyRWxlbWVudCwgY3VycmVudEVsZW1lbnQpICYmICFjdXJyZW50SXNEdW1teSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWxlbWVudDogdW5kZWZpbmVkLFxuICAgICAgICBvdXRPZkRPTU9yZGVyOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBncm91cHBlckZpcnN0Rm9jdXNhYmxlID0gdGhpcy5nZXRGaXJzdCh0cnVlKTtcbiAgICBpZiAoIWN1cnJlbnRFbGVtZW50IHx8ICFkb20ubm9kZUNvbnRhaW5zKGdyb3VwcGVyRWxlbWVudCwgY3VycmVudEVsZW1lbnQpIHx8IGN1cnJlbnRJc0R1bW15KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlbGVtZW50OiBncm91cHBlckZpcnN0Rm9jdXNhYmxlLFxuICAgICAgICBvdXRPZkRPTU9yZGVyOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB0YWJzdGVyID0gdGhpcy5fdGFic3RlcjtcbiAgICBsZXQgbmV4dCA9IG51bGw7XG4gICAgbGV0IG91dE9mRE9NT3JkZXIgPSBmYWxzZTtcbiAgICBsZXQgdW5jb250cm9sbGVkO1xuICAgIGlmICh0aGlzLl9zaG91bGRUYWJJbnNpZGUgJiYgZ3JvdXBwZXJGaXJzdEZvY3VzYWJsZSkge1xuICAgICAgY29uc3QgZmluZFByb3BzID0ge1xuICAgICAgICBjb250YWluZXI6IGdyb3VwcGVyRWxlbWVudCxcbiAgICAgICAgY3VycmVudEVsZW1lbnQsXG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQsXG4gICAgICAgIGlnbm9yZUFjY2Vzc2liaWxpdHksXG4gICAgICAgIHVzZUFjdGl2ZU1vZGFsaXplcjogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZpbmRQcm9wc091dCA9IHt9O1xuICAgICAgbmV4dCA9IHRhYnN0ZXIuZm9jdXNhYmxlW2lzQmFja3dhcmQgPyBcImZpbmRQcmV2XCIgOiBcImZpbmROZXh0XCJdKGZpbmRQcm9wcywgZmluZFByb3BzT3V0KTtcbiAgICAgIG91dE9mRE9NT3JkZXIgPSAhIWZpbmRQcm9wc091dC5vdXRPZkRPTU9yZGVyO1xuICAgICAgaWYgKCFuZXh0ICYmIHRoaXMuX3Byb3BzLnRhYmJhYmlsaXR5ID09PSBHcm91cHBlclRhYmJhYmlsaXRpZXMuTGltaXRlZFRyYXBGb2N1cykge1xuICAgICAgICBuZXh0ID0gdGFic3Rlci5mb2N1c2FibGVbaXNCYWNrd2FyZCA/IFwiZmluZExhc3RcIiA6IFwiZmluZEZpcnN0XCJdKHtcbiAgICAgICAgICBjb250YWluZXI6IGdyb3VwcGVyRWxlbWVudCxcbiAgICAgICAgICBpZ25vcmVBY2Nlc3NpYmlsaXR5LFxuICAgICAgICAgIHVzZUFjdGl2ZU1vZGFsaXplcjogdHJ1ZVxuICAgICAgICB9LCBmaW5kUHJvcHNPdXQpO1xuICAgICAgICBvdXRPZkRPTU9yZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHVuY29udHJvbGxlZCA9IGZpbmRQcm9wc091dC51bmNvbnRyb2xsZWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50OiBuZXh0LFxuICAgICAgdW5jb250cm9sbGVkLFxuICAgICAgb3V0T2ZET01PcmRlclxuICAgIH07XG4gIH1cbiAgbWFrZVRhYmJhYmxlKGlzVGFiYmFibGUpIHtcbiAgICB0aGlzLl9zaG91bGRUYWJJbnNpZGUgPSBpc1RhYmJhYmxlIHx8ICF0aGlzLl9wcm9wcy50YWJiYWJpbGl0eTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIF9zZXRJbmZvcm1hdGl2ZVN0eWxlJDEodGhpcy5fZWxlbWVudCwgIXRoaXMuX3Nob3VsZFRhYkluc2lkZSk7XG4gICAgfVxuICB9XG4gIGlzQWN0aXZlKG5vSWZGaXJzdElzRm9jdXNlZCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCkgfHwgbnVsbDtcbiAgICBsZXQgaXNQYXJlbnRBY3RpdmUgPSB0cnVlO1xuICAgIGZvciAobGV0IGUgPSBkb20uZ2V0UGFyZW50RWxlbWVudChlbGVtZW50KTsgZTsgZSA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGUpKSB7XG4gICAgICBjb25zdCBnID0gKF9hID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0aGlzLl90YWJzdGVyLCBlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdyb3VwcGVyO1xuICAgICAgaWYgKGcpIHtcbiAgICAgICAgaWYgKCFnLl9zaG91bGRUYWJJbnNpZGUpIHtcbiAgICAgICAgICBpc1BhcmVudEFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCByZXQgPSBpc1BhcmVudEFjdGl2ZSA/IHRoaXMuX3Byb3BzLnRhYmJhYmlsaXR5ID8gdGhpcy5fc2hvdWxkVGFiSW5zaWRlIDogZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHJldCAmJiBub0lmRmlyc3RJc0ZvY3VzZWQpIHtcbiAgICAgIGNvbnN0IGZvY3VzZWQgPSB0aGlzLl90YWJzdGVyLmZvY3VzZWRFbGVtZW50LmdldEZvY3VzZWRFbGVtZW50KCk7XG4gICAgICBpZiAoZm9jdXNlZCkge1xuICAgICAgICByZXQgPSBmb2N1c2VkICE9PSB0aGlzLmdldEZpcnN0KHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGdldEZpcnN0KG9yQ29udGFpbmVyKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGdyb3VwcGVyRWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgIGxldCBmaXJzdDtcbiAgICBpZiAoZ3JvdXBwZXJFbGVtZW50KSB7XG4gICAgICBpZiAob3JDb250YWluZXIgJiYgdGhpcy5fdGFic3Rlci5mb2N1c2FibGUuaXNGb2N1c2FibGUoZ3JvdXBwZXJFbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZ3JvdXBwZXJFbGVtZW50O1xuICAgICAgfVxuICAgICAgZmlyc3QgPSAoX2EgPSB0aGlzLl9maXJzdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldCgpO1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IHRoaXMuX3RhYnN0ZXIuZm9jdXNhYmxlLmZpbmRGaXJzdCh7XG4gICAgICAgICAgY29udGFpbmVyOiBncm91cHBlckVsZW1lbnQsXG4gICAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlXG4gICAgICAgIH0pIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgdGhpcy5zZXRGaXJzdChmaXJzdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0O1xuICB9XG4gIHNldEZpcnN0KGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fZmlyc3QgPSBuZXcgV2Vha0hUTUxFbGVtZW50KHRoaXMuX3RhYnN0ZXIuZ2V0V2luZG93LCBlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuX2ZpcnN0O1xuICAgIH1cbiAgfVxuICBhY2NlcHRFbGVtZW50KGVsZW1lbnQsIHN0YXRlKSB7XG4gICAgY29uc3QgY2FjaGVkR3JvdXBwZXJzID0gc3RhdGUuY2FjaGVkR3JvdXBwZXJzO1xuICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBkb20uZ2V0UGFyZW50RWxlbWVudCh0aGlzLmdldEVsZW1lbnQoKSk7XG4gICAgY29uc3QgcGFyZW50Q3R4ID0gcGFyZW50RWxlbWVudCAmJiBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRoaXMuX3RhYnN0ZXIsIHBhcmVudEVsZW1lbnQpO1xuICAgIGNvbnN0IHBhcmVudEN0eEdyb3VwcGVyID0gcGFyZW50Q3R4ID09PSBudWxsIHx8IHBhcmVudEN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50Q3R4Lmdyb3VwcGVyO1xuICAgIGNvbnN0IHBhcmVudEdyb3VwcGVyID0gKHBhcmVudEN0eCA9PT0gbnVsbCB8fCBwYXJlbnRDdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudEN0eC5ncm91cHBlckJlZm9yZU1vdmVyKSA/IHBhcmVudEN0eEdyb3VwcGVyIDogdW5kZWZpbmVkO1xuICAgIGxldCBwYXJlbnRHcm91cHBlckVsZW1lbnQ7XG4gICAgY29uc3QgZ2V0SXNBY3RpdmUgPSBncm91cHBlciA9PiB7XG4gICAgICBsZXQgY2FjaGVkID0gY2FjaGVkR3JvdXBwZXJzW2dyb3VwcGVyLmlkXTtcbiAgICAgIGxldCBpc0FjdGl2ZTtcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgaXNBY3RpdmUgPSBjYWNoZWQuaXNBY3RpdmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0FjdGl2ZSA9IHRoaXMuaXNBY3RpdmUodHJ1ZSk7XG4gICAgICAgIGNhY2hlZCA9IGNhY2hlZEdyb3VwcGVyc1tncm91cHBlci5pZF0gPSB7XG4gICAgICAgICAgaXNBY3RpdmVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FjdGl2ZTtcbiAgICB9O1xuICAgIGlmIChwYXJlbnRHcm91cHBlcikge1xuICAgICAgcGFyZW50R3JvdXBwZXJFbGVtZW50ID0gcGFyZW50R3JvdXBwZXIuZ2V0RWxlbWVudCgpO1xuICAgICAgaWYgKCFnZXRJc0FjdGl2ZShwYXJlbnRHcm91cHBlcikgJiYgcGFyZW50R3JvdXBwZXJFbGVtZW50ICYmIHN0YXRlLmNvbnRhaW5lciAhPT0gcGFyZW50R3JvdXBwZXJFbGVtZW50ICYmIGRvbS5ub2RlQ29udGFpbnMoc3RhdGUuY29udGFpbmVyLCBwYXJlbnRHcm91cHBlckVsZW1lbnQpKSB7XG4gICAgICAgIC8vIERvIG5vdCBmYWxsIGludG8gYSBjaGlsZCBncm91cHBlciBvZiBpbmFjdGl2ZSBwYXJlbnQgZ3JvdXBwZXIgaWYgaXQncyBpbiB0aGUgc2NvcGUgb2YgdGhlIHNlYXJjaC5cbiAgICAgICAgc3RhdGUuc2tpcHBlZEZvY3VzYWJsZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1Q7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlzQWN0aXZlID0gZ2V0SXNBY3RpdmUodGhpcyk7XG4gICAgY29uc3QgZ3JvdXBwZXJFbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgaWYgKGdyb3VwcGVyRWxlbWVudCkge1xuICAgICAgaWYgKGlzQWN0aXZlICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChncm91cHBlckVsZW1lbnQgPT09IGVsZW1lbnQgJiYgcGFyZW50Q3R4R3JvdXBwZXIpIHtcbiAgICAgICAgICBpZiAoIXBhcmVudEdyb3VwcGVyRWxlbWVudCkge1xuICAgICAgICAgICAgcGFyZW50R3JvdXBwZXJFbGVtZW50ID0gcGFyZW50Q3R4R3JvdXBwZXIuZ2V0RWxlbWVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyZW50R3JvdXBwZXJFbGVtZW50ICYmICFnZXRJc0FjdGl2ZShwYXJlbnRDdHhHcm91cHBlcikgJiYgZG9tLm5vZGVDb250YWlucyhzdGF0ZS5jb250YWluZXIsIHBhcmVudEdyb3VwcGVyRWxlbWVudCkgJiYgcGFyZW50R3JvdXBwZXJFbGVtZW50ICE9PSBzdGF0ZS5jb250YWluZXIpIHtcbiAgICAgICAgICAgIHN0YXRlLnNraXBwZWRGb2N1c2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwcGVyRWxlbWVudCAhPT0gZWxlbWVudCAmJiBkb20ubm9kZUNvbnRhaW5zKGdyb3VwcGVyRWxlbWVudCwgZWxlbWVudCkpIHtcbiAgICAgICAgICBzdGF0ZS5za2lwcGVkRm9jdXNhYmxlID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlZEdyb3VwcGVyc1t0aGlzLmlkXTtcbiAgICAgICAgbGV0IGZpcnN0O1xuICAgICAgICBpZiAoXCJmaXJzdFwiIGluIGNhY2hlZCkge1xuICAgICAgICAgIGZpcnN0ID0gY2FjaGVkLmZpcnN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpcnN0ID0gY2FjaGVkLmZpcnN0ID0gdGhpcy5nZXRGaXJzdCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3QgJiYgc3RhdGUuYWNjZXB0Q29uZGl0aW9uKGZpcnN0KSkge1xuICAgICAgICAgIHN0YXRlLnJlamVjdEVsZW1lbnRzRnJvbSA9IGdyb3VwcGVyRWxlbWVudDtcbiAgICAgICAgICBzdGF0ZS5za2lwcGVkRm9jdXNhYmxlID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZmlyc3QgIT09IHN0YXRlLmZyb20pIHtcbiAgICAgICAgICAgIHN0YXRlLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXRlLmZvdW5kRWxlbWVudCA9IGZpcnN0O1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuY2xhc3MgR3JvdXBwZXJBUEkge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyLCBnZXRXaW5kb3cpIHtcbiAgICB0aGlzLl9jdXJyZW50ID0ge307XG4gICAgdGhpcy5fZ3JvdXBwZXJzID0ge307XG4gICAgdGhpcy5faW5pdCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgICAgLy8gTWFraW5nIHN1cmUgZ3JvdXBwZXIncyBvbkZvY3VzIGlzIGNhbGxlZCBiZWZvcmUgbW9kYWxpemVyJ3Mgb25Gb2N1cy5cbiAgICAgIHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuc3Vic2NyaWJlRmlyc3QodGhpcy5fb25Gb2N1cyk7XG4gICAgICBjb25zdCBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9tLmdldEFjdGl2ZUVsZW1lbnQoZG9jKTtcbiAgICAgIGlmIChhY3RpdmVFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX29uRm9jdXMoYWN0aXZlRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9vbk1vdXNlRG93biwgdHJ1ZSk7XG4gICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fb25LZXlEb3duLCB0cnVlKTtcbiAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKEdyb3VwcGVyTW92ZUZvY3VzRXZlbnROYW1lLCB0aGlzLl9vbk1vdmVGb2N1cyk7XG4gICAgfTtcbiAgICB0aGlzLl9vbkdyb3VwcGVyRGlzcG9zZSA9IGdyb3VwcGVyID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ncm91cHBlcnNbZ3JvdXBwZXIuaWRdO1xuICAgIH07XG4gICAgdGhpcy5fb25Gb2N1cyA9IGVsZW1lbnQgPT4ge1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ3VycmVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX29uTW91c2VEb3duID0gZSA9PiB7XG4gICAgICBsZXQgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICB3aGlsZSAodGFyZ2V0ICYmICF0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5pc0ZvY3VzYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgIHRhcmdldCA9IHRoaXMuX3RhYnN0ZXIuZ2V0UGFyZW50KHRhcmdldCk7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUN1cnJlbnQodGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX29uS2V5RG93biA9IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC5rZXkgIT09IEtleXMuRW50ZXIgJiYgZXZlbnQua2V5ICE9PSBLZXlzLkVzY2FwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBHaXZlIGEgY2hhbmNlIHRvIG90aGVyIGxpc3RlbmVycyB0byBoYW5kbGUgdGhlIGV2ZW50LlxuICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZ2V0Rm9jdXNlZEVsZW1lbnQoKTtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuaGFuZGxlS2V5UHJlc3MoZWxlbWVudCwgZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25Nb3ZlRm9jdXMgPSBlID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlLmNvbXBvc2VkUGF0aCgpWzBdO1xuICAgICAgY29uc3QgYWN0aW9uID0gKF9hID0gZS5kZXRhaWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3Rpb247XG4gICAgICBpZiAoZWxlbWVudCAmJiBhY3Rpb24gIT09IHVuZGVmaW5lZCAmJiAhZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGlmIChhY3Rpb24gPT09IEdyb3VwcGVyTW92ZUZvY3VzQWN0aW9ucy5FbnRlcikge1xuICAgICAgICAgIHRoaXMuX2VudGVyR3JvdXBwZXIoZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZXNjYXBlR3JvdXBwZXIoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX3RhYnN0ZXIgPSB0YWJzdGVyO1xuICAgIHRoaXMuX3dpbiA9IGdldFdpbmRvdztcbiAgICB0YWJzdGVyLnF1ZXVlSW5pdCh0aGlzLl9pbml0KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgIHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuY2FuY2VsQXN5bmNGb2N1cyhBc3luY0ZvY3VzU291cmNlcy5Fc2NhcGVHcm91cHBlcik7XG4gICAgdGhpcy5fY3VycmVudCA9IHt9O1xuICAgIGlmICh0aGlzLl91cGRhdGVUaW1lcikge1xuICAgICAgd2luLmNsZWFyVGltZW91dCh0aGlzLl91cGRhdGVUaW1lcik7XG4gICAgICBkZWxldGUgdGhpcy5fdXBkYXRlVGltZXI7XG4gICAgfVxuICAgIHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQudW5zdWJzY3JpYmUodGhpcy5fb25Gb2N1cyk7XG4gICAgd2luLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5fb25Nb3VzZURvd24sIHRydWUpO1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9vbktleURvd24sIHRydWUpO1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEdyb3VwcGVyTW92ZUZvY3VzRXZlbnROYW1lLCB0aGlzLl9vbk1vdmVGb2N1cyk7XG4gICAgT2JqZWN0LmtleXModGhpcy5fZ3JvdXBwZXJzKS5mb3JFYWNoKGdyb3VwcGVySWQgPT4ge1xuICAgICAgaWYgKHRoaXMuX2dyb3VwcGVyc1tncm91cHBlcklkXSkge1xuICAgICAgICB0aGlzLl9ncm91cHBlcnNbZ3JvdXBwZXJJZF0uZGlzcG9zZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5fZ3JvdXBwZXJzW2dyb3VwcGVySWRdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUdyb3VwcGVyKGVsZW1lbnQsIHByb3BzLCBzeXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIDtcbiAgICBjb25zdCB0YWJzdGVyID0gdGhpcy5fdGFic3RlcjtcbiAgICBjb25zdCBuZXdHcm91cHBlciA9IG5ldyBHcm91cHBlcih0YWJzdGVyLCBlbGVtZW50LCB0aGlzLl9vbkdyb3VwcGVyRGlzcG9zZSwgcHJvcHMsIHN5cyk7XG4gICAgdGhpcy5fZ3JvdXBwZXJzW25ld0dyb3VwcGVyLmlkXSA9IG5ld0dyb3VwcGVyO1xuICAgIGNvbnN0IGZvY3VzZWRFbGVtZW50ID0gdGFic3Rlci5mb2N1c2VkRWxlbWVudC5nZXRGb2N1c2VkRWxlbWVudCgpO1xuICAgIC8vIE5ld2x5IGNyZWF0ZWQgZ3JvdXBwZXIgY29udGFpbnMgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCwgdXBkYXRlIHRoZSBzdGF0ZSBvbiB0aGUgbmV4dCB0aWNrICh0b1xuICAgIC8vIG1ha2Ugc3VyZSBhbGwgZ3JvdXBwZXJzIGFyZSBwcm9jZXNzZWQpLlxuICAgIGlmIChmb2N1c2VkRWxlbWVudCAmJiBkb20ubm9kZUNvbnRhaW5zKGVsZW1lbnQsIGZvY3VzZWRFbGVtZW50KSAmJiAhdGhpcy5fdXBkYXRlVGltZXIpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVRpbWVyID0gdGhpcy5fd2luKCkuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVUaW1lcjtcbiAgICAgICAgLy8gTWFraW5nIHN1cmUgdGhlIGZvY3VzZWQgZWxlbWVudCBoYXNuJ3QgY2hhbmdlZC5cbiAgICAgICAgaWYgKGZvY3VzZWRFbGVtZW50ID09PSB0YWJzdGVyLmZvY3VzZWRFbGVtZW50LmdldEZvY3VzZWRFbGVtZW50KCkpIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVDdXJyZW50KGZvY3VzZWRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdHcm91cHBlcjtcbiAgfVxuICBmb3JnZXRDdXJyZW50R3JvdXBwZXJzKCkge1xuICAgIHRoaXMuX2N1cnJlbnQgPSB7fTtcbiAgfVxuICBfdXBkYXRlQ3VycmVudChlbGVtZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0aGlzLl91cGRhdGVUaW1lcikge1xuICAgICAgdGhpcy5fd2luKCkuY2xlYXJUaW1lb3V0KHRoaXMuX3VwZGF0ZVRpbWVyKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVUaW1lcjtcbiAgICB9XG4gICAgY29uc3QgdGFic3RlciA9IHRoaXMuX3RhYnN0ZXI7XG4gICAgY29uc3QgbmV3SWRzID0ge307XG4gICAgZm9yIChsZXQgZWwgPSB0YWJzdGVyLmdldFBhcmVudChlbGVtZW50KTsgZWw7IGVsID0gdGFic3Rlci5nZXRQYXJlbnQoZWwpKSB7XG4gICAgICBjb25zdCBncm91cHBlciA9IChfYSA9IGdldFRhYnN0ZXJPbkVsZW1lbnQodGFic3RlciwgZWwpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ3JvdXBwZXI7XG4gICAgICBpZiAoZ3JvdXBwZXIpIHtcbiAgICAgICAgbmV3SWRzW2dyb3VwcGVyLmlkXSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRbZ3JvdXBwZXIuaWRdID0gZ3JvdXBwZXI7XG4gICAgICAgIGNvbnN0IGlzVGFiYmFibGUgPSBncm91cHBlci5pc0FjdGl2ZSgpIHx8IGVsZW1lbnQgIT09IGVsICYmICghZ3JvdXBwZXIuZ2V0UHJvcHMoKS5kZWxlZ2F0ZWQgfHwgZ3JvdXBwZXIuZ2V0Rmlyc3QoZmFsc2UpICE9PSBlbGVtZW50KTtcbiAgICAgICAgZ3JvdXBwZXIubWFrZVRhYmJhYmxlKGlzVGFiYmFibGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKHRoaXMuX2N1cnJlbnQpKSB7XG4gICAgICBjb25zdCBncm91cHBlciA9IHRoaXMuX2N1cnJlbnRbaWRdO1xuICAgICAgaWYgKCEoZ3JvdXBwZXIuaWQgaW4gbmV3SWRzKSkge1xuICAgICAgICBncm91cHBlci5tYWtlVGFiYmFibGUoZmFsc2UpO1xuICAgICAgICBncm91cHBlci5zZXRGaXJzdCh1bmRlZmluZWQpO1xuICAgICAgICBkZWxldGUgdGhpcy5fY3VycmVudFtpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9lbnRlckdyb3VwcGVyKGVsZW1lbnQsIHJlbGF0ZWRFdmVudCkge1xuICAgIGNvbnN0IHRhYnN0ZXIgPSB0aGlzLl90YWJzdGVyO1xuICAgIGNvbnN0IGN0eCA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGFic3RlciwgZWxlbWVudCk7XG4gICAgY29uc3QgZ3JvdXBwZXIgPSAoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4Lmdyb3VwcGVyKSB8fCAoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4Lm1vZGFsaXplckluR3JvdXBwZXIpO1xuICAgIGNvbnN0IGdyb3VwcGVyRWxlbWVudCA9IGdyb3VwcGVyID09PSBudWxsIHx8IGdyb3VwcGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBncm91cHBlci5nZXRFbGVtZW50KCk7XG4gICAgaWYgKGdyb3VwcGVyICYmIGdyb3VwcGVyRWxlbWVudCAmJiAoZWxlbWVudCA9PT0gZ3JvdXBwZXJFbGVtZW50IHx8IGdyb3VwcGVyLmdldFByb3BzKCkuZGVsZWdhdGVkICYmIGVsZW1lbnQgPT09IGdyb3VwcGVyLmdldEZpcnN0KGZhbHNlKSkpIHtcbiAgICAgIGNvbnN0IG5leHQgPSB0YWJzdGVyLmZvY3VzYWJsZS5maW5kTmV4dCh7XG4gICAgICAgIGNvbnRhaW5lcjogZ3JvdXBwZXJFbGVtZW50LFxuICAgICAgICBjdXJyZW50RWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmIChuZXh0ICYmICghcmVsYXRlZEV2ZW50IHx8IHJlbGF0ZWRFdmVudCAmJiBncm91cHBlckVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgVGFic3Rlck1vdmVGb2N1c0V2ZW50KHtcbiAgICAgICAgYnk6IFwiZ3JvdXBwZXJcIixcbiAgICAgICAgb3duZXI6IGdyb3VwcGVyRWxlbWVudCxcbiAgICAgICAgbmV4dCxcbiAgICAgICAgcmVsYXRlZEV2ZW50XG4gICAgICB9KSkpKSB7XG4gICAgICAgIGlmIChyZWxhdGVkRXZlbnQpIHtcbiAgICAgICAgICAvLyBXaGVuIHRoZSBhcHBsaWNhdGlvbiBoYXNuJ3QgcHJldmVudGVkIGRlZmF1bHQsXG4gICAgICAgICAgLy8gd2UgY29uc2lkZXIgdGhlIGV2ZW50IGNvbXBsZXRlbHkgaGFuZGxlZCwgaGVuY2Ugd2VcbiAgICAgICAgICAvLyBwcmV2ZW50IHRoZSBpbml0aWFsIGV2ZW50J3MgZGVmYXVsdCBhY3Rpb24gYW5kIHN0b3BcbiAgICAgICAgICAvLyBwcm9wYWdhdGlvbi5cbiAgICAgICAgICByZWxhdGVkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZWxhdGVkRXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5mb2N1cygpO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX2VzY2FwZUdyb3VwcGVyKGVsZW1lbnQsIHJlbGF0ZWRFdmVudCwgZnJvbU1vZGFsaXplcikge1xuICAgIGNvbnN0IHRhYnN0ZXIgPSB0aGlzLl90YWJzdGVyO1xuICAgIGNvbnN0IGN0eCA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGFic3RlciwgZWxlbWVudCk7XG4gICAgbGV0IGdyb3VwcGVyID0gKGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5ncm91cHBlcikgfHwgKGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5tb2RhbGl6ZXJJbkdyb3VwcGVyKTtcbiAgICBjb25zdCBncm91cHBlckVsZW1lbnQgPSBncm91cHBlciA9PT0gbnVsbCB8fCBncm91cHBlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JvdXBwZXIuZ2V0RWxlbWVudCgpO1xuICAgIGlmIChncm91cHBlciAmJiBncm91cHBlckVsZW1lbnQgJiYgZG9tLm5vZGVDb250YWlucyhncm91cHBlckVsZW1lbnQsIGVsZW1lbnQpKSB7XG4gICAgICBsZXQgbmV4dDtcbiAgICAgIGlmIChlbGVtZW50ICE9PSBncm91cHBlckVsZW1lbnQgfHwgZnJvbU1vZGFsaXplcikge1xuICAgICAgICBuZXh0ID0gZ3JvdXBwZXIuZ2V0Rmlyc3QodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwYXJlbnRFbGVtZW50ID0gZG9tLmdldFBhcmVudEVsZW1lbnQoZ3JvdXBwZXJFbGVtZW50KTtcbiAgICAgICAgY29uc3QgcGFyZW50Q3R4ID0gcGFyZW50RWxlbWVudCA/IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGFic3RlciwgcGFyZW50RWxlbWVudCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGdyb3VwcGVyID0gcGFyZW50Q3R4ID09PSBudWxsIHx8IHBhcmVudEN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50Q3R4Lmdyb3VwcGVyO1xuICAgICAgICBuZXh0ID0gZ3JvdXBwZXIgPT09IG51bGwgfHwgZ3JvdXBwZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyb3VwcGVyLmdldEZpcnN0KHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKG5leHQgJiYgKCFyZWxhdGVkRXZlbnQgfHwgcmVsYXRlZEV2ZW50ICYmIGdyb3VwcGVyRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBUYWJzdGVyTW92ZUZvY3VzRXZlbnQoe1xuICAgICAgICBieTogXCJncm91cHBlclwiLFxuICAgICAgICBvd25lcjogZ3JvdXBwZXJFbGVtZW50LFxuICAgICAgICBuZXh0LFxuICAgICAgICByZWxhdGVkRXZlbnRcbiAgICAgIH0pKSkpIHtcbiAgICAgICAgaWYgKGdyb3VwcGVyKSB7XG4gICAgICAgICAgZ3JvdXBwZXIubWFrZVRhYmJhYmxlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHBhcnQgaGFwcGVucyBhc3luY2hyb25vdXNseSBpbnNpZGUgc2V0VGltZW91dCxcbiAgICAgICAgLy8gc28gbm8gbmVlZCB0byBwcmV2ZW50IGRlZmF1bHQgb3Igc3RvcCBwcm9wYWdhdGlvbi5cbiAgICAgICAgbmV4dC5mb2N1cygpO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbW92ZUZvY3VzKGVsZW1lbnQsIGFjdGlvbikge1xuICAgIHJldHVybiBhY3Rpb24gPT09IEdyb3VwcGVyTW92ZUZvY3VzQWN0aW9ucy5FbnRlciA/IHRoaXMuX2VudGVyR3JvdXBwZXIoZWxlbWVudCkgOiB0aGlzLl9lc2NhcGVHcm91cHBlcihlbGVtZW50KTtcbiAgfVxuICBoYW5kbGVLZXlQcmVzcyhlbGVtZW50LCBldmVudCwgZnJvbU1vZGFsaXplcikge1xuICAgIGNvbnN0IHRhYnN0ZXIgPSB0aGlzLl90YWJzdGVyO1xuICAgIGNvbnN0IGN0eCA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGFic3RlciwgZWxlbWVudCk7XG4gICAgaWYgKGN0eCAmJiAoKGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5ncm91cHBlcikgfHwgKGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5tb2RhbGl6ZXJJbkdyb3VwcGVyKSkpIHtcbiAgICAgIHRhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuY2FuY2VsQXN5bmNGb2N1cyhBc3luY0ZvY3VzU291cmNlcy5Fc2NhcGVHcm91cHBlcik7XG4gICAgICBpZiAoY3R4Lmlnbm9yZUtleWRvd24oZXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXkgPT09IEtleXMuRW50ZXIpIHtcbiAgICAgICAgdGhpcy5fZW50ZXJHcm91cHBlcihlbGVtZW50LCBldmVudCk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gS2V5cy5Fc2NhcGUpIHtcbiAgICAgICAgLy8gV2Ugd2lsbCBoYW5kbGUgRXNjIGFzeW5jaHJvbm91c2x5LCBpZiBzb21ldGhpbmcgaW4gdGhlIGFwcGxpY2F0aW9uIHdpbGxcbiAgICAgICAgLy8gbW92ZSBmb2N1cyBkdXJpbmcgdGhlIGtleXByZXNzIGhhbmRsaW5nLCB3ZSB3aWxsIG5vdCBpbnRlcmZlcmUuXG4gICAgICAgIGNvbnN0IGZvY3VzZWRFbGVtZW50ID0gdGFic3Rlci5mb2N1c2VkRWxlbWVudC5nZXRGb2N1c2VkRWxlbWVudCgpO1xuICAgICAgICB0YWJzdGVyLmZvY3VzZWRFbGVtZW50LnJlcXVlc3RBc3luY0ZvY3VzKEFzeW5jRm9jdXNTb3VyY2VzLkVzY2FwZUdyb3VwcGVyLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKGZvY3VzZWRFbGVtZW50ICE9PSB0YWJzdGVyLmZvY3VzZWRFbGVtZW50LmdldEZvY3VzZWRFbGVtZW50KCkgJiYgKFxuICAgICAgICAgIC8vIEEgcGFydCBvZiBNb2RhbGl6ZXIgdGhhdCBoYXMgY2FsbGVkIHRoaXMgaGFuZGxlciB0byBlc2NhcGUgdGhlIGFjdGl2ZSBncm91cHBlclxuICAgICAgICAgIC8vIG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gRE9NLCBpZiB0aGUgZm9jdXMgaXMgb24gYm9keSwgd2Ugc3RpbGwgd2FudCB0byBoYW5kbGUgRXNjLlxuICAgICAgICAgIGZyb21Nb2RhbGl6ZXIgJiYgIWZvY3VzZWRFbGVtZW50IHx8ICFmcm9tTW9kYWxpemVyKSkge1xuICAgICAgICAgICAgLy8gU29tZXRoaW5nIGVsc2UgaW4gdGhlIGFwcGxpY2F0aW9uIGhhcyBtb3ZlZCBmb2N1cywgd2Ugd2lsbCBub3QgaGFuZGxlIEVzYy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZXNjYXBlR3JvdXBwZXIoZWxlbWVudCwgZXZlbnQsIGZyb21Nb2RhbGl6ZXIpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9zZXRJbmZvcm1hdGl2ZVN0eWxlJDEod2Vha0VsZW1lbnQsIHJlbW92ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gd2Vha0VsZW1lbnQuZ2V0KCk7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcIi0tdGFic3Rlci1ncm91cHBlclwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLXRhYnN0ZXItZ3JvdXBwZXJcIiwgXCJ1bmxpbWl0ZWRcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEtleWJvYXJkTmF2aWdhdGlvblN0YXRlIGV4dGVuZHMgU3Vic2NyaWJhYmxlIHtcbiAgY29uc3RydWN0b3IoZ2V0V2luZG93KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9vbkNoYW5nZSA9IGlzTmF2aWdhdGluZ1dpdGhLZXlib2FyZCA9PiB7XG4gICAgICB0aGlzLnNldFZhbChpc05hdmlnYXRpbmdXaXRoS2V5Ym9hcmQsIHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICB0aGlzLl9rZXlib3JnID0gY3JlYXRlS2V5Ym9yZyhnZXRXaW5kb3coKSk7XG4gICAgdGhpcy5fa2V5Ym9yZy5zdWJzY3JpYmUodGhpcy5fb25DaGFuZ2UpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIGlmICh0aGlzLl9rZXlib3JnKSB7XG4gICAgICB0aGlzLl9rZXlib3JnLnVuc3Vic2NyaWJlKHRoaXMuX29uQ2hhbmdlKTtcbiAgICAgIGRpc3Bvc2VLZXlib3JnKHRoaXMuX2tleWJvcmcpO1xuICAgICAgZGVsZXRlIHRoaXMuX2tleWJvcmc7XG4gICAgfVxuICB9XG4gIHNldE5hdmlnYXRpbmdXaXRoS2V5Ym9hcmQoaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuX2tleWJvcmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRWYWwoaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkKTtcbiAgfVxuICBpc05hdmlnYXRpbmdXaXRoS2V5Ym9hcmQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAhISgoX2EgPSB0aGlzLl9rZXlib3JnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkKCkpO1xuICB9XG59XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmxldCBfd2FzRm9jdXNlZENvdW50ZXIgPSAwO1xuY29uc3QgX2FyaWFIaWRkZW4gPSBcImFyaWEtaGlkZGVuXCI7XG5mdW5jdGlvbiBfc2V0SW5mb3JtYXRpdmVTdHlsZSh3ZWFrRWxlbWVudCwgcmVtb3ZlLCBpbnRlcm5hbElkLCB1c2VySWQsIGlzQWN0aXZlLCB3YXNGb2N1c2VkKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB3ZWFrRWxlbWVudC5nZXQoKTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiLS10YWJzdGVyLW1vZGFsaXplclwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLXRhYnN0ZXItbW9kYWxpemVyXCIsIGludGVybmFsSWQgKyBcIixcIiArIHVzZXJJZCArIFwiLFwiICsgKGlzQWN0aXZlID8gXCJhY3RpdmVcIiA6IFwiaW5hY3RpdmVcIikgKyBcIixcIiArIFwiLFwiICsgKHdhc0ZvY3VzZWQgPyBgZm9jdXNlZCgke3dhc0ZvY3VzZWR9KWAgOiBcIm5vdC1mb2N1c2VkXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogTWFuYWdlcyB0aGUgZHVtbXkgaW5wdXRzIGZvciB0aGUgTW9kYWxpemVyLlxuICovXG5jbGFzcyBNb2RhbGl6ZXJEdW1teU1hbmFnZXIgZXh0ZW5kcyBEdW1teUlucHV0TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHRhYnN0ZXIsIHN5cykge1xuICAgIHN1cGVyKHRhYnN0ZXIsIGVsZW1lbnQsIER1bW15SW5wdXRNYW5hZ2VyUHJpb3JpdGllcy5Nb2RhbGl6ZXIsIHN5cyk7XG4gICAgdGhpcy5fc2V0SGFuZGxlcnMoKGR1bW15SW5wdXQsIGlzQmFja3dhcmQpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBlbCA9IGVsZW1lbnQuZ2V0KCk7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBlbCAmJiAoKF9hID0gUm9vdEFQSS5nZXRSb290KHRhYnN0ZXIsIGVsKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEVsZW1lbnQoKSk7XG4gICAgICBjb25zdCBpbnB1dCA9IGR1bW15SW5wdXQuaW5wdXQ7XG4gICAgICBsZXQgdG9Gb2N1cztcbiAgICAgIGlmIChjb250YWluZXIgJiYgaW5wdXQpIHtcbiAgICAgICAgY29uc3QgZHVtbXlDb250YWluZXIgPSBnZXREdW1teUlucHV0Q29udGFpbmVyKGlucHV0KTtcbiAgICAgICAgY29uc3QgY3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0YWJzdGVyLCBkdW1teUNvbnRhaW5lciB8fCBpbnB1dCk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICB0b0ZvY3VzID0gKF9iID0gRm9jdXNlZEVsZW1lbnRTdGF0ZS5maW5kTmV4dFRhYmJhYmxlKHRhYnN0ZXIsIGN0eCwgY29udGFpbmVyLCBpbnB1dCwgdW5kZWZpbmVkLCBpc0JhY2t3YXJkLCB0cnVlKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvRm9jdXMpIHtcbiAgICAgICAgICBuYXRpdmVGb2N1cyh0b0ZvY3VzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBNb2RhbGl6ZXIgZXh0ZW5kcyBUYWJzdGVyUGFydCB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIsIGVsZW1lbnQsIG9uRGlzcG9zZSwgcHJvcHMsIHN5cywgYWN0aXZlRWxlbWVudHMpIHtcbiAgICBzdXBlcih0YWJzdGVyLCBlbGVtZW50LCBwcm9wcyk7XG4gICAgdGhpcy5fd2FzRm9jdXNlZCA9IDA7XG4gICAgdGhpcy51c2VySWQgPSBwcm9wcy5pZDtcbiAgICB0aGlzLl9vbkRpc3Bvc2UgPSBvbkRpc3Bvc2U7XG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudHMgPSBhY3RpdmVFbGVtZW50cztcbiAgICBpZiAoIXRhYnN0ZXIuY29udHJvbFRhYikge1xuICAgICAgdGhpcy5kdW1teU1hbmFnZXIgPSBuZXcgTW9kYWxpemVyRHVtbXlNYW5hZ2VyKHRoaXMuX2VsZW1lbnQsIHRhYnN0ZXIsIHN5cyk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgX3NldEluZm9ybWF0aXZlU3R5bGUodGhpcy5fZWxlbWVudCwgZmFsc2UsIHRoaXMuaWQsIHRoaXMudXNlcklkLCB0aGlzLl9pc0FjdGl2ZSwgdGhpcy5fd2FzRm9jdXNlZCk7XG4gICAgfVxuICB9XG4gIG1ha2VBY3RpdmUoaXNBY3RpdmUpIHtcbiAgICBpZiAodGhpcy5faXNBY3RpdmUgIT09IGlzQWN0aXZlKSB7XG4gICAgICB0aGlzLl9pc0FjdGl2ZSA9IGlzQWN0aXZlO1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudHMgPSB0aGlzLl9hY3RpdmVFbGVtZW50cztcbiAgICAgICAgY29uc3QgaW5kZXggPSBhY3RpdmVFbGVtZW50cy5tYXAoZSA9PiBlLmdldCgpKS5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBhY3RpdmVFbGVtZW50cy5wdXNoKG5ldyBXZWFrSFRNTEVsZW1lbnQodGhpcy5fdGFic3Rlci5nZXRXaW5kb3csIGVsZW1lbnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgX3NldEluZm9ybWF0aXZlU3R5bGUodGhpcy5fZWxlbWVudCwgZmFsc2UsIHRoaXMuaWQsIHRoaXMudXNlcklkLCB0aGlzLl9pc0FjdGl2ZSwgdGhpcy5fd2FzRm9jdXNlZCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KGlzQWN0aXZlKTtcbiAgICB9XG4gIH1cbiAgZm9jdXNlZChub0luY3JlbWVudCkge1xuICAgIGlmICghbm9JbmNyZW1lbnQpIHtcbiAgICAgIHRoaXMuX3dhc0ZvY3VzZWQgPSArK193YXNGb2N1c2VkQ291bnRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dhc0ZvY3VzZWQ7XG4gIH1cbiAgc2V0UHJvcHMocHJvcHMpIHtcbiAgICBpZiAocHJvcHMuaWQpIHtcbiAgICAgIHRoaXMudXNlcklkID0gcHJvcHMuaWQ7XG4gICAgfVxuICAgIHRoaXMuX3Byb3BzID0ge1xuICAgICAgLi4ucHJvcHNcbiAgICB9O1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMubWFrZUFjdGl2ZShmYWxzZSk7XG4gICAgdGhpcy5fb25EaXNwb3NlKHRoaXMpO1xuICAgIChfYSA9IHRoaXMuZHVtbXlNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xuICAgIGRlbGV0ZSB0aGlzLmR1bW15TWFuYWdlcjtcbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuX3JlbW92ZSgpO1xuICB9XG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2lzQWN0aXZlO1xuICB9XG4gIGNvbnRhaW5zKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9tLm5vZGVDb250YWlucyh0aGlzLmdldEVsZW1lbnQoKSwgZWxlbWVudCk7XG4gIH1cbiAgZmluZE5leHRUYWJiYWJsZShjdXJyZW50RWxlbWVudCwgcmVmZXJlbmNlRWxlbWVudCwgaXNCYWNrd2FyZCwgaWdub3JlQWNjZXNzaWJpbGl0eSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgbW9kYWxpemVyRWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgIGlmICghbW9kYWxpemVyRWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRhYnN0ZXIgPSB0aGlzLl90YWJzdGVyO1xuICAgIGxldCBuZXh0ID0gbnVsbDtcbiAgICBsZXQgb3V0T2ZET01PcmRlciA9IGZhbHNlO1xuICAgIGxldCB1bmNvbnRyb2xsZWQ7XG4gICAgY29uc3QgY29udGFpbmVyID0gY3VycmVudEVsZW1lbnQgJiYgKChfYSA9IFJvb3RBUEkuZ2V0Um9vdCh0YWJzdGVyLCBjdXJyZW50RWxlbWVudCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRFbGVtZW50KCkpO1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIGNvbnN0IGZpbmRQcm9wcyA9IHtcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBjdXJyZW50RWxlbWVudCxcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCxcbiAgICAgICAgaWdub3JlQWNjZXNzaWJpbGl0eSxcbiAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlXG4gICAgICB9O1xuICAgICAgY29uc3QgZmluZFByb3BzT3V0ID0ge307XG4gICAgICBuZXh0ID0gdGFic3Rlci5mb2N1c2FibGVbaXNCYWNrd2FyZCA/IFwiZmluZFByZXZcIiA6IFwiZmluZE5leHRcIl0oZmluZFByb3BzLCBmaW5kUHJvcHNPdXQpO1xuICAgICAgaWYgKCFuZXh0ICYmIHRoaXMuX3Byb3BzLmlzVHJhcHBlZCAmJiAoKF9iID0gdGFic3Rlci5tb2RhbGl6ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY3RpdmVJZCkpIHtcbiAgICAgICAgbmV4dCA9IHRhYnN0ZXIuZm9jdXNhYmxlW2lzQmFja3dhcmQgPyBcImZpbmRMYXN0XCIgOiBcImZpbmRGaXJzdFwiXSh7XG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGlnbm9yZUFjY2Vzc2liaWxpdHksXG4gICAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlXG4gICAgICAgIH0sIGZpbmRQcm9wc091dCk7XG4gICAgICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV4dCA9IGN1cnJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIG91dE9mRE9NT3JkZXIgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0T2ZET01PcmRlciA9ICEhZmluZFByb3BzT3V0Lm91dE9mRE9NT3JkZXI7XG4gICAgICB9XG4gICAgICB1bmNvbnRyb2xsZWQgPSBmaW5kUHJvcHNPdXQudW5jb250cm9sbGVkO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudDogbmV4dCxcbiAgICAgIHVuY29udHJvbGxlZCxcbiAgICAgIG91dE9mRE9NT3JkZXJcbiAgICB9O1xuICB9XG4gIF9kaXNwYXRjaEV2ZW50KGlzQWN0aXZlLCBhbGxFbGVtZW50cykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICBsZXQgZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IGFsbEVsZW1lbnRzID8gdGhpcy5fYWN0aXZlRWxlbWVudHMubWFwKGUgPT4gZS5nZXQoKSkgOiBbZWxlbWVudF07XG4gICAgICBmb3IgKGNvbnN0IGVsIG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIGNvbnN0IGV2ZW50RGV0YWlsID0ge1xuICAgICAgICAgICAgaWQ6IHRoaXMudXNlcklkLFxuICAgICAgICAgICAgZWxlbWVudFxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBpc0FjdGl2ZSA/IG5ldyBNb2RhbGl6ZXJBY3RpdmVFdmVudChldmVudERldGFpbCkgOiBuZXcgTW9kYWxpemVySW5hY3RpdmVFdmVudChldmVudERldGFpbCk7XG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFByZXZlbnRlZDtcbiAgfVxuICBfcmVtb3ZlKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgX3NldEluZm9ybWF0aXZlU3R5bGUodGhpcy5fZWxlbWVudCwgdHJ1ZSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBNb2RhbGl6ZXJBUEkge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyLFxuICAvLyBAZGVwcmVjYXRlZCB1c2UgYWNjZXNzaWJsZUNoZWNrLlxuICBhbHdheXNBY2Nlc3NpYmxlU2VsZWN0b3IsIGFjY2Vzc2libGVDaGVjaykge1xuICAgIHRoaXMuX29uTW9kYWxpemVyRGlzcG9zZSA9IG1vZGFsaXplciA9PiB7XG4gICAgICBjb25zdCBpZCA9IG1vZGFsaXplci5pZDtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IG1vZGFsaXplci51c2VySWQ7XG4gICAgICBjb25zdCBwYXJ0ID0gdGhpcy5fcGFydHNbdXNlcklkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9tb2RhbGl6ZXJzW2lkXTtcbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIGRlbGV0ZSBwYXJ0W2lkXTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHBhcnQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wYXJ0c1t1c2VySWRdO1xuICAgICAgICAgIGNvbnN0IGFjdGl2YXRpb25IaXN0b3J5ID0gdGhpcy5fYWN0aXZhdGlvbkhpc3Rvcnk7XG4gICAgICAgICAgY29uc3QgY2xlYW5BY3RpdmF0aW9uSGlzdG9yeSA9IFtdO1xuICAgICAgICAgIGxldCBwcmV2SGlzdG9yeUl0ZW07XG4gICAgICAgICAgLy8gVGhlIGhpc3Rvcnkgb3JkZXIgaXMgZnJvbSBtb3N0IHJlY2VudCB0byBvbGRlc3QuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2YXRpb25IaXN0b3J5Lmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYWN0aXZhdGlvbiBoaXN0b3J5LCBtYWtpbmcgc3VyZSB0aGVyZSBhcmUgbm8gZHVwbGljYXRlc1xuICAgICAgICAgICAgLy8gZm9yIGNhc2VzIGxpa2UgW21vZGFsMiwgbW9kYWwxLCBtb2RhbDIsIG1vZGFsMV06IGp1c3QgcmVtb3ZpbmcgbW9kYWwyXG4gICAgICAgICAgICAvLyB3aWxsIHJlc3VsdCBpbiBbbW9kYWwxLCBtb2RhbDFdIGFuZCB3ZSB3YW50IGp1c3QgW21vZGFsMV0uIE90aGVyd2lzZSxcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgY2hhbmNlIGZvciB0aGlzIGFycmF5IHRvIGdyb3cgZm9yZXZlciBpbiBhIG5hcnJvdyBjYXNlIG9mXG4gICAgICAgICAgICAvLyBhIG1vZGFsaXplciB0aGF0IHN0YXlzIGluIERPTSBmb3JldmVyIGFuZCBpcyBiZWluZyBhY3RpdmF0ZWQvZGVhY3RpdmF0ZWRcbiAgICAgICAgICAgIC8vIHN3aXRjaGluZyBiZXR3ZWVuIG90aGVyIG1vZGFsaXplcnMgdGhhdCBjb21lIGFuZCBnby5cbiAgICAgICAgICAgIGNvbnN0IG1vZGFsaXplclVzZXJJZEZyb21IaXN0b3J5ID0gYWN0aXZhdGlvbkhpc3RvcnlbaV07XG4gICAgICAgICAgICBpZiAobW9kYWxpemVyVXNlcklkRnJvbUhpc3RvcnkgPT09IHVzZXJJZCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RhbGl6ZXJVc2VySWRGcm9tSGlzdG9yeSAhPT0gcHJldkhpc3RvcnlJdGVtKSB7XG4gICAgICAgICAgICAgIHByZXZIaXN0b3J5SXRlbSA9IG1vZGFsaXplclVzZXJJZEZyb21IaXN0b3J5O1xuICAgICAgICAgICAgICBpZiAobW9kYWxpemVyVXNlcklkRnJvbUhpc3RvcnkgfHwgY2xlYW5BY3RpdmF0aW9uSGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2xlYW5BY3RpdmF0aW9uSGlzdG9yeS51bnNoaWZ0KG1vZGFsaXplclVzZXJJZEZyb21IaXN0b3J5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9hY3RpdmF0aW9uSGlzdG9yeSA9IGNsZWFuQWN0aXZhdGlvbkhpc3Rvcnk7XG4gICAgICAgICAgaWYgKHRoaXMuYWN0aXZlSWQgPT09IHVzZXJJZCkge1xuICAgICAgICAgICAgY29uc3QgcHJldkFjdGl2ZUlkID0gY2xlYW5BY3RpdmF0aW9uSGlzdG9yeVswXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZBY3RpdmUgPSBwcmV2QWN0aXZlSWQgPyBPYmplY3QudmFsdWVzKHRoaXMuX3BhcnRzW3ByZXZBY3RpdmVJZF0pWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmUocHJldkFjdGl2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbktleURvd24gPSBldmVudCA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoZXZlbnQua2V5ICE9PSBLZXlzLkVzY2FwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0YWJzdGVyID0gdGhpcy5fdGFic3RlcjtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0YWJzdGVyLmZvY3VzZWRFbGVtZW50LmdldEZvY3VzZWRFbGVtZW50KCk7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBjdHggPSBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRhYnN0ZXIsIGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBtb2RhbGl6ZXIgPSBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgubW9kYWxpemVyO1xuICAgICAgICBpZiAoY3R4ICYmICFjdHguZ3JvdXBwZXIgJiYgKG1vZGFsaXplciA9PT0gbnVsbCB8fCBtb2RhbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vZGFsaXplci5pc0FjdGl2ZSgpKSAmJiAhY3R4Lmlnbm9yZUtleWRvd24oZXZlbnQpKSB7XG4gICAgICAgICAgY29uc3QgYWN0aXZlSWQgPSBtb2RhbGl6ZXIudXNlcklkO1xuICAgICAgICAgIGlmIChhY3RpdmVJZCkge1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHRoaXMuX3BhcnRzW2FjdGl2ZUlkXTtcbiAgICAgICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZvY3VzZWRTaW5jZSA9IE9iamVjdC5rZXlzKHBhcnQpLm1hcChpZCA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBwYXJ0W2lkXTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IG0uZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIGxldCBncm91cHBlcjtcbiAgICAgICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgIGdyb3VwcGVyID0gKF9hID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0YWJzdGVyLCBlbCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ncm91cHBlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG0gJiYgZWwgJiYgZ3JvdXBwZXIgPyB7XG4gICAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAgIGZvY3VzZWRTaW5jZTogbS5mb2N1c2VkKHRydWUpXG4gICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgIGZvY3VzZWRTaW5jZTogMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pLmZpbHRlcihmID0+IGYuZm9jdXNlZFNpbmNlID4gMCkuc29ydCgoYSwgYikgPT4gYS5mb2N1c2VkU2luY2UgPiBiLmZvY3VzZWRTaW5jZSA/IC0xIDogYS5mb2N1c2VkU2luY2UgPCBiLmZvY3VzZWRTaW5jZSA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgaWYgKGZvY3VzZWRTaW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBncm91cHBlckVsZW1lbnQgPSBmb2N1c2VkU2luY2VbMF0uZWw7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwcGVyRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgKF9hID0gdGFic3Rlci5ncm91cHBlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhbmRsZUtleVByZXNzKGdyb3VwcGVyRWxlbWVudCwgZXZlbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byB0aGUgZm9jdXMgc3RhdGUgYW5kIGhhbmRsZXMgbW9kYWxpemVyIHJlbGF0ZWQgZm9jdXMgZXZlbnRzXG4gICAgICogQHBhcmFtIGZvY3VzZWRFbGVtZW50IC0gRWxlbWVudCB0aGF0IGlzIGZvY3VzZWRcbiAgICAgKiBAcGFyYW0gZGV0YWlsIC0gQWRkaXRpb25hbCBkYXRhIGFib3V0IHRoZSBmb2N1cyBldmVudFxuICAgICAqL1xuICAgIHRoaXMuX29uRm9jdXMgPSAoZm9jdXNlZEVsZW1lbnQsIGRldGFpbCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdGFic3RlciA9IHRoaXMuX3RhYnN0ZXI7XG4gICAgICBjb25zdCBjdHggPSBmb2N1c2VkRWxlbWVudCAmJiBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRhYnN0ZXIsIGZvY3VzZWRFbGVtZW50KTtcbiAgICAgIC8vIE1vZGFsaXplciBiZWhhdmlvdXIgaXMgb3B0IGluLCBvbmx5IGFwcGx5IHRvIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIHRhYnN0ZXIgY29udGV4dFxuICAgICAgaWYgKCFjdHggfHwgIWZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF1Z21lbnRlZE1hcCA9IHRoaXMuX2F1Z01hcDtcbiAgICAgIGZvciAobGV0IGUgPSBmb2N1c2VkRWxlbWVudDsgZTsgZSA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGUpKSB7XG4gICAgICAgIC8vIElmIHRoZSBuZXdseSBmb2N1c2VkIGVsZW1lbnQgaXMgaW5zaWRlIHNvbWUgb2YgdGhlIGhpZGRlbiBjb250YWluZXJzLFxuICAgICAgICAvLyByZW1vdmUgYXJpYS1oaWRkZW4gZnJvbSB0aG9zZSBzeW5jaHJvbm91c2x5IGZvciB0aGUgc2NyZWVuIHJlYWRlcnNcbiAgICAgICAgLy8gdG8gYmUgYWJsZSB0byByZWFkIHRoZSBlbGVtZW50LiBUaGUgcmVzdCBvZiBhcmlhLWhpZGRlbnMsIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAgICAvLyBhY3luY2hyb25vdXNseSBmb3IgdGhlIHNha2Ugb2YgcGVyZm9ybWFuY2UuXG4gICAgICAgIGlmIChhdWdtZW50ZWRNYXAuaGFzKGUpKSB7XG4gICAgICAgICAgYXVnbWVudGVkTWFwLmRlbGV0ZShlKTtcbiAgICAgICAgICBhdWdtZW50QXR0cmlidXRlKHRhYnN0ZXIsIGUsIF9hcmlhSGlkZGVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IG1vZGFsaXplciA9IGN0eC5tb2RhbGl6ZXI7XG4gICAgICBjb25zdCB0YWJzdGVyT25Gb2N1c2VkRWxlbWVudCA9IGdldFRhYnN0ZXJPbkVsZW1lbnQodGFic3RlciwgZm9jdXNlZEVsZW1lbnQpO1xuICAgICAgY29uc3QgbW9kYWxpemVyT25Gb2N1c2VkRWxlbWVudCA9IHRhYnN0ZXJPbkZvY3VzZWRFbGVtZW50ID09PSBudWxsIHx8IHRhYnN0ZXJPbkZvY3VzZWRFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJzdGVyT25Gb2N1c2VkRWxlbWVudC5tb2RhbGl6ZXI7XG4gICAgICBpZiAobW9kYWxpemVyT25Gb2N1c2VkRWxlbWVudCkge1xuICAgICAgICBtb2RhbGl6ZXJPbkZvY3VzZWRFbGVtZW50LmZvY3VzZWQoKTtcbiAgICAgICAgaWYgKG1vZGFsaXplck9uRm9jdXNlZEVsZW1lbnQudXNlcklkID09PSB0aGlzLmFjdGl2ZUlkICYmIHRhYnN0ZXJPbkZvY3VzZWRFbGVtZW50Lmdyb3VwcGVyKSB7XG4gICAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudCA9IHRhYnN0ZXIuZ2V0UGFyZW50KGZvY3VzZWRFbGVtZW50KTtcbiAgICAgICAgICBjb25zdCBwYXJlbnRNb2RhbGl6ZXIgPSBwYXJlbnRFbGVtZW50ICYmICgoX2EgPSBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRhYnN0ZXIsIHBhcmVudEVsZW1lbnQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9kYWxpemVyKTtcbiAgICAgICAgICBpZiAocGFyZW50TW9kYWxpemVyKSB7XG4gICAgICAgICAgICBtb2RhbGl6ZXIgPSBwYXJlbnRNb2RhbGl6ZXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBbiBpbmFjdGl2ZSBncm91cHBlciB3aXRoIHRoZSBtb2RhbGl6ZXIgb24gdGhlIHNhbWUgbm9kZSB3aWxsIG5vdCBnaXZlIHRoZSBtb2RhbGl6ZXJcbiAgICAgIC8vIGluIHRoZSBjb250ZXh0LCB5ZXQgd2Ugc3RpbGwgd2FudCB0byB0cmFjayB0aGF0IHRoZSBtb2RhbGl6ZXIncyBjb250YWluZXIgd2FzIGZvY3VzZWQuXG4gICAgICBtb2RhbGl6ZXIgPT09IG51bGwgfHwgbW9kYWxpemVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2RhbGl6ZXIuZm9jdXNlZCgpO1xuICAgICAgaWYgKChtb2RhbGl6ZXIgPT09IG51bGwgfHwgbW9kYWxpemVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2RhbGl6ZXIudXNlcklkKSA9PT0gdGhpcy5hY3RpdmVJZCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRJc090aGVyc0FjY2Vzc2libGUgPSBtb2RhbGl6ZXIgPT09IG51bGwgfHwgbW9kYWxpemVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2RhbGl6ZXIuZ2V0UHJvcHMoKS5pc090aGVyc0FjY2Vzc2libGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIERldmVsb3BlcnMgY2FsbGluZyBgZWxlbWVudC5mb2N1cygpYCBzaG91bGQgY2hhbmdlL2RlYWN0aXZhdGUgYWN0aXZlIG1vZGFsaXplclxuICAgICAgaWYgKGRldGFpbC5pc0ZvY3VzZWRQcm9ncmFtbWF0aWNhbGx5IHx8IHRoaXMuY3VycmVudElzT3RoZXJzQWNjZXNzaWJsZSB8fCAobW9kYWxpemVyID09PSBudWxsIHx8IG1vZGFsaXplciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kYWxpemVyLmdldFByb3BzKCkuaXNBbHdheXNBY2Nlc3NpYmxlKSkge1xuICAgICAgICB0aGlzLnNldEFjdGl2ZShtb2RhbGl6ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9jdXNlZCBvdXRzaWRlIG9mIHRoZSBhY3RpdmUgbW9kYWxpemVyLCB0cnkgcHVsbCBmb2N1cyBiYWNrIHRvIGN1cnJlbnQgbW9kYWxpemVyXG4gICAgICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgICAgICB3aW4uY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc3RvcmVNb2RhbGl6ZXJGb2N1c1RpbWVyKTtcbiAgICAgICAgLy8gVE9ETyBzb21lIHJlbmRlcmluZyBmcmFtZXdvcmtzIChpLmUuIFJlYWN0KSBtaWdodCBhc3luYyByZXJlbmRlciB0aGUgRE9NIHNvIHdlIG5lZWQgdG8gd2FpdCBmb3IgYSBkdXJhdGlvblxuICAgICAgICAvLyBGaWd1cmUgb3V0IGEgYmV0dGVyIHdheSBvZiBkb2luZyB0aGlzIHJhdGhlciB0aGFuIGEgMTAwbXMgdGltZW91dFxuICAgICAgICB0aGlzLl9yZXN0b3JlTW9kYWxpemVyRm9jdXNUaW1lciA9IHdpbi5zZXRUaW1lb3V0KCgpID0+IHRoaXMuX3Jlc3RvcmVNb2RhbGl6ZXJGb2N1cyhmb2N1c2VkRWxlbWVudCksIDEwMCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl90YWJzdGVyID0gdGFic3RlcjtcbiAgICB0aGlzLl93aW4gPSB0YWJzdGVyLmdldFdpbmRvdztcbiAgICB0aGlzLl9tb2RhbGl6ZXJzID0ge307XG4gICAgdGhpcy5fcGFydHMgPSB7fTtcbiAgICB0aGlzLl9hdWdNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuX2F1ZyA9IFtdO1xuICAgIHRoaXMuX2Fsd2F5c0FjY2Vzc2libGVTZWxlY3RvciA9IGFsd2F5c0FjY2Vzc2libGVTZWxlY3RvcjtcbiAgICB0aGlzLl9hY2Nlc3NpYmxlQ2hlY2sgPSBhY2Nlc3NpYmxlQ2hlY2s7XG4gICAgdGhpcy5fYWN0aXZhdGlvbkhpc3RvcnkgPSBbXTtcbiAgICB0aGlzLmFjdGl2ZUVsZW1lbnRzID0gW107XG4gICAgaWYgKCF0YWJzdGVyLmNvbnRyb2xUYWIpIHtcbiAgICAgIHRhYnN0ZXIucm9vdC5hZGREdW1teUlucHV0cygpO1xuICAgIH1cbiAgICBjb25zdCB3aW4gPSB0aGlzLl93aW4oKTtcbiAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fb25LZXlEb3duLCB0cnVlKTtcbiAgICB0YWJzdGVyLnF1ZXVlSW5pdCgoKSA9PiB7XG4gICAgICB0aGlzLl90YWJzdGVyLmZvY3VzZWRFbGVtZW50LnN1YnNjcmliZSh0aGlzLl9vbkZvY3VzKTtcbiAgICB9KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9vbktleURvd24sIHRydWUpO1xuICAgIC8vIERpc3Bvc2UgYWxsIG1vZGFsaXplcnMgbWFuYWdlZCBieSB0aGUgQVBJXG4gICAgT2JqZWN0LmtleXModGhpcy5fbW9kYWxpemVycykuZm9yRWFjaChtb2RhbGl6ZXJJZCA9PiB7XG4gICAgICBpZiAodGhpcy5fbW9kYWxpemVyc1ttb2RhbGl6ZXJJZF0pIHtcbiAgICAgICAgdGhpcy5fbW9kYWxpemVyc1ttb2RhbGl6ZXJJZF0uZGlzcG9zZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5fbW9kYWxpemVyc1ttb2RhbGl6ZXJJZF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgd2luLmNsZWFyVGltZW91dCh0aGlzLl9yZXN0b3JlTW9kYWxpemVyRm9jdXNUaW1lcik7XG4gICAgd2luLmNsZWFyVGltZW91dCh0aGlzLl9oaWRkZW5VcGRhdGVUaW1lcik7XG4gICAgdGhpcy5fcGFydHMgPSB7fTtcbiAgICBkZWxldGUgdGhpcy5hY3RpdmVJZDtcbiAgICB0aGlzLmFjdGl2ZUVsZW1lbnRzID0gW107XG4gICAgdGhpcy5fYXVnTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICB0aGlzLl9hdWcgPSBbXTtcbiAgICB0aGlzLl90YWJzdGVyLmZvY3VzZWRFbGVtZW50LnVuc3Vic2NyaWJlKHRoaXMuX29uRm9jdXMpO1xuICB9XG4gIGNyZWF0ZU1vZGFsaXplcihlbGVtZW50LCBwcm9wcywgc3lzKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JykgO1xuICAgIGNvbnN0IG1vZGFsaXplciA9IG5ldyBNb2RhbGl6ZXIodGhpcy5fdGFic3RlciwgZWxlbWVudCwgdGhpcy5fb25Nb2RhbGl6ZXJEaXNwb3NlLCBwcm9wcywgc3lzLCB0aGlzLmFjdGl2ZUVsZW1lbnRzKTtcbiAgICBjb25zdCBpZCA9IG1vZGFsaXplci5pZDtcbiAgICBjb25zdCB1c2VySWQgPSBwcm9wcy5pZDtcbiAgICB0aGlzLl9tb2RhbGl6ZXJzW2lkXSA9IG1vZGFsaXplcjtcbiAgICBsZXQgcGFydCA9IHRoaXMuX3BhcnRzW3VzZXJJZF07XG4gICAgaWYgKCFwYXJ0KSB7XG4gICAgICBwYXJ0ID0gdGhpcy5fcGFydHNbdXNlcklkXSA9IHt9O1xuICAgIH1cbiAgICBwYXJ0W2lkXSA9IG1vZGFsaXplcjtcbiAgICBjb25zdCBmb2N1c2VkRWxlbWVudCA9IChfYSA9IHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZ2V0Rm9jdXNlZEVsZW1lbnQoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAvLyBBZGRpbmcgYSBtb2RhbGl6ZXIgd2hpY2ggaXMgYWxyZWFkeSBmb2N1c2VkLCBhY3RpdmF0ZSBpdFxuICAgIGlmIChlbGVtZW50ICE9PSBmb2N1c2VkRWxlbWVudCAmJiBkb20ubm9kZUNvbnRhaW5zKGVsZW1lbnQsIGZvY3VzZWRFbGVtZW50KSkge1xuICAgICAgaWYgKHVzZXJJZCAhPT0gdGhpcy5hY3RpdmVJZCkge1xuICAgICAgICB0aGlzLnNldEFjdGl2ZShtb2RhbGl6ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kYWxpemVyLm1ha2VBY3RpdmUodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb2RhbGl6ZXI7XG4gIH1cbiAgaXNBdWdtZW50ZWQoZWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLl9hdWdNYXAuaGFzKGVsZW1lbnQpO1xuICB9XG4gIGhpZGRlblVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5faGlkZGVuVXBkYXRlVGltZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faGlkZGVuVXBkYXRlVGltZXIgPSB0aGlzLl93aW4oKS5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9oaWRkZW5VcGRhdGVUaW1lcjtcbiAgICAgIHRoaXMuX2hpZGRlblVwZGF0ZSgpO1xuICAgIH0sIDI1MCk7XG4gIH1cbiAgc2V0QWN0aXZlKG1vZGFsaXplcikge1xuICAgIGNvbnN0IHVzZXJJZCA9IG1vZGFsaXplciA9PT0gbnVsbCB8fCBtb2RhbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vZGFsaXplci51c2VySWQ7XG4gICAgY29uc3QgYWN0aXZlSWQgPSB0aGlzLmFjdGl2ZUlkO1xuICAgIGlmIChhY3RpdmVJZCA9PT0gdXNlcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlSWQgPSB1c2VySWQ7XG4gICAgaWYgKGFjdGl2ZUlkKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gdGhpcy5fcGFydHNbYWN0aXZlSWRdO1xuICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBPYmplY3Qua2V5cyhwYXJ0KSkge1xuICAgICAgICAgIHBhcnRbaWRdLm1ha2VBY3RpdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1c2VySWQpIHtcbiAgICAgIGNvbnN0IHBhcnQgPSB0aGlzLl9wYXJ0c1t1c2VySWRdO1xuICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBPYmplY3Qua2V5cyhwYXJ0KSkge1xuICAgICAgICAgIHBhcnRbaWRdLm1ha2VBY3RpdmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50SXNPdGhlcnNBY2Nlc3NpYmxlID0gbW9kYWxpemVyID09PSBudWxsIHx8IG1vZGFsaXplciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9kYWxpemVyLmdldFByb3BzKCkuaXNPdGhlcnNBY2Nlc3NpYmxlO1xuICAgIHRoaXMuaGlkZGVuVXBkYXRlKCk7XG4gICAgY29uc3QgYWN0aXZhdGlvbkhpc3RvcnkgPSB0aGlzLl9hY3RpdmF0aW9uSGlzdG9yeTtcbiAgICBpZiAoYWN0aXZhdGlvbkhpc3RvcnlbMF0gIT09IHVzZXJJZCAmJiAodXNlcklkICE9PSB1bmRlZmluZWQgfHwgYWN0aXZhdGlvbkhpc3RvcnkubGVuZ3RoID4gMCkpIHtcbiAgICAgIGFjdGl2YXRpb25IaXN0b3J5LnVuc2hpZnQodXNlcklkKTtcbiAgICB9XG4gIH1cbiAgZm9jdXMoZWxlbWVudEZyb21Nb2RhbGl6ZXIsIG5vRm9jdXNGaXJzdCwgbm9Gb2N1c0RlZmF1bHQpIHtcbiAgICBjb25zdCB0YWJzdGVyID0gdGhpcy5fdGFic3RlcjtcbiAgICBjb25zdCBjdHggPSBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRhYnN0ZXIsIGVsZW1lbnRGcm9tTW9kYWxpemVyKTtcbiAgICBjb25zdCBtb2RhbGl6ZXIgPSBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgubW9kYWxpemVyO1xuICAgIGlmIChtb2RhbGl6ZXIpIHtcbiAgICAgIHRoaXMuc2V0QWN0aXZlKG1vZGFsaXplcik7XG4gICAgICBjb25zdCBwcm9wcyA9IG1vZGFsaXplci5nZXRQcm9wcygpO1xuICAgICAgY29uc3QgbW9kYWxpemVyUm9vdCA9IG1vZGFsaXplci5nZXRFbGVtZW50KCk7XG4gICAgICBpZiAobW9kYWxpemVyUm9vdCkge1xuICAgICAgICBpZiAobm9Gb2N1c0ZpcnN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub0ZvY3VzRmlyc3QgPSBwcm9wcy5pc05vRm9jdXNGaXJzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vRm9jdXNGaXJzdCAmJiB0YWJzdGVyLmtleWJvYXJkTmF2aWdhdGlvbi5pc05hdmlnYXRpbmdXaXRoS2V5Ym9hcmQoKSAmJiB0YWJzdGVyLmZvY3VzZWRFbGVtZW50LmZvY3VzRmlyc3Qoe1xuICAgICAgICAgIGNvbnRhaW5lcjogbW9kYWxpemVyUm9vdFxuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub0ZvY3VzRGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9Gb2N1c0RlZmF1bHQgPSBwcm9wcy5pc05vRm9jdXNEZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9Gb2N1c0RlZmF1bHQgJiYgdGFic3Rlci5mb2N1c2VkRWxlbWVudC5mb2N1c0RlZmF1bHQobW9kYWxpemVyUm9vdCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0YWJzdGVyLmZvY3VzZWRFbGVtZW50LnJlc2V0Rm9jdXMobW9kYWxpemVyUm9vdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVsZW1lbnQgaXMgbm90IGluIE1vZGFsaXplci5cIiwgZWxlbWVudEZyb21Nb2RhbGl6ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWN0aXZhdGUobW9kYWxpemVyRWxlbWVudE9yQ29udGFpbmVyKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG1vZGFsaXplclRvQWN0aXZhdGUgPSBtb2RhbGl6ZXJFbGVtZW50T3JDb250YWluZXIgPyAoX2EgPSBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRoaXMuX3RhYnN0ZXIsIG1vZGFsaXplckVsZW1lbnRPckNvbnRhaW5lcikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2RhbGl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFtb2RhbGl6ZXJFbGVtZW50T3JDb250YWluZXIgfHwgbW9kYWxpemVyVG9BY3RpdmF0ZSkge1xuICAgICAgdGhpcy5zZXRBY3RpdmUobW9kYWxpemVyVG9BY3RpdmF0ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFjY2VwdEVsZW1lbnQoZWxlbWVudCwgc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbW9kYWxpemVyVXNlcklkID0gc3RhdGUubW9kYWxpemVyVXNlcklkO1xuICAgIGNvbnN0IGN1cnJlbnRNb2RhbGl6ZXIgPSAoX2EgPSBzdGF0ZS5jdXJyZW50Q3R4KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9kYWxpemVyO1xuICAgIGlmIChtb2RhbGl6ZXJVc2VySWQpIHtcbiAgICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLmFjdGl2ZUVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZS5nZXQoKTtcbiAgICAgICAgaWYgKGVsICYmIChkb20ubm9kZUNvbnRhaW5zKGVsZW1lbnQsIGVsKSB8fCBlbCA9PT0gZWxlbWVudCkpIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIGEgcGFydCBvZiBjdXJyZW50bHkgYWN0aXZlIG1vZGFsaXplciBzb21ld2hlcmUgZGVlcGVyIGluIHRoZSBET00sXG4gICAgICAgICAgLy8gc2tpcHBpbmcgYWxsIG90aGVyIGNoZWNrcy5cbiAgICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXQgPSBtb2RhbGl6ZXJVc2VySWQgPT09IChjdXJyZW50TW9kYWxpemVyID09PSBudWxsIHx8IGN1cnJlbnRNb2RhbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRNb2RhbGl6ZXIudXNlcklkKSB8fCAhbW9kYWxpemVyVXNlcklkICYmIChjdXJyZW50TW9kYWxpemVyID09PSBudWxsIHx8IGN1cnJlbnRNb2RhbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRNb2RhbGl6ZXIuZ2V0UHJvcHMoKS5pc0Fsd2F5c0FjY2Vzc2libGUpID8gdW5kZWZpbmVkIDogTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXRlLnNraXBwZWRGb2N1c2FibGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIF9oaWRkZW5VcGRhdGUoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHRhYnN0ZXIgPSB0aGlzLl90YWJzdGVyO1xuICAgIGNvbnN0IGJvZHkgPSB0YWJzdGVyLmdldFdpbmRvdygpLmRvY3VtZW50LmJvZHk7XG4gICAgY29uc3QgYWN0aXZlSWQgPSB0aGlzLmFjdGl2ZUlkO1xuICAgIGNvbnN0IHBhcnRzID0gdGhpcy5fcGFydHM7XG4gICAgY29uc3QgdmlzaWJsZUVsZW1lbnRzID0gW107XG4gICAgY29uc3QgaGlkZGVuRWxlbWVudHMgPSBbXTtcbiAgICBjb25zdCBhbHdheXNBY2Nlc3NpYmxlU2VsZWN0b3IgPSB0aGlzLl9hbHdheXNBY2Nlc3NpYmxlU2VsZWN0b3I7XG4gICAgY29uc3QgYWx3YXlzQWNjZXNzaWJsZUVsZW1lbnRzID0gYWx3YXlzQWNjZXNzaWJsZVNlbGVjdG9yID8gQXJyYXkuZnJvbShkb20ucXVlcnlTZWxlY3RvckFsbChib2R5LCBhbHdheXNBY2Nlc3NpYmxlU2VsZWN0b3IpKSA6IFtdO1xuICAgIGNvbnN0IGFjdGl2ZU1vZGFsaXplckVsZW1lbnRzID0gW107XG4gICAgZm9yIChjb25zdCB1c2VySWQgb2YgT2JqZWN0LmtleXMocGFydHMpKSB7XG4gICAgICBjb25zdCBtb2RhbGl6ZXJQYXJ0cyA9IHBhcnRzW3VzZXJJZF07XG4gICAgICBmb3IgKGNvbnN0IGlkIG9mIE9iamVjdC5rZXlzKG1vZGFsaXplclBhcnRzKSkge1xuICAgICAgICBjb25zdCBtb2RhbGl6ZXIgPSBtb2RhbGl6ZXJQYXJ0c1tpZF07XG4gICAgICAgIGNvbnN0IGVsID0gbW9kYWxpemVyLmdldEVsZW1lbnQoKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBtb2RhbGl6ZXIuZ2V0UHJvcHMoKTtcbiAgICAgICAgY29uc3QgaXNBbHdheXNBY2Nlc3NpYmxlID0gcHJvcHMuaXNBbHdheXNBY2Nlc3NpYmxlO1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBpZiAodXNlcklkID09PSBhY3RpdmVJZCkge1xuICAgICAgICAgICAgYWN0aXZlTW9kYWxpemVyRWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3VycmVudElzT3RoZXJzQWNjZXNzaWJsZSkge1xuICAgICAgICAgICAgICB2aXNpYmxlRWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0Fsd2F5c0FjY2Vzc2libGUpIHtcbiAgICAgICAgICAgIGFsd2F5c0FjY2Vzc2libGVFbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlkZGVuRWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGF1Z21lbnRlZE1hcCA9IHRoaXMuX2F1Z01hcDtcbiAgICBjb25zdCBhbGxWaXNpYmxlRWxlbWVudHMgPSB2aXNpYmxlRWxlbWVudHMubGVuZ3RoID4gMCA/IFsuLi52aXNpYmxlRWxlbWVudHMsIC4uLmFsd2F5c0FjY2Vzc2libGVFbGVtZW50c10gOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbmV3QXVnbWVudGVkID0gW107XG4gICAgY29uc3QgbmV3QXVnbWVudGVkTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCB0b2dnbGUgPSAoZWxlbWVudCwgaGlkZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZTtcbiAgICAgIGlmICh0YWdOYW1lID09PSBcIlNDUklQVFwiIHx8IHRhZ05hbWUgPT09IFwiU1RZTEVcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgaXNBdWdtZW50ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChhdWdtZW50ZWRNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgaXNBdWdtZW50ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF1Z21lbnRlZE1hcC5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgYXVnbWVudEF0dHJpYnV0ZSh0YWJzdGVyLCBlbGVtZW50LCBfYXJpYUhpZGRlbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGlkZSAmJiAhKChfYSA9IHRoaXMuX2FjY2Vzc2libGVDaGVjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZWxlbWVudCwgYWN0aXZlTW9kYWxpemVyRWxlbWVudHMpKSAmJiBhdWdtZW50QXR0cmlidXRlKHRhYnN0ZXIsIGVsZW1lbnQsIF9hcmlhSGlkZGVuLCBcInRydWVcIikpIHtcbiAgICAgICAgYXVnbWVudGVkTWFwLnNldChlbGVtZW50LCB0cnVlKTtcbiAgICAgICAgaXNBdWdtZW50ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXVnbWVudGVkKSB7XG4gICAgICAgIG5ld0F1Z21lbnRlZC5wdXNoKG5ldyBXZWFrSFRNTEVsZW1lbnQodGFic3Rlci5nZXRXaW5kb3csIGVsZW1lbnQpKTtcbiAgICAgICAgbmV3QXVnbWVudGVkTWFwLnNldChlbGVtZW50LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHdhbGsgPSBlbGVtZW50ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGZvciAobGV0IGVsID0gZG9tLmdldEZpcnN0RWxlbWVudENoaWxkKGVsZW1lbnQpOyBlbDsgZWwgPSBkb20uZ2V0TmV4dEVsZW1lbnRTaWJsaW5nKGVsKSkge1xuICAgICAgICBsZXQgc2tpcCA9IGZhbHNlO1xuICAgICAgICBsZXQgY29udGFpbnNNb2RhbGl6ZXIgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvbnRhaW5lZEJ5TW9kYWxpemVyID0gZmFsc2U7XG4gICAgICAgIGlmIChhbGxWaXNpYmxlRWxlbWVudHMpIHtcbiAgICAgICAgICBjb25zdCBlbFBhcmVudCA9IHRhYnN0ZXIuZ2V0UGFyZW50KGVsKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgYWxsVmlzaWJsZUVsZW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoZWwgPT09IGMpIHtcbiAgICAgICAgICAgICAgc2tpcCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRvbS5ub2RlQ29udGFpbnMoZWwsIGMpKSB7XG4gICAgICAgICAgICAgIGNvbnRhaW5zTW9kYWxpemVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRvbS5ub2RlQ29udGFpbnMoYywgZWxQYXJlbnQpKSB7XG4gICAgICAgICAgICAgIC8vIHRhYnN0ZXIuZ2V0UGFyZW50KCkgY291bGQgYmUgcHJvdmlkZWQgYnkgdGhlIGFwcGxpY2F0aW9uIHRvXG4gICAgICAgICAgICAgIC8vIGhhbmRsZSwgZm9yIGV4YW1wbGUsIHZpcnR1YWwgcGFyZW50cy4gTWFraW5nIHN1cmUsIHdlIGFyZVxuICAgICAgICAgICAgICAvLyBub3Qgc2V0dGluZyBhcmlhLWhpZGRlbiBvbiBlbGVtZW50cyB3aGljaCBhcmUgdmlydHVhbGx5XG4gICAgICAgICAgICAgIC8vIGluc2lkZSBtb2RhbGl6ZXIuXG4gICAgICAgICAgICAgIGNvbnRhaW5lZEJ5TW9kYWxpemVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRhaW5zTW9kYWxpemVyIHx8ICgoX2EgPSBlbC5fX3RhYnN0ZXJFbGVtZW50RmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub0RpcmVjdEFyaWFIaWRkZW4pKSB7XG4gICAgICAgICAgICB3YWxrKGVsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFza2lwICYmICFjb250YWluZWRCeU1vZGFsaXplcikge1xuICAgICAgICAgICAgdG9nZ2xlKGVsLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9nZ2xlKGVsLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghYWxsVmlzaWJsZUVsZW1lbnRzKSB7XG4gICAgICBhbHdheXNBY2Nlc3NpYmxlRWxlbWVudHMuZm9yRWFjaChlID0+IHRvZ2dsZShlLCBmYWxzZSkpO1xuICAgIH1cbiAgICBoaWRkZW5FbGVtZW50cy5mb3JFYWNoKGUgPT4gdG9nZ2xlKGUsIHRydWUpKTtcbiAgICBpZiAoYm9keSkge1xuICAgICAgd2Fsayhib2R5KTtcbiAgICB9XG4gICAgKF9hID0gdGhpcy5fYXVnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKGUgPT4gZS5nZXQoKSkuZm9yRWFjaChlID0+IHtcbiAgICAgIGlmIChlICYmICFuZXdBdWdtZW50ZWRNYXAuZ2V0KGUpKSB7XG4gICAgICAgIHRvZ2dsZShlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fYXVnID0gbmV3QXVnbWVudGVkO1xuICAgIHRoaXMuX2F1Z01hcCA9IG5ld0F1Z21lbnRlZE1hcDtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYW4gZWxlbWVudCBpcyBmb2N1c2VkIG91dHNpZGUgb2YgYW4gYWN0aXZlIG1vZGFsaXplci5cbiAgICogQXR0ZW1wdHMgdG8gcHVsbCBmb2N1cyBiYWNrIGludG8gdGhlIGFjdGl2ZSBtb2RhbGl6ZXJcbiAgICogQHBhcmFtIG91dHNpZGVFbGVtZW50IC0gQW4gZWxlbWVudCBiZWluZyBmb2N1c2VkIG91dHNpZGUgb2YgdGhlIG1vZGFsaXplclxuICAgKi9cbiAgX3Jlc3RvcmVNb2RhbGl6ZXJGb2N1cyhvdXRzaWRlRWxlbWVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBvd25lckRvY3VtZW50ID0gb3V0c2lkZUVsZW1lbnQgPT09IG51bGwgfHwgb3V0c2lkZUVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG91dHNpZGVFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgaWYgKCFvdXRzaWRlRWxlbWVudCB8fCAhb3duZXJEb2N1bWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmb2N1c2VkRWxlbWVudCA9IHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZ2V0Rm9jdXNlZEVsZW1lbnQoKTtcbiAgICBjb25zdCBmb2N1c2VkRWxlbWVudE1vZGFsaXplciA9IGZvY3VzZWRFbGVtZW50ICYmICgoX2EgPSBSb290QVBJLmdldFRhYnN0ZXJDb250ZXh0KHRoaXMuX3RhYnN0ZXIsIGZvY3VzZWRFbGVtZW50KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vZGFsaXplcik7XG4gICAgaWYgKCFmb2N1c2VkRWxlbWVudCB8fCBmb2N1c2VkRWxlbWVudCAmJiAoZm9jdXNlZEVsZW1lbnRNb2RhbGl6ZXIgPT09IG51bGwgfHwgZm9jdXNlZEVsZW1lbnRNb2RhbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvY3VzZWRFbGVtZW50TW9kYWxpemVyLnVzZXJJZCkgPT09IHRoaXMuYWN0aXZlSWQpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnQsIG9yIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50XG4gICAgICAvLyBpcyBpbiB0aGUgYWN0aXZlIG1vZGFsaXplciwgd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFic3RlciA9IHRoaXMuX3RhYnN0ZXI7XG4gICAgY29uc3QgY3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0YWJzdGVyLCBvdXRzaWRlRWxlbWVudCk7XG4gICAgY29uc3QgbW9kYWxpemVyID0gY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4Lm1vZGFsaXplcjtcbiAgICBjb25zdCBhY3RpdmVJZCA9IHRoaXMuYWN0aXZlSWQ7XG4gICAgaWYgKCFtb2RhbGl6ZXIgJiYgIWFjdGl2ZUlkIHx8IG1vZGFsaXplciAmJiBhY3RpdmVJZCA9PT0gbW9kYWxpemVyLnVzZXJJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb250YWluZXIgPSBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgucm9vdC5nZXRFbGVtZW50KCk7XG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgbGV0IHRvRm9jdXMgPSB0YWJzdGVyLmZvY3VzYWJsZS5maW5kRmlyc3Qoe1xuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHVzZUFjdGl2ZU1vZGFsaXplcjogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAodG9Gb2N1cykge1xuICAgICAgICBpZiAob3V0c2lkZUVsZW1lbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odG9Gb2N1cykgJiBkb2N1bWVudC5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcpIHtcbiAgICAgICAgICB0b0ZvY3VzID0gdGFic3Rlci5mb2N1c2FibGUuZmluZExhc3Qoe1xuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCF0b0ZvY3VzKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG9ubHkgbWlnaHQgbWVhbiB0aGF0IGZpbmRGaXJzdC9maW5kTGFzdCBhcmUgYnVnZ3kgYW5kIGluY29uc2lzdGVudC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNvbWV0aGluZyB3ZW50IHdyb25nLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGFic3Rlci5mb2N1c2VkRWxlbWVudC5mb2N1cyh0b0ZvY3VzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBDdXJyZW50IE1vZGFsaXplciBkb2Vzbid0IHNlZW0gdG8gaGF2ZSBmb2N1c2FibGUgZWxlbWVudHMuXG4gICAgLy8gQmx1cnJpbmcgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnQgd2hpY2ggaXMgb3V0c2lkZSBvZiB0aGUgY3VycmVudCBNb2RhbGl6ZXIuXG4gICAgb3V0c2lkZUVsZW1lbnQuYmx1cigpO1xuICB9XG59XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmNvbnN0IF9pbnB1dFNlbGVjdG9yID0gLyojX19QVVJFX18qL1tcImlucHV0XCIsIFwidGV4dGFyZWFcIiwgXCIqW2NvbnRlbnRlZGl0YWJsZV1cIl0uam9pbihcIiwgXCIpO1xuY2xhc3MgTW92ZXJEdW1teU1hbmFnZXIgZXh0ZW5kcyBEdW1teUlucHV0TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHRhYnN0ZXIsIGdldE1lbW9yaXplZCwgc3lzKSB7XG4gICAgc3VwZXIodGFic3RlciwgZWxlbWVudCwgRHVtbXlJbnB1dE1hbmFnZXJQcmlvcml0aWVzLk1vdmVyLCBzeXMpO1xuICAgIHRoaXMuX29uRm9jdXNEdW1teUlucHV0ID0gZHVtbXlJbnB1dCA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fZWxlbWVudC5nZXQoKTtcbiAgICAgIGNvbnN0IGlucHV0ID0gZHVtbXlJbnB1dC5pbnB1dDtcbiAgICAgIGlmIChjb250YWluZXIgJiYgaW5wdXQpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0aGlzLl90YWJzdGVyLCBjb250YWluZXIpO1xuICAgICAgICBsZXQgdG9Gb2N1cztcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgIHRvRm9jdXMgPSAoX2EgPSBGb2N1c2VkRWxlbWVudFN0YXRlLmZpbmROZXh0VGFiYmFibGUodGhpcy5fdGFic3RlciwgY3R4LCB1bmRlZmluZWQsIGlucHV0LCB1bmRlZmluZWQsICFkdW1teUlucHV0LmlzRmlyc3QsIHRydWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZW1vcml6ZWQgPSAoX2IgPSB0aGlzLl9nZXRNZW1vcml6ZWQoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldCgpO1xuICAgICAgICBpZiAobWVtb3JpemVkICYmIHRoaXMuX3RhYnN0ZXIuZm9jdXNhYmxlLmlzRm9jdXNhYmxlKG1lbW9yaXplZCkpIHtcbiAgICAgICAgICB0b0ZvY3VzID0gbWVtb3JpemVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b0ZvY3VzKSB7XG4gICAgICAgICAgbmF0aXZlRm9jdXModG9Gb2N1cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX3RhYnN0ZXIgPSB0YWJzdGVyO1xuICAgIHRoaXMuX2dldE1lbW9yaXplZCA9IGdldE1lbW9yaXplZDtcbiAgICB0aGlzLl9zZXRIYW5kbGVycyh0aGlzLl9vbkZvY3VzRHVtbXlJbnB1dCk7XG4gIH1cbn1cbi8vIFR5cGVTY3JpcHQgZW51bXMgcHJvZHVjZSBkZXByZXNzaW5nIEphdmFTY3JpcHQgY29kZSwgc28sIHdlJ3JlIGp1c3QgdXNpbmdcbi8vIGEgZmV3IG9sZCBzdHlsZSBjb25zdGFudHMgaGVyZS5cbmNvbnN0IF9tb3ZlclVwZGF0ZUFkZCA9IDE7XG5jb25zdCBfbW92ZXJVcGRhdGVBdHRyID0gMjtcbmNvbnN0IF9tb3ZlclVwZGF0ZVJlbW92ZSA9IDM7XG5jbGFzcyBNb3ZlciBleHRlbmRzIFRhYnN0ZXJQYXJ0IHtcbiAgY29uc3RydWN0b3IodGFic3RlciwgZWxlbWVudCwgb25EaXNwb3NlLCBwcm9wcywgc3lzKSB7XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKHRhYnN0ZXIsIGVsZW1lbnQsIHByb3BzKTtcbiAgICB0aGlzLl92aXNpYmxlID0ge307XG4gICAgdGhpcy5fb25JbnRlcnNlY3Rpb24gPSBlbnRyaWVzID0+IHtcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBjb25zdCBlbCA9IGVudHJ5LnRhcmdldDtcbiAgICAgICAgY29uc3QgaWQgPSBnZXRFbGVtZW50VUlkKHRoaXMuX3dpbiwgZWwpO1xuICAgICAgICBsZXQgbmV3VmlzaWJpbGl0eTtcbiAgICAgICAgbGV0IGZ1bGx5VmlzaWJsZSA9IHRoaXMuX2Z1bGx5VmlzaWJsZTtcbiAgICAgICAgaWYgKGVudHJ5LmludGVyc2VjdGlvblJhdGlvID49IDAuMjUpIHtcbiAgICAgICAgICBuZXdWaXNpYmlsaXR5ID0gZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPj0gMC43NSA/IFZpc2liaWxpdGllcy5WaXNpYmxlIDogVmlzaWJpbGl0aWVzLlBhcnRpYWxseVZpc2libGU7XG4gICAgICAgICAgaWYgKG5ld1Zpc2liaWxpdHkgPT09IFZpc2liaWxpdGllcy5WaXNpYmxlKSB7XG4gICAgICAgICAgICBmdWxseVZpc2libGUgPSBpZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3VmlzaWJpbGl0eSA9IFZpc2liaWxpdGllcy5JbnZpc2libGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Zpc2libGVbaWRdICE9PSBuZXdWaXNpYmlsaXR5KSB7XG4gICAgICAgICAgaWYgKG5ld1Zpc2liaWxpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Zpc2libGVbaWRdO1xuICAgICAgICAgICAgaWYgKGZ1bGx5VmlzaWJsZSA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2Z1bGx5VmlzaWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdmlzaWJsZVtpZF0gPSBuZXdWaXNpYmlsaXR5O1xuICAgICAgICAgICAgdGhpcy5fZnVsbHlWaXNpYmxlID0gZnVsbHlWaXNpYmxlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoZWwpO1xuICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgTW92ZXJTdGF0ZUV2ZW50KHN0YXRlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl93aW4gPSB0YWJzdGVyLmdldFdpbmRvdztcbiAgICB0aGlzLnZpc2liaWxpdHlUb2xlcmFuY2UgPSAoX2EgPSBwcm9wcy52aXNpYmlsaXR5VG9sZXJhbmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLjg7XG4gICAgaWYgKHRoaXMuX3Byb3BzLnRyYWNrU3RhdGUgfHwgdGhpcy5fcHJvcHMudmlzaWJpbGl0eUF3YXJlKSB7XG4gICAgICB0aGlzLl9pbnRlcnNlY3Rpb25PYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcih0aGlzLl9vbkludGVyc2VjdGlvbiwge1xuICAgICAgICB0aHJlc2hvbGQ6IFswLCAwLjI1LCAwLjUsIDAuNzUsIDFdXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX29ic2VydmVTdGF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLl9vbkRpc3Bvc2UgPSBvbkRpc3Bvc2U7XG4gICAgY29uc3QgZ2V0TWVtb3JpemVkID0gKCkgPT4gcHJvcHMubWVtb3JpemVDdXJyZW50ID8gdGhpcy5fY3VycmVudCA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIXRhYnN0ZXIuY29udHJvbFRhYikge1xuICAgICAgdGhpcy5kdW1teU1hbmFnZXIgPSBuZXcgTW92ZXJEdW1teU1hbmFnZXIodGhpcy5fZWxlbWVudCwgdGFic3RlciwgZ2V0TWVtb3JpemVkLCBzeXMpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLl9vbkRpc3Bvc2UodGhpcyk7XG4gICAgaWYgKHRoaXMuX2ludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICB0aGlzLl9pbnRlcnNlY3Rpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICBkZWxldGUgdGhpcy5faW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLl9jdXJyZW50O1xuICAgIGRlbGV0ZSB0aGlzLl9mdWxseVZpc2libGU7XG4gICAgZGVsZXRlIHRoaXMuX2FsbEVsZW1lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVRdWV1ZTtcbiAgICBpZiAodGhpcy5fdW5vYnNlcnZlKSB7XG4gICAgICB0aGlzLl91bm9ic2VydmUoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl91bm9ic2VydmU7XG4gICAgfVxuICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgIGlmICh0aGlzLl9zZXRDdXJyZW50VGltZXIpIHtcbiAgICAgIHdpbi5jbGVhclRpbWVvdXQodGhpcy5fc2V0Q3VycmVudFRpbWVyKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zZXRDdXJyZW50VGltZXI7XG4gICAgfVxuICAgIGlmICh0aGlzLl91cGRhdGVUaW1lcikge1xuICAgICAgd2luLmNsZWFyVGltZW91dCh0aGlzLl91cGRhdGVUaW1lcik7XG4gICAgICBkZWxldGUgdGhpcy5fdXBkYXRlVGltZXI7XG4gICAgfVxuICAgIChfYSA9IHRoaXMuZHVtbXlNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xuICAgIGRlbGV0ZSB0aGlzLmR1bW15TWFuYWdlcjtcbiAgfVxuICBzZXRDdXJyZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fY3VycmVudCA9IG5ldyBXZWFrSFRNTEVsZW1lbnQodGhpcy5fd2luLCBlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCh0aGlzLl9wcm9wcy50cmFja1N0YXRlIHx8IHRoaXMuX3Byb3BzLnZpc2liaWxpdHlBd2FyZSkgJiYgIXRoaXMuX3NldEN1cnJlbnRUaW1lcikge1xuICAgICAgdGhpcy5fc2V0Q3VycmVudFRpbWVyID0gdGhpcy5fd2luKCkuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3NldEN1cnJlbnRUaW1lcjtcbiAgICAgICAgY29uc3QgY2hhbmdlZCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudCAhPT0gdGhpcy5fcHJldkN1cnJlbnQpIHtcbiAgICAgICAgICBjaGFuZ2VkLnB1c2godGhpcy5fY3VycmVudCk7XG4gICAgICAgICAgY2hhbmdlZC5wdXNoKHRoaXMuX3ByZXZDdXJyZW50KTtcbiAgICAgICAgICB0aGlzLl9wcmV2Q3VycmVudCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB3ZWFrIG9mIGNoYW5nZWQpIHtcbiAgICAgICAgICBjb25zdCBlbCA9IHdlYWsgPT09IG51bGwgfHwgd2VhayA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2Vhay5nZXQoKTtcbiAgICAgICAgICBpZiAoZWwgJiYgKChfYSA9IHRoaXMuX2FsbEVsZW1lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KGVsKSkgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5fcHJvcHM7XG4gICAgICAgICAgICBpZiAoZWwgJiYgKHByb3BzLnZpc2liaWxpdHlBd2FyZSAhPT0gdW5kZWZpbmVkIHx8IHByb3BzLnRyYWNrU3RhdGUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZShlbCk7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IE1vdmVyU3RhdGVFdmVudChzdGF0ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0Q3VycmVudCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB0aGlzLl9jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCkpIHx8IG51bGw7XG4gIH1cbiAgZmluZE5leHRUYWJiYWJsZShjdXJyZW50RWxlbWVudCwgcmVmZXJlbmNlRWxlbWVudCwgaXNCYWNrd2FyZCwgaWdub3JlQWNjZXNzaWJpbGl0eSkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgIGNvbnN0IGN1cnJlbnRJc0R1bW15ID0gY29udGFpbmVyICYmIGdldER1bW15SW5wdXRDb250YWluZXIoY3VycmVudEVsZW1lbnQpID09PSBjb250YWluZXI7XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgbmV4dCA9IG51bGw7XG4gICAgbGV0IG91dE9mRE9NT3JkZXIgPSBmYWxzZTtcbiAgICBsZXQgdW5jb250cm9sbGVkO1xuICAgIGlmICh0aGlzLl9wcm9wcy50YWJiYWJsZSB8fCBjdXJyZW50SXNEdW1teSB8fCBjdXJyZW50RWxlbWVudCAmJiAhZG9tLm5vZGVDb250YWlucyhjb250YWluZXIsIGN1cnJlbnRFbGVtZW50KSkge1xuICAgICAgY29uc3QgZmluZFByb3BzID0ge1xuICAgICAgICBjdXJyZW50RWxlbWVudCxcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBpZ25vcmVBY2Nlc3NpYmlsaXR5LFxuICAgICAgICB1c2VBY3RpdmVNb2RhbGl6ZXI6IHRydWVcbiAgICAgIH07XG4gICAgICBjb25zdCBmaW5kUHJvcHNPdXQgPSB7fTtcbiAgICAgIG5leHQgPSB0aGlzLl90YWJzdGVyLmZvY3VzYWJsZVtpc0JhY2t3YXJkID8gXCJmaW5kUHJldlwiIDogXCJmaW5kTmV4dFwiXShmaW5kUHJvcHMsIGZpbmRQcm9wc091dCk7XG4gICAgICBvdXRPZkRPTU9yZGVyID0gISFmaW5kUHJvcHNPdXQub3V0T2ZET01PcmRlcjtcbiAgICAgIHVuY29udHJvbGxlZCA9IGZpbmRQcm9wc091dC51bmNvbnRyb2xsZWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50OiBuZXh0LFxuICAgICAgdW5jb250cm9sbGVkLFxuICAgICAgb3V0T2ZET01PcmRlclxuICAgIH07XG4gIH1cbiAgYWNjZXB0RWxlbWVudChlbGVtZW50LCBzdGF0ZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCFGb2N1c2VkRWxlbWVudFN0YXRlLmlzVGFiYmluZykge1xuICAgICAgcmV0dXJuICgoX2EgPSBzdGF0ZS5jdXJyZW50Q3R4KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXhjbHVkZWRGcm9tTW92ZXIpID8gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBtZW1vcml6ZUN1cnJlbnQsXG4gICAgICB2aXNpYmlsaXR5QXdhcmUsXG4gICAgICBoYXNEZWZhdWx0ID0gdHJ1ZVxuICAgIH0gPSB0aGlzLl9wcm9wcztcbiAgICBjb25zdCBtb3ZlckVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICBpZiAobW92ZXJFbGVtZW50ICYmIChtZW1vcml6ZUN1cnJlbnQgfHwgdmlzaWJpbGl0eUF3YXJlIHx8IGhhc0RlZmF1bHQpICYmICghZG9tLm5vZGVDb250YWlucyhtb3ZlckVsZW1lbnQsIHN0YXRlLmZyb20pIHx8IGdldER1bW15SW5wdXRDb250YWluZXIoc3RhdGUuZnJvbSkgPT09IG1vdmVyRWxlbWVudCkpIHtcbiAgICAgIGxldCBmb3VuZDtcbiAgICAgIGlmIChtZW1vcml6ZUN1cnJlbnQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IChfYiA9IHRoaXMuX2N1cnJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXQoKTtcbiAgICAgICAgaWYgKGN1cnJlbnQgJiYgc3RhdGUuYWNjZXB0Q29uZGl0aW9uKGN1cnJlbnQpKSB7XG4gICAgICAgICAgZm91bmQgPSBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kICYmIGhhc0RlZmF1bHQpIHtcbiAgICAgICAgZm91bmQgPSB0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5maW5kRGVmYXVsdCh7XG4gICAgICAgICAgY29udGFpbmVyOiBtb3ZlckVsZW1lbnQsXG4gICAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFmb3VuZCAmJiB2aXNpYmlsaXR5QXdhcmUpIHtcbiAgICAgICAgZm91bmQgPSB0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5maW5kRWxlbWVudCh7XG4gICAgICAgICAgY29udGFpbmVyOiBtb3ZlckVsZW1lbnQsXG4gICAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlLFxuICAgICAgICAgIGlzQmFja3dhcmQ6IHN0YXRlLmlzQmFja3dhcmQsXG4gICAgICAgICAgYWNjZXB0Q29uZGl0aW9uOiBlbCA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGdldEVsZW1lbnRVSWQodGhpcy5fd2luLCBlbCk7XG4gICAgICAgICAgICBjb25zdCB2aXNpYmlsaXR5ID0gdGhpcy5fdmlzaWJsZVtpZF07XG4gICAgICAgICAgICByZXR1cm4gbW92ZXJFbGVtZW50ICE9PSBlbCAmJiAhISgoX2EgPSB0aGlzLl9hbGxFbGVtZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChlbCkpICYmIHN0YXRlLmFjY2VwdENvbmRpdGlvbihlbCkgJiYgKHZpc2liaWxpdHkgPT09IFZpc2liaWxpdGllcy5WaXNpYmxlIHx8IHZpc2liaWxpdHkgPT09IFZpc2liaWxpdGllcy5QYXJ0aWFsbHlWaXNpYmxlICYmICh2aXNpYmlsaXR5QXdhcmUgPT09IFZpc2liaWxpdGllcy5QYXJ0aWFsbHlWaXNpYmxlIHx8ICF0aGlzLl9mdWxseVZpc2libGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIHN0YXRlLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuZm91bmRFbGVtZW50ID0gZm91bmQ7XG4gICAgICAgIHN0YXRlLnJlamVjdEVsZW1lbnRzRnJvbSA9IG1vdmVyRWxlbWVudDtcbiAgICAgICAgc3RhdGUuc2tpcHBlZEZvY3VzYWJsZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgX29ic2VydmVTdGF0ZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgaWYgKHRoaXMuX3Vub2JzZXJ2ZSB8fCAhZWxlbWVudCB8fCB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aW4gPSB0aGlzLl93aW4oKTtcbiAgICBjb25zdCBhbGxFbGVtZW50cyA9IHRoaXMuX2FsbEVsZW1lbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCB0YWJzdGVyRm9jdXNhYmxlID0gdGhpcy5fdGFic3Rlci5mb2N1c2FibGU7XG4gICAgbGV0IHVwZGF0ZVF1ZXVlID0gdGhpcy5fdXBkYXRlUXVldWUgPSBbXTtcbiAgICBjb25zdCBvYnNlcnZlciA9IGRvbS5jcmVhdGVNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBtdXRhdGlvbi50YXJnZXQ7XG4gICAgICAgIGNvbnN0IHJlbW92ZWQgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXM7XG4gICAgICAgIGNvbnN0IGFkZGVkID0gbXV0YXRpb24uYWRkZWROb2RlcztcbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICAgICAgaWYgKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUgPT09IFwidGFiaW5kZXhcIikge1xuICAgICAgICAgICAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgIGVsZW1lbnQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgdHlwZTogX21vdmVyVXBkYXRlQXR0clxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgIGVsZW1lbnQ6IHJlbW92ZWRbaV0sXG4gICAgICAgICAgICAgIHR5cGU6IF9tb3ZlclVwZGF0ZVJlbW92ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICBlbGVtZW50OiBhZGRlZFtpXSxcbiAgICAgICAgICAgICAgdHlwZTogX21vdmVyVXBkYXRlQWRkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICB9KTtcbiAgICBjb25zdCBzZXRFbGVtZW50ID0gKGVsZW1lbnQsIHJlbW92ZSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBhbGxFbGVtZW50cy5nZXQoZWxlbWVudCk7XG4gICAgICBpZiAoY3VycmVudCAmJiByZW1vdmUpIHtcbiAgICAgICAgKF9hID0gdGhpcy5faW50ZXJzZWN0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgIGFsbEVsZW1lbnRzLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGlmICghY3VycmVudCAmJiAhcmVtb3ZlKSB7XG4gICAgICAgIGFsbEVsZW1lbnRzLnNldChlbGVtZW50LCB0aGlzKTtcbiAgICAgICAgKF9iID0gdGhpcy5faW50ZXJzZWN0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlRWxlbWVudCA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgaXNGb2N1c2FibGUgPSB0YWJzdGVyRm9jdXNhYmxlLmlzRm9jdXNhYmxlKGVsZW1lbnQpO1xuICAgICAgY29uc3QgY3VycmVudCA9IGFsbEVsZW1lbnRzLmdldChlbGVtZW50KTtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIGlmICghaXNGb2N1c2FibGUpIHtcbiAgICAgICAgICBzZXRFbGVtZW50KGVsZW1lbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNGb2N1c2FibGUpIHtcbiAgICAgICAgICBzZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhZGROZXdFbGVtZW50cyA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtb3ZlclxuICAgICAgfSA9IGdldE1vdmVyR3JvdXBwZXIoZWxlbWVudCk7XG4gICAgICBpZiAobW92ZXIgJiYgbW92ZXIgIT09IHRoaXMpIHtcbiAgICAgICAgaWYgKG1vdmVyLmdldEVsZW1lbnQoKSA9PT0gZWxlbWVudCAmJiB0YWJzdGVyRm9jdXNhYmxlLmlzRm9jdXNhYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgc2V0RWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHdhbGtlciA9IGNyZWF0ZUVsZW1lbnRUcmVlV2Fsa2VyKHdpbi5kb2N1bWVudCwgZWxlbWVudCwgbm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBtb3ZlcixcbiAgICAgICAgICBncm91cHBlclxuICAgICAgICB9ID0gZ2V0TW92ZXJHcm91cHBlcihub2RlKTtcbiAgICAgICAgaWYgKG1vdmVyICYmIG1vdmVyICE9PSB0aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBncm91cHBlckZpcnN0Rm9jdXNhYmxlID0gZ3JvdXBwZXIgPT09IG51bGwgfHwgZ3JvdXBwZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyb3VwcGVyLmdldEZpcnN0KHRydWUpO1xuICAgICAgICBpZiAoZ3JvdXBwZXIgJiYgZ3JvdXBwZXIuZ2V0RWxlbWVudCgpICE9PSBub2RlICYmIGdyb3VwcGVyRmlyc3RGb2N1c2FibGUgJiYgZ3JvdXBwZXJGaXJzdEZvY3VzYWJsZSAhPT0gbm9kZSkge1xuICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhYnN0ZXJGb2N1c2FibGUuaXNGb2N1c2FibGUobm9kZSkpIHtcbiAgICAgICAgICBzZXRFbGVtZW50KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICAgfSk7XG4gICAgICBpZiAod2Fsa2VyKSB7XG4gICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IGVsZW1lbnQ7XG4gICAgICAgIHdoaWxlICh3YWxrZXIubmV4dE5vZGUoKSkge1xuICAgICAgICAgIC8qIEl0ZXJhdGluZyBmb3IgdGhlIHNha2Ugb2YgY2FsbGluZyBwcm9jZXNzTm9kZSgpIGNhbGxiYWNrLiAqL1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmVXYWxrID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gYWxsRWxlbWVudHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgc2V0RWxlbWVudChlbGVtZW50LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGVsID0gZG9tLmdldEZpcnN0RWxlbWVudENoaWxkKGVsZW1lbnQpOyBlbDsgZWwgPSBkb20uZ2V0TmV4dEVsZW1lbnRTaWJsaW5nKGVsKSkge1xuICAgICAgICByZW1vdmVXYWxrKGVsKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlcXVlc3RVcGRhdGUgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3VwZGF0ZVRpbWVyICYmIHVwZGF0ZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl91cGRhdGVUaW1lciA9IHdpbi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fdXBkYXRlVGltZXI7XG4gICAgICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIH0gb2YgdXBkYXRlUXVldWUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIF9tb3ZlclVwZGF0ZUF0dHI6XG4gICAgICAgICAgICAgICAgdXBkYXRlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBfbW92ZXJVcGRhdGVBZGQ6XG4gICAgICAgICAgICAgICAgYWRkTmV3RWxlbWVudHMoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgX21vdmVyVXBkYXRlUmVtb3ZlOlxuICAgICAgICAgICAgICAgIHJlbW92ZVdhbGsoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVF1ZXVlID0gdGhpcy5fdXBkYXRlUXVldWUgPSBbXTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRNb3Zlckdyb3VwcGVyID0gZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCByZXQgPSB7fTtcbiAgICAgIGZvciAobGV0IGVsID0gZWxlbWVudDsgZWw7IGVsID0gZG9tLmdldFBhcmVudEVsZW1lbnQoZWwpKSB7XG4gICAgICAgIGNvbnN0IHRvZSA9IGdldFRhYnN0ZXJPbkVsZW1lbnQodGhpcy5fdGFic3RlciwgZWwpO1xuICAgICAgICBpZiAodG9lKSB7XG4gICAgICAgICAgaWYgKHRvZS5ncm91cHBlciAmJiAhcmV0Lmdyb3VwcGVyKSB7XG4gICAgICAgICAgICByZXQuZ3JvdXBwZXIgPSB0b2UuZ3JvdXBwZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b2UubW92ZXIpIHtcbiAgICAgICAgICAgIHJldC5tb3ZlciA9IHRvZS5tb3ZlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgICAgZWxlbWVudCxcbiAgICAgIHR5cGU6IF9tb3ZlclVwZGF0ZUFkZFxuICAgIH0pO1xuICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgYXR0cmlidXRlRmlsdGVyOiBbXCJ0YWJpbmRleFwiXVxuICAgIH0pO1xuICAgIHRoaXMuX3Vub2JzZXJ2ZSA9ICgpID0+IHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9XG4gIGdldFN0YXRlKGVsZW1lbnQpIHtcbiAgICBjb25zdCBpZCA9IGdldEVsZW1lbnRVSWQodGhpcy5fd2luLCBlbGVtZW50KTtcbiAgICBpZiAoaWQgaW4gdGhpcy5fdmlzaWJsZSkge1xuICAgICAgY29uc3QgdmlzaWJpbGl0eSA9IHRoaXMuX3Zpc2libGVbaWRdIHx8IFZpc2liaWxpdGllcy5JbnZpc2libGU7XG4gICAgICBjb25zdCBpc0N1cnJlbnQgPSB0aGlzLl9jdXJyZW50ID8gdGhpcy5fY3VycmVudC5nZXQoKSA9PT0gZWxlbWVudCA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzQ3VycmVudCxcbiAgICAgICAgdmlzaWJpbGl0eVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuLyoqXG4gKiBDYWxjdWxhdGVzIGRpc3RhbmNlIGJldHdlZW4gdHdvIHJlY3RhbmdsZXMuXG4gKlxuICogQHBhcmFtIGF4MSBmaXJzdCByZWN0YW5nbGUgbGVmdFxuICogQHBhcmFtIGF5MSBmaXJzdCByZWN0YW5nbGUgdG9wXG4gKiBAcGFyYW0gYXgyIGZpcnN0IHJlY3RhbmdsZSByaWdodFxuICogQHBhcmFtIGF5MiBmaXJzdCByZWN0YW5nbGUgYm90dG9tXG4gKiBAcGFyYW0gYngxIHNlY29uZCByZWN0YW5nbGUgbGVmdFxuICogQHBhcmFtIGJ5MSBzZWNvbmQgcmVjdGFuZ2xlIHRvcFxuICogQHBhcmFtIGJ4MiBzZWNvbmQgcmVjdGFuZ2xlIHJpZ2h0XG4gKiBAcGFyYW0gYnkyIHNlY29uZCByZWN0YW5nbGUgYm90dG9tXG4gKiBAcmV0dXJucyBudW1iZXIsIHNob3J0ZXN0IGRpc3RhbmNlIGJldHdlZW4gdGhlIHJlY3RhbmdsZXMuXG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlKGF4MSwgYXkxLCBheDIsIGF5MiwgYngxLCBieTEsIGJ4MiwgYnkyKSB7XG4gIGNvbnN0IHhEaXN0YW5jZSA9IGF4MiA8IGJ4MSA/IGJ4MSAtIGF4MiA6IGJ4MiA8IGF4MSA/IGF4MSAtIGJ4MiA6IDA7XG4gIGNvbnN0IHlEaXN0YW5jZSA9IGF5MiA8IGJ5MSA/IGJ5MSAtIGF5MiA6IGJ5MiA8IGF5MSA/IGF5MSAtIGJ5MiA6IDA7XG4gIHJldHVybiB4RGlzdGFuY2UgPT09IDAgPyB5RGlzdGFuY2UgOiB5RGlzdGFuY2UgPT09IDAgPyB4RGlzdGFuY2UgOiBNYXRoLnNxcnQoeERpc3RhbmNlICogeERpc3RhbmNlICsgeURpc3RhbmNlICogeURpc3RhbmNlKTtcbn1cbmNsYXNzIE1vdmVyQVBJIHtcbiAgY29uc3RydWN0b3IodGFic3RlciwgZ2V0V2luZG93KSB7XG4gICAgdGhpcy5faW5pdCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93biwgdHJ1ZSk7XG4gICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihNb3Zlck1vdmVGb2N1c0V2ZW50TmFtZSwgdGhpcy5fb25Nb3ZlRm9jdXMpO1xuICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoTW92ZXJNZW1vcml6ZWRFbGVtZW50RXZlbnROYW1lLCB0aGlzLl9vbk1lbW9yaXplZEVsZW1lbnQpO1xuICAgICAgdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC5zdWJzY3JpYmUodGhpcy5fb25Gb2N1cyk7XG4gICAgfTtcbiAgICB0aGlzLl9vbk1vdmVyRGlzcG9zZSA9IG1vdmVyID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9tb3ZlcnNbbW92ZXIuaWRdO1xuICAgIH07XG4gICAgdGhpcy5fb25Gb2N1cyA9IGVsZW1lbnQgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgLy8gV2hlbiBzb21ldGhpbmcgaW4gdGhlIGFwcCBnZXRzIGZvY3VzZWQsIHdlIGFyZSBtYWtpbmcgc3VyZSB0aGF0XG4gICAgICAvLyB0aGUgcmVsZXZhbnQgY29udGV4dCBNb3ZlciBpcyBhd2FyZSBvZiBpdC5cbiAgICAgIC8vIExvb2tpbmcgZm9yIHRoZSByZWxldmFudCBjb250ZXh0IE1vdmVyIGZyb20gdGhlIGN1cnJlbnRseVxuICAgICAgLy8gZm9jdXNlZCBlbGVtZW50IHBhcmVudCwgbm90IGZyb20gdGhlIGVsZW1lbnQgaXRzZWxmLCBiZWNhdXNlIHRoZVxuICAgICAgLy8gTW92ZXIgZWxlbWVudCBpdHNlbGYgY2Fubm90IGJlIGl0cyBvd24gY3VycmVudCAoYnV0IG1pZ2h0IGJlXG4gICAgICAvLyBjdXJyZW50IGZvciBpdHMgcGFyZW50IE1vdmVyKS5cbiAgICAgIGxldCBjdXJyZW50Rm9jdXNhYmxlRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICBsZXQgZGVlcGVzdEZvY3VzYWJsZUVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgZm9yIChsZXQgZWwgPSBkb20uZ2V0UGFyZW50RWxlbWVudChlbGVtZW50KTsgZWw7IGVsID0gZG9tLmdldFBhcmVudEVsZW1lbnQoZWwpKSB7XG4gICAgICAgIC8vIFdlIGdvIHRocm91Z2ggYWxsIE1vdmVycyB1cCBmcm9tIHRoZSBmb2N1c2VkIGVsZW1lbnQgYW5kXG4gICAgICAgIC8vIHNldCB0aGVpciBjdXJyZW50IGVsZW1lbnQgdG8gdGhlIGRlZXBlc3QgZm9jdXNhYmxlIG9mIHRoYXRcbiAgICAgICAgLy8gTW92ZXIuXG4gICAgICAgIGNvbnN0IG1vdmVyID0gKF9hID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0aGlzLl90YWJzdGVyLCBlbCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb3ZlcjtcbiAgICAgICAgaWYgKG1vdmVyKSB7XG4gICAgICAgICAgbW92ZXIuc2V0Q3VycmVudChkZWVwZXN0Rm9jdXNhYmxlRWxlbWVudCk7XG4gICAgICAgICAgY3VycmVudEZvY3VzYWJsZUVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJyZW50Rm9jdXNhYmxlRWxlbWVudCAmJiB0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5pc0ZvY3VzYWJsZShlbCkpIHtcbiAgICAgICAgICBjdXJyZW50Rm9jdXNhYmxlRWxlbWVudCA9IGRlZXBlc3RGb2N1c2FibGVFbGVtZW50ID0gZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX29uS2V5RG93biA9IGFzeW5jIGV2ZW50ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICh0aGlzLl9pZ25vcmVkSW5wdXRUaW1lcikge1xuICAgICAgICB0aGlzLl93aW4oKS5jbGVhclRpbWVvdXQodGhpcy5faWdub3JlZElucHV0VGltZXIpO1xuICAgICAgICBkZWxldGUgdGhpcy5faWdub3JlZElucHV0VGltZXI7XG4gICAgICB9XG4gICAgICAoX2EgPSB0aGlzLl9pZ25vcmVkSW5wdXRSZXNvbHZlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBmYWxzZSk7XG4gICAgICAvLyBHaXZlIGEgY2hhbmNlIHRvIG90aGVyIGxpc3RlbmVycyB0byBoYW5kbGUgdGhlIGV2ZW50IChmb3IgZXhhbXBsZSxcbiAgICAgIC8vIHRvIHNjcm9sbCBpbnN0ZWFkIG9mIG1vdmluZyBmb2N1cykuXG4gICAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSBldmVudC5rZXk7XG4gICAgICBsZXQgbW92ZXJLZXk7XG4gICAgICBpZiAoa2V5ID09PSBLZXlzLkFycm93RG93bikge1xuICAgICAgICBtb3ZlcktleSA9IE1vdmVyS2V5cy5BcnJvd0Rvd247XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gS2V5cy5BcnJvd1JpZ2h0KSB7XG4gICAgICAgIG1vdmVyS2V5ID0gTW92ZXJLZXlzLkFycm93UmlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gS2V5cy5BcnJvd1VwKSB7XG4gICAgICAgIG1vdmVyS2V5ID0gTW92ZXJLZXlzLkFycm93VXA7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gS2V5cy5BcnJvd0xlZnQpIHtcbiAgICAgICAgbW92ZXJLZXkgPSBNb3ZlcktleXMuQXJyb3dMZWZ0O1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IEtleXMuUGFnZURvd24pIHtcbiAgICAgICAgbW92ZXJLZXkgPSBNb3ZlcktleXMuUGFnZURvd247XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gS2V5cy5QYWdlVXApIHtcbiAgICAgICAgbW92ZXJLZXkgPSBNb3ZlcktleXMuUGFnZVVwO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IEtleXMuSG9tZSkge1xuICAgICAgICBtb3ZlcktleSA9IE1vdmVyS2V5cy5Ib21lO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IEtleXMuRW5kKSB7XG4gICAgICAgIG1vdmVyS2V5ID0gTW92ZXJLZXlzLkVuZDtcbiAgICAgIH1cbiAgICAgIGlmICghbW92ZXJLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZm9jdXNlZCA9IHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZ2V0Rm9jdXNlZEVsZW1lbnQoKTtcbiAgICAgIGlmICghZm9jdXNlZCB8fCAoYXdhaXQgdGhpcy5faXNJZ25vcmVkSW5wdXQoZm9jdXNlZCwga2V5KSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbW92ZUZvY3VzKGZvY3VzZWQsIG1vdmVyS2V5LCBldmVudCk7XG4gICAgfTtcbiAgICB0aGlzLl9vbk1vdmVGb2N1cyA9IGUgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZWxlbWVudCA9IGUuY29tcG9zZWRQYXRoKClbMF07XG4gICAgICBjb25zdCBrZXkgPSAoX2EgPSBlLmRldGFpbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmtleTtcbiAgICAgIGlmIChlbGVtZW50ICYmIGtleSAhPT0gdW5kZWZpbmVkICYmICFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgdGhpcy5fbW92ZUZvY3VzKGVsZW1lbnQsIGtleSk7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbk1lbW9yaXplZEVsZW1lbnQgPSBlID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUuY29tcG9zZWRQYXRoKClbMF07XG4gICAgICBsZXQgbWVtb3JpemVkRWxlbWVudCA9IChfYSA9IGUuZGV0YWlsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVtb3JpemVkRWxlbWVudDtcbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gUm9vdEFQSS5nZXRUYWJzdGVyQ29udGV4dCh0aGlzLl90YWJzdGVyLCB0YXJnZXQpO1xuICAgICAgICBjb25zdCBtb3ZlciA9IGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5tb3ZlcjtcbiAgICAgICAgaWYgKG1vdmVyKSB7XG4gICAgICAgICAgaWYgKG1lbW9yaXplZEVsZW1lbnQgJiYgIWRvbS5ub2RlQ29udGFpbnMobW92ZXIuZ2V0RWxlbWVudCgpLCBtZW1vcml6ZWRFbGVtZW50KSkge1xuICAgICAgICAgICAgbWVtb3JpemVkRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW92ZXIuc2V0Q3VycmVudChtZW1vcml6ZWRFbGVtZW50KTtcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl90YWJzdGVyID0gdGFic3RlcjtcbiAgICB0aGlzLl93aW4gPSBnZXRXaW5kb3c7XG4gICAgdGhpcy5fbW92ZXJzID0ge307XG4gICAgdGFic3Rlci5xdWV1ZUluaXQodGhpcy5faW5pdCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgd2luID0gdGhpcy5fd2luKCk7XG4gICAgdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC51bnN1YnNjcmliZSh0aGlzLl9vbkZvY3VzKTtcbiAgICAoX2EgPSB0aGlzLl9pZ25vcmVkSW5wdXRSZXNvbHZlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBmYWxzZSk7XG4gICAgaWYgKHRoaXMuX2lnbm9yZWRJbnB1dFRpbWVyKSB7XG4gICAgICB3aW4uY2xlYXJUaW1lb3V0KHRoaXMuX2lnbm9yZWRJbnB1dFRpbWVyKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9pZ25vcmVkSW5wdXRUaW1lcjtcbiAgICB9XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5RG93biwgdHJ1ZSk7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoTW92ZXJNb3ZlRm9jdXNFdmVudE5hbWUsIHRoaXMuX29uTW92ZUZvY3VzKTtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihNb3Zlck1lbW9yaXplZEVsZW1lbnRFdmVudE5hbWUsIHRoaXMuX29uTWVtb3JpemVkRWxlbWVudCk7XG4gICAgT2JqZWN0LmtleXModGhpcy5fbW92ZXJzKS5mb3JFYWNoKG1vdmVySWQgPT4ge1xuICAgICAgaWYgKHRoaXMuX21vdmVyc1ttb3ZlcklkXSkge1xuICAgICAgICB0aGlzLl9tb3ZlcnNbbW92ZXJJZF0uZGlzcG9zZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5fbW92ZXJzW21vdmVySWRdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZU1vdmVyKGVsZW1lbnQsIHByb3BzLCBzeXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIDtcbiAgICBjb25zdCBuZXdNb3ZlciA9IG5ldyBNb3Zlcih0aGlzLl90YWJzdGVyLCBlbGVtZW50LCB0aGlzLl9vbk1vdmVyRGlzcG9zZSwgcHJvcHMsIHN5cyk7XG4gICAgdGhpcy5fbW92ZXJzW25ld01vdmVyLmlkXSA9IG5ld01vdmVyO1xuICAgIHJldHVybiBuZXdNb3ZlcjtcbiAgfVxuICBtb3ZlRm9jdXMoZnJvbUVsZW1lbnQsIGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tb3ZlRm9jdXMoZnJvbUVsZW1lbnQsIGtleSk7XG4gIH1cbiAgX21vdmVGb2N1cyhmcm9tRWxlbWVudCwga2V5LCByZWxhdGVkRXZlbnQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHRhYnN0ZXIgPSB0aGlzLl90YWJzdGVyO1xuICAgIGNvbnN0IGN0eCA9IFJvb3RBUEkuZ2V0VGFic3RlckNvbnRleHQodGFic3RlciwgZnJvbUVsZW1lbnQsIHtcbiAgICAgIGNoZWNrUnRsOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKCFjdHggfHwgIWN0eC5tb3ZlciB8fCBjdHguZXhjbHVkZWRGcm9tTW92ZXIgfHwgcmVsYXRlZEV2ZW50ICYmIGN0eC5pZ25vcmVLZXlkb3duKHJlbGF0ZWRFdmVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBtb3ZlciA9IGN0eC5tb3ZlcjtcbiAgICBjb25zdCBjb250YWluZXIgPSBtb3Zlci5nZXRFbGVtZW50KCk7XG4gICAgaWYgKGN0eC5ncm91cHBlckJlZm9yZU1vdmVyKSB7XG4gICAgICBjb25zdCBncm91cHBlciA9IGN0eC5ncm91cHBlcjtcbiAgICAgIGlmIChncm91cHBlciAmJiAhZ3JvdXBwZXIuaXNBY3RpdmUodHJ1ZSkpIHtcbiAgICAgICAgLy8gRm9yIHRoZSBjYXNlcyB3aGVuIHdlIGhhdmUgTW92ZXIvQWN0aXZlIEdyb3VwcGVyL0luYWN0aXZlIEdyb3VwcGVyLCB3ZSBuZWVkIHRvIGNoZWNrXG4gICAgICAgIC8vIHRoZSBncm91cHBlcnMgYmV0d2VlbiB0aGUgY3VycmVudCBlbGVtZW50IGFuZCB0aGUgY3VycmVudCBtb3Zlci5cbiAgICAgICAgZm9yIChsZXQgZWwgPSBkb20uZ2V0UGFyZW50RWxlbWVudChncm91cHBlci5nZXRFbGVtZW50KCkpOyBlbCAmJiBlbCAhPT0gY29udGFpbmVyOyBlbCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGVsKSkge1xuICAgICAgICAgIGlmICgoX2IgPSAoX2EgPSBnZXRUYWJzdGVyT25FbGVtZW50KHRhYnN0ZXIsIGVsKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdyb3VwcGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaXNBY3RpdmUodHJ1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZm9jdXNhYmxlID0gdGFic3Rlci5mb2N1c2FibGU7XG4gICAgY29uc3QgbW92ZXJQcm9wcyA9IG1vdmVyLmdldFByb3BzKCk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gbW92ZXJQcm9wcy5kaXJlY3Rpb24gfHwgTW92ZXJEaXJlY3Rpb25zLkJvdGg7XG4gICAgY29uc3QgaXNCb3RoID0gZGlyZWN0aW9uID09PSBNb3ZlckRpcmVjdGlvbnMuQm90aDtcbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gaXNCb3RoIHx8IGRpcmVjdGlvbiA9PT0gTW92ZXJEaXJlY3Rpb25zLlZlcnRpY2FsO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGlzQm90aCB8fCBkaXJlY3Rpb24gPT09IE1vdmVyRGlyZWN0aW9ucy5Ib3Jpem9udGFsO1xuICAgIGNvbnN0IGlzR3JpZExpbmVhciA9IGRpcmVjdGlvbiA9PT0gTW92ZXJEaXJlY3Rpb25zLkdyaWRMaW5lYXI7XG4gICAgY29uc3QgaXNHcmlkID0gaXNHcmlkTGluZWFyIHx8IGRpcmVjdGlvbiA9PT0gTW92ZXJEaXJlY3Rpb25zLkdyaWQ7XG4gICAgY29uc3QgaXNDeWNsaWMgPSBtb3ZlclByb3BzLmN5Y2xpYztcbiAgICBsZXQgbmV4dDtcbiAgICBsZXQgc2Nyb2xsSW50b1ZpZXdBcmc7XG4gICAgbGV0IGZvY3VzZWRFbGVtZW50UmVjdDtcbiAgICBsZXQgZm9jdXNlZEVsZW1lbnRYMSA9IDA7XG4gICAgbGV0IGZvY3VzZWRFbGVtZW50WDIgPSAwO1xuICAgIGlmIChpc0dyaWQpIHtcbiAgICAgIGZvY3VzZWRFbGVtZW50UmVjdCA9IGZyb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgZm9jdXNlZEVsZW1lbnRYMSA9IE1hdGguY2VpbChmb2N1c2VkRWxlbWVudFJlY3QubGVmdCk7XG4gICAgICBmb2N1c2VkRWxlbWVudFgyID0gTWF0aC5mbG9vcihmb2N1c2VkRWxlbWVudFJlY3QucmlnaHQpO1xuICAgIH1cbiAgICBpZiAoY3R4LnJ0bCkge1xuICAgICAgaWYgKGtleSA9PT0gTW92ZXJLZXlzLkFycm93UmlnaHQpIHtcbiAgICAgICAga2V5ID0gTW92ZXJLZXlzLkFycm93TGVmdDtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBNb3ZlcktleXMuQXJyb3dMZWZ0KSB7XG4gICAgICAgIGtleSA9IE1vdmVyS2V5cy5BcnJvd1JpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5ID09PSBNb3ZlcktleXMuQXJyb3dEb3duICYmIGlzVmVydGljYWwgfHwga2V5ID09PSBNb3ZlcktleXMuQXJyb3dSaWdodCAmJiAoaXNIb3Jpem9udGFsIHx8IGlzR3JpZCkpIHtcbiAgICAgIG5leHQgPSBmb2N1c2FibGUuZmluZE5leHQoe1xuICAgICAgICBjdXJyZW50RWxlbWVudDogZnJvbUVsZW1lbnQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmIChuZXh0ICYmIGlzR3JpZCkge1xuICAgICAgICBjb25zdCBuZXh0RWxlbWVudFgxID0gTWF0aC5jZWlsKG5leHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCk7XG4gICAgICAgIGlmICghaXNHcmlkTGluZWFyICYmIGZvY3VzZWRFbGVtZW50WDIgPiBuZXh0RWxlbWVudFgxKSB7XG4gICAgICAgICAgbmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghbmV4dCAmJiBpc0N5Y2xpYykge1xuICAgICAgICBuZXh0ID0gZm9jdXNhYmxlLmZpbmRGaXJzdCh7XG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIHVzZUFjdGl2ZU1vZGFsaXplcjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gTW92ZXJLZXlzLkFycm93VXAgJiYgaXNWZXJ0aWNhbCB8fCBrZXkgPT09IE1vdmVyS2V5cy5BcnJvd0xlZnQgJiYgKGlzSG9yaXpvbnRhbCB8fCBpc0dyaWQpKSB7XG4gICAgICBuZXh0ID0gZm9jdXNhYmxlLmZpbmRQcmV2KHtcbiAgICAgICAgY3VycmVudEVsZW1lbnQ6IGZyb21FbGVtZW50LFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHVzZUFjdGl2ZU1vZGFsaXplcjogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAobmV4dCAmJiBpc0dyaWQpIHtcbiAgICAgICAgY29uc3QgbmV4dEVsZW1lbnRYMiA9IE1hdGguZmxvb3IobmV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCk7XG4gICAgICAgIGlmICghaXNHcmlkTGluZWFyICYmIG5leHRFbGVtZW50WDIgPiBmb2N1c2VkRWxlbWVudFgxKSB7XG4gICAgICAgICAgbmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghbmV4dCAmJiBpc0N5Y2xpYykge1xuICAgICAgICBuZXh0ID0gZm9jdXNhYmxlLmZpbmRMYXN0KHtcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBNb3ZlcktleXMuSG9tZSkge1xuICAgICAgaWYgKGlzR3JpZCkge1xuICAgICAgICBmb2N1c2FibGUuZmluZEVsZW1lbnQoe1xuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBjdXJyZW50RWxlbWVudDogZnJvbUVsZW1lbnQsXG4gICAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlLFxuICAgICAgICAgIGlzQmFja3dhcmQ6IHRydWUsXG4gICAgICAgICAgYWNjZXB0Q29uZGl0aW9uOiBlbCA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIWZvY3VzYWJsZS5pc0ZvY3VzYWJsZShlbCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dEVsZW1lbnRYMSA9IE1hdGguY2VpbCgoX2EgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKTtcbiAgICAgICAgICAgIGlmIChlbCAhPT0gZnJvbUVsZW1lbnQgJiYgZm9jdXNlZEVsZW1lbnRYMSA8PSBuZXh0RWxlbWVudFgxKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IGVsO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0ID0gZm9jdXNhYmxlLmZpbmRGaXJzdCh7XG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIHVzZUFjdGl2ZU1vZGFsaXplcjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gTW92ZXJLZXlzLkVuZCkge1xuICAgICAgaWYgKGlzR3JpZCkge1xuICAgICAgICBmb2N1c2FibGUuZmluZEVsZW1lbnQoe1xuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBjdXJyZW50RWxlbWVudDogZnJvbUVsZW1lbnQsXG4gICAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlLFxuICAgICAgICAgIGFjY2VwdENvbmRpdGlvbjogZWwgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKCFmb2N1c2FibGUuaXNGb2N1c2FibGUoZWwpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHRFbGVtZW50WDEgPSBNYXRoLmNlaWwoKF9hID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCk7XG4gICAgICAgICAgICBpZiAoZWwgIT09IGZyb21FbGVtZW50ICYmIGZvY3VzZWRFbGVtZW50WDEgPj0gbmV4dEVsZW1lbnRYMSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSBlbDtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCA9IGZvY3VzYWJsZS5maW5kTGFzdCh7XG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIHVzZUFjdGl2ZU1vZGFsaXplcjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gTW92ZXJLZXlzLlBhZ2VVcCkge1xuICAgICAgZm9jdXNhYmxlLmZpbmRFbGVtZW50KHtcbiAgICAgICAgY3VycmVudEVsZW1lbnQ6IGZyb21FbGVtZW50LFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHVzZUFjdGl2ZU1vZGFsaXplcjogdHJ1ZSxcbiAgICAgICAgaXNCYWNrd2FyZDogdHJ1ZSxcbiAgICAgICAgYWNjZXB0Q29uZGl0aW9uOiBlbCA9PiB7XG4gICAgICAgICAgaWYgKCFmb2N1c2FibGUuaXNGb2N1c2FibGUoZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0VsZW1lbnRWZXJ0aWNhbGx5VmlzaWJsZUluQ29udGFpbmVyKHRoaXMuX3dpbiwgZWwsIG1vdmVyLnZpc2liaWxpdHlUb2xlcmFuY2UpKSB7XG4gICAgICAgICAgICBuZXh0ID0gZWw7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIHdpbGwgYmUgb24gdGhlIGZpcnN0IGNvbHVtbiBtb3ZlIGZvcndhcmQgYW5kIHByZXNlcnZlIHByZXZpb3VzIGNvbHVtblxuICAgICAgaWYgKGlzR3JpZCAmJiBuZXh0KSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q29sdW1uWDEgPSBNYXRoLmNlaWwobmV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KTtcbiAgICAgICAgZm9jdXNhYmxlLmZpbmRFbGVtZW50KHtcbiAgICAgICAgICBjdXJyZW50RWxlbWVudDogbmV4dCxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgdXNlQWN0aXZlTW9kYWxpemVyOiB0cnVlLFxuICAgICAgICAgIGFjY2VwdENvbmRpdGlvbjogZWwgPT4ge1xuICAgICAgICAgICAgaWYgKCFmb2N1c2FibGUuaXNGb2N1c2FibGUoZWwpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHRFbGVtZW50WDEgPSBNYXRoLmNlaWwoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCk7XG4gICAgICAgICAgICBpZiAoZm9jdXNlZEVsZW1lbnRYMSA8IG5leHRFbGVtZW50WDEgfHwgZmlyc3RDb2x1bW5YMSA+PSBuZXh0RWxlbWVudFgxKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IGVsO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzY3JvbGxJbnRvVmlld0FyZyA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBNb3ZlcktleXMuUGFnZURvd24pIHtcbiAgICAgIGZvY3VzYWJsZS5maW5kRWxlbWVudCh7XG4gICAgICAgIGN1cnJlbnRFbGVtZW50OiBmcm9tRWxlbWVudCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICB1c2VBY3RpdmVNb2RhbGl6ZXI6IHRydWUsXG4gICAgICAgIGFjY2VwdENvbmRpdGlvbjogZWwgPT4ge1xuICAgICAgICAgIGlmICghZm9jdXNhYmxlLmlzRm9jdXNhYmxlKGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNFbGVtZW50VmVydGljYWxseVZpc2libGVJbkNvbnRhaW5lcih0aGlzLl93aW4sIGVsLCBtb3Zlci52aXNpYmlsaXR5VG9sZXJhbmNlKSkge1xuICAgICAgICAgICAgbmV4dCA9IGVsO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyB3aWxsIGJlIG9uIHRoZSBsYXN0IGNvbHVtbiBtb3ZlIGJhY2t3YXJkcyBhbmQgcHJlc2VydmUgcHJldmlvdXMgY29sdW1uXG4gICAgICBpZiAoaXNHcmlkICYmIG5leHQpIHtcbiAgICAgICAgY29uc3QgbGFzdENvbHVtblgxID0gTWF0aC5jZWlsKG5leHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCk7XG4gICAgICAgIGZvY3VzYWJsZS5maW5kRWxlbWVudCh7XG4gICAgICAgICAgY3VycmVudEVsZW1lbnQ6IG5leHQsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIHVzZUFjdGl2ZU1vZGFsaXplcjogdHJ1ZSxcbiAgICAgICAgICBpc0JhY2t3YXJkOiB0cnVlLFxuICAgICAgICAgIGFjY2VwdENvbmRpdGlvbjogZWwgPT4ge1xuICAgICAgICAgICAgaWYgKCFmb2N1c2FibGUuaXNGb2N1c2FibGUoZWwpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHRFbGVtZW50WDEgPSBNYXRoLmNlaWwoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCk7XG4gICAgICAgICAgICBpZiAoZm9jdXNlZEVsZW1lbnRYMSA+IG5leHRFbGVtZW50WDEgfHwgbGFzdENvbHVtblgxIDw9IG5leHRFbGVtZW50WDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gZWw7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHNjcm9sbEludG9WaWV3QXJnID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzR3JpZCkge1xuICAgICAgY29uc3QgaXNCYWNrd2FyZCA9IGtleSA9PT0gTW92ZXJLZXlzLkFycm93VXA7XG4gICAgICBjb25zdCBheDEgPSBmb2N1c2VkRWxlbWVudFgxO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgIGNvbnN0IGF5MSA9IE1hdGguY2VpbChmb2N1c2VkRWxlbWVudFJlY3QudG9wKTtcbiAgICAgIGNvbnN0IGF4MiA9IGZvY3VzZWRFbGVtZW50WDI7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgY29uc3QgYXkyID0gTWF0aC5mbG9vcihmb2N1c2VkRWxlbWVudFJlY3QuYm90dG9tKTtcbiAgICAgIGxldCB0YXJnZXRFbGVtZW50O1xuICAgICAgbGV0IGxhc3REaXN0YW5jZTtcbiAgICAgIGxldCBsYXN0SW50ZXJzZWN0aW9uID0gMDtcbiAgICAgIGZvY3VzYWJsZS5maW5kQWxsKHtcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBjdXJyZW50RWxlbWVudDogZnJvbUVsZW1lbnQsXG4gICAgICAgIGlzQmFja3dhcmQsXG4gICAgICAgIG9uRWxlbWVudDogZWwgPT4ge1xuICAgICAgICAgIC8vIEZpbmQgZWxlbWVudCB3aGljaCBoYXMgbWF4aW1hbCBpbnRlcnNlY3Rpb24gd2l0aCB0aGUgZm9jdXNlZCBlbGVtZW50IGhvcml6b250YWxseSxcbiAgICAgICAgICAvLyBvciB0aGUgY2xvc2VzdCBvbmUuXG4gICAgICAgICAgY29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIGNvbnN0IGJ4MSA9IE1hdGguY2VpbChyZWN0LmxlZnQpO1xuICAgICAgICAgIGNvbnN0IGJ5MSA9IE1hdGguY2VpbChyZWN0LnRvcCk7XG4gICAgICAgICAgY29uc3QgYngyID0gTWF0aC5mbG9vcihyZWN0LnJpZ2h0KTtcbiAgICAgICAgICBjb25zdCBieTIgPSBNYXRoLmZsb29yKHJlY3QuYm90dG9tKTtcbiAgICAgICAgICBpZiAoaXNCYWNrd2FyZCAmJiBheTEgPCBieTIgfHwgIWlzQmFja3dhcmQgJiYgYXkyID4gYnkxKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGNvbnNpZGVyIGVsZW1lbnRzIHdoaWNoIGFyZSBiZWxvdy9hYm92ZSBjdXJyZXRseSBmb2N1c2VkLlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHhJbnRlcnNlY3Rpb25XaWR0aCA9IE1hdGguY2VpbChNYXRoLm1pbihheDIsIGJ4MikpIC0gTWF0aC5mbG9vcihNYXRoLm1heChheDEsIGJ4MSkpO1xuICAgICAgICAgIGNvbnN0IG1pbldpZHRoID0gTWF0aC5jZWlsKE1hdGgubWluKGF4MiAtIGF4MSwgYngyIC0gYngxKSk7XG4gICAgICAgICAgaWYgKHhJbnRlcnNlY3Rpb25XaWR0aCA+IDAgJiYgbWluV2lkdGggPj0geEludGVyc2VjdGlvbldpZHRoKSB7XG4gICAgICAgICAgICAvLyBFbGVtZW50IGludGVyc2VjdHMgd2l0aCB0aGUgZm9jdXNlZCBlbGVtZW50IG9uIFggYXhpcy5cbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IHhJbnRlcnNlY3Rpb25XaWR0aCAvIG1pbldpZHRoO1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbiA+IGxhc3RJbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9IGVsO1xuICAgICAgICAgICAgICBsYXN0SW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobGFzdEludGVyc2VjdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGhhdmUgaW50ZXJzZWN0aW9uLCB0cnkganVzdCB0aGUgY2xvc2VzdCBvbmUuXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGdldERpc3RhbmNlKGF4MSwgYXkxLCBheDIsIGF5MiwgYngxLCBieTEsIGJ4MiwgYnkyKTtcbiAgICAgICAgICAgIGlmIChsYXN0RGlzdGFuY2UgPT09IHVuZGVmaW5lZCB8fCBkaXN0YW5jZSA8IGxhc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgICBsYXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9IGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobGFzdEludGVyc2VjdGlvbiA+IDApIHtcbiAgICAgICAgICAgIC8vIEVsZW1lbnQgZG9lc24ndCBpbnRlcnNlY3QsIGJ1dCB3ZSBoYWQgaW50ZXJzZWN0aW9uIGFscmVhZHksIHN0b3Agc2VhcmNoLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBuZXh0ID0gdGFyZ2V0RWxlbWVudDtcbiAgICB9XG4gICAgaWYgKG5leHQgJiYgKCFyZWxhdGVkRXZlbnQgfHwgcmVsYXRlZEV2ZW50ICYmIGNvbnRhaW5lci5kaXNwYXRjaEV2ZW50KG5ldyBUYWJzdGVyTW92ZUZvY3VzRXZlbnQoe1xuICAgICAgYnk6IFwibW92ZXJcIixcbiAgICAgIG93bmVyOiBjb250YWluZXIsXG4gICAgICBuZXh0LFxuICAgICAgcmVsYXRlZEV2ZW50XG4gICAgfSkpKSkge1xuICAgICAgaWYgKHNjcm9sbEludG9WaWV3QXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXcodGhpcy5fd2luLCBuZXh0LCBzY3JvbGxJbnRvVmlld0FyZyk7XG4gICAgICB9XG4gICAgICBpZiAocmVsYXRlZEV2ZW50KSB7XG4gICAgICAgIHJlbGF0ZWRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZWxhdGVkRXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBuYXRpdmVGb2N1cyhuZXh0KTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBhc3luYyBfaXNJZ25vcmVkSW5wdXQoZWxlbWVudCwga2V5KSB7XG4gICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiKSA9PT0gXCJ0cnVlXCIgJiYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIpIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSA9PT0gXCJjb21ib2JveFwiKSkge1xuICAgICAgLy8gSXQgaXMgbGlrZWx5IGEgY29tYm9ib3ggd2l0aCBleHBhbmRlZCBvcHRpb25zIGFuZCBhcnJvdyBrZXlzIGFyZVxuICAgICAgLy8gY29udHJvbGxlZCBieSBpdC5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKGVsZW1lbnQsIF9pbnB1dFNlbGVjdG9yKSkge1xuICAgICAgbGV0IHNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICAgIGxldCBzZWxlY3Rpb25FbmQgPSAwO1xuICAgICAgbGV0IHRleHRMZW5ndGggPSAwO1xuICAgICAgbGV0IGFzeW5jUmV0O1xuICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gXCJJTlBVVFwiIHx8IGVsZW1lbnQudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgdGV4dExlbmd0aCA9ICh2YWx1ZSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlID09PSBcImVtYWlsXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIC8vIEZvciB0aGVzZSB0eXBlcyBDaHJvbWl1bSBkb2Vzbid0IHByb3ZpZGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZC5cbiAgICAgICAgICAvLyBIZW5jZSB0aGUgdWdseSB3b3JrYXJvdW5kIHRvIGZpbmQgaWYgdGhlIGNhcmV0IHBvc2l0aW9uIGlzIGNoYW5nZWQgd2l0aFxuICAgICAgICAgIC8vIHRoZSBrZXlwcmVzcy5cbiAgICAgICAgICAvLyBUT0RPOiBIYXZlIGEgbG9vayBhdCByYW5nZSwgd2VlaywgdGltZSwgdGltZSwgZGF0ZSwgZGF0ZXRpbWUtbG9jYWwuXG4gICAgICAgICAgaWYgKHRleHRMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvbS5nZXRTZWxlY3Rpb24oZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxMZW5ndGggPSBzZWxlY3Rpb24udG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgICAgICAgIGNvbnN0IGlzQmFja3dhcmQgPSBrZXkgPT09IEtleXMuQXJyb3dMZWZ0IHx8IGtleSA9PT0gS2V5cy5BcnJvd1VwO1xuICAgICAgICAgICAgICBzZWxlY3Rpb24ubW9kaWZ5KFwiZXh0ZW5kXCIsIGlzQmFja3dhcmQgPyBcImJhY2t3YXJkXCIgOiBcImZvcndhcmRcIiwgXCJjaGFyYWN0ZXJcIik7XG4gICAgICAgICAgICAgIGlmIChpbml0aWFsTGVuZ3RoICE9PSBzZWxlY3Rpb24udG9TdHJpbmcoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FyZXQgaXMgbW92ZWQsIHNvLCB3ZSdyZSBub3Qgb24gdGhlIGVkZ2Ugb2YgdGhlIHZhbHVlLlxuICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgc2VsZWN0aW9uLlxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5tb2RpZnkoXCJleHRlbmRcIiwgaXNCYWNrd2FyZCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiLCBcImNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzZWxTdGFydCA9IGVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgaWYgKHNlbFN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgaWdub3JlIG5vdCB0ZXh0IGVkaXRhYmxlIGlucHV0cyBsaWtlIGNoZWNrYm94ZXMgYW5kIHJhZGlvcyAoYnV0IGlnbm9yZSBoaWRkZW4pLlxuICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT09IFwiaGlkZGVuXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gc2VsU3RhcnQgfHwgMDtcbiAgICAgICAgICBzZWxlY3Rpb25FbmQgPSBlbGVtZW50LnNlbGVjdGlvbkVuZCB8fCAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuY29udGVudEVkaXRhYmxlID09PSBcInRydWVcIikge1xuICAgICAgICBhc3luY1JldCA9IG5ldyAoZ2V0UHJvbWlzZSh0aGlzLl93aW4pKShyZXNvbHZlID0+IHtcbiAgICAgICAgICB0aGlzLl9pZ25vcmVkSW5wdXRSZXNvbHZlID0gdmFsdWUgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2lnbm9yZWRJbnB1dFJlc29sdmU7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgICAgICAgIGlmICh0aGlzLl9pZ25vcmVkSW5wdXRUaW1lcikge1xuICAgICAgICAgICAgd2luLmNsZWFyVGltZW91dCh0aGlzLl9pZ25vcmVkSW5wdXRUaW1lcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGFuY2hvck5vZGU6IHByZXZBbmNob3JOb2RlLFxuICAgICAgICAgICAgZm9jdXNOb2RlOiBwcmV2Rm9jdXNOb2RlLFxuICAgICAgICAgICAgYW5jaG9yT2Zmc2V0OiBwcmV2QW5jaG9yT2Zmc2V0LFxuICAgICAgICAgICAgZm9jdXNPZmZzZXQ6IHByZXZGb2N1c09mZnNldFxuICAgICAgICAgIH0gPSBkb20uZ2V0U2VsZWN0aW9uKGVsZW1lbnQpIHx8IHt9O1xuICAgICAgICAgIC8vIEdldCBzZWxlY3Rpb24gZ2l2ZXMgaW5jb3JyZWN0IHZhbHVlIGlmIHdlIGNhbGwgaXQgc3luY3Jvbm91c2x5IG9uS2V5RG93bi5cbiAgICAgICAgICB0aGlzLl9pZ25vcmVkSW5wdXRUaW1lciA9IHdpbi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2lnbm9yZWRJbnB1dFRpbWVyO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBhbmNob3JOb2RlLFxuICAgICAgICAgICAgICBmb2N1c05vZGUsXG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCxcbiAgICAgICAgICAgICAgZm9jdXNPZmZzZXRcbiAgICAgICAgICAgIH0gPSBkb20uZ2V0U2VsZWN0aW9uKGVsZW1lbnQpIHx8IHt9O1xuICAgICAgICAgICAgaWYgKGFuY2hvck5vZGUgIT09IHByZXZBbmNob3JOb2RlIHx8IGZvY3VzTm9kZSAhPT0gcHJldkZvY3VzTm9kZSB8fCBhbmNob3JPZmZzZXQgIT09IHByZXZBbmNob3JPZmZzZXQgfHwgZm9jdXNPZmZzZXQgIT09IHByZXZGb2N1c09mZnNldCkge1xuICAgICAgICAgICAgICAoX2EgPSB0aGlzLl9pZ25vcmVkSW5wdXRSZXNvbHZlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gYW5jaG9yT2Zmc2V0IHx8IDA7XG4gICAgICAgICAgICBzZWxlY3Rpb25FbmQgPSBmb2N1c09mZnNldCB8fCAwO1xuICAgICAgICAgICAgdGV4dExlbmd0aCA9ICgoX2IgPSBlbGVtZW50LnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSB8fCAwO1xuICAgICAgICAgICAgaWYgKGFuY2hvck5vZGUgJiYgZm9jdXNOb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChkb20ubm9kZUNvbnRhaW5zKGVsZW1lbnQsIGFuY2hvck5vZGUpICYmIGRvbS5ub2RlQ29udGFpbnMoZWxlbWVudCwgZm9jdXNOb2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChhbmNob3JOb2RlICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgYW5jaG9yRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZE9mZnNldHMgPSBub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IGFuY2hvck5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhbmNob3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gZm9jdXNOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZVRleHQgPSBub2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVRleHQgJiYgIWRvbS5nZXRGaXJzdENoaWxkKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuID0gbm9kZVRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmNob3JGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzTm9kZSAhPT0gYW5jaG9yTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQgKz0gbGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydCArPSBsZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQgKz0gbGVuO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBlID0gZG9tLmdldEZpcnN0Q2hpbGQobm9kZSk7IGUgJiYgIXN0b3A7IGUgPSBlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IGFkZE9mZnNldHMoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3A7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgYWRkT2Zmc2V0cyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYyA9IHRoaXMuX2lnbm9yZWRJbnB1dFJlc29sdmUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHRoaXMsIHRydWUpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChhc3luY1JldCAmJiAhKGF3YWl0IGFzeW5jUmV0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID4gMCAmJiAoa2V5ID09PSBLZXlzLkFycm93TGVmdCB8fCBrZXkgPT09IEtleXMuQXJyb3dVcCB8fCBrZXkgPT09IEtleXMuSG9tZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPCB0ZXh0TGVuZ3RoICYmIChrZXkgPT09IEtleXMuQXJyb3dSaWdodCB8fCBrZXkgPT09IEtleXMuQXJyb3dEb3duIHx8IGtleSA9PT0gS2V5cy5FbmQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZU11dGF0aW9ucyhkb2MsIHRhYnN0ZXIsIHVwZGF0ZVRhYnN0ZXJCeUF0dHJpYnV0ZSwgc3luY1N0YXRlKSB7XG4gIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvKiBOb29wICovXG4gICAgfTtcbiAgfVxuICBjb25zdCBnZXRXaW5kb3cgPSB0YWJzdGVyLmdldFdpbmRvdztcbiAgbGV0IGVsZW1lbnRCeVVJZDtcbiAgY29uc3Qgb25NdXRhdGlvbiA9IG11dGF0aW9ucyA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCByZW1vdmVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IG11dGF0aW9uLnRhcmdldDtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXM7XG4gICAgICBjb25zdCBhZGRlZCA9IG11dGF0aW9uLmFkZGVkTm9kZXM7XG4gICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgaWYgKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUgPT09IFRBQlNURVJfQVRUUklCVVRFX05BTUUpIHtcbiAgICAgICAgICAvLyByZW1vdmVkTm9kZXMgaGVscHMgdG8gbWFrZSBzdXJlIHdlIGFyZSBub3QgcmVjcmVhdGluZyB0aGluZ3NcbiAgICAgICAgICAvLyBmb3IgdGhlIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uLCBpZiB3ZSBkbyByZW1vdmVDaGlsZCgpIGFuZCBzZXRBdHRyaWJ1dGUoKSBvbiB0aGVcbiAgICAgICAgICAvLyByZW1vdmVkIGNoaWxkIGluIHRoZSBzYW1lIHRpY2ssIGJvdGggdGhlIGNoaWxkIHJlbW92YWwgYW5kIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAvLyBjaGFuZ2Ugd2lsbCBiZSBwcmVzZW50IGluIHRoZSBtdXRhdGlvbiByZWNvcmRzLiBBbmQgdGhlIGF0dHJpYnV0ZSBjaGFuZ2VcbiAgICAgICAgICAvLyB3aWxsIGZvbGxvdyB0aGUgY2hpbGQgcmVtb3ZhbC5cbiAgICAgICAgICAvLyBTbywgd2UgcmVtZW1iZXIgdGhlIHJlbW92ZWQgbm9kZXMgYW5kIGlnbm9yZSBhdHRyaWJ1dGUgY2hhbmdlcyBmb3IgdGhlbS5cbiAgICAgICAgICBpZiAoIXJlbW92ZWROb2Rlcy5oYXModGFyZ2V0KSkge1xuICAgICAgICAgICAgdXBkYXRlVGFic3RlckJ5QXR0cmlidXRlKHRhYnN0ZXIsIHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCByZW1vdmVkTm9kZSA9IHJlbW92ZWRbaV07XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzLmFkZChyZW1vdmVkTm9kZSk7XG4gICAgICAgICAgdXBkYXRlVGFic3RlckVsZW1lbnRzKHJlbW92ZWROb2RlLCB0cnVlKTtcbiAgICAgICAgICAoX2IgPSAoX2EgPSB0YWJzdGVyLl9kdW1teU9ic2VydmVyKS5kb21DaGFuZ2VkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdXBkYXRlVGFic3RlckVsZW1lbnRzKGFkZGVkW2ldKTtcbiAgICAgICAgICAoX2QgPSAoX2MgPSB0YWJzdGVyLl9kdW1teU9ic2VydmVyKS5kb21DaGFuZ2VkKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVkTm9kZXMuY2xlYXIoKTtcbiAgICAoX2UgPSB0YWJzdGVyLm1vZGFsaXplcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmhpZGRlblVwZGF0ZSgpO1xuICB9O1xuICBmdW5jdGlvbiB1cGRhdGVUYWJzdGVyRWxlbWVudHMobm9kZSwgcmVtb3ZlZCkge1xuICAgIGlmICghZWxlbWVudEJ5VUlkKSB7XG4gICAgICBlbGVtZW50QnlVSWQgPSBnZXRJbnN0YW5jZUNvbnRleHQoZ2V0V2luZG93KS5lbGVtZW50QnlVSWQ7XG4gICAgfVxuICAgIHByb2Nlc3NOb2RlKG5vZGUsIHJlbW92ZWQpO1xuICAgIGNvbnN0IHdhbGtlciA9IGNyZWF0ZUVsZW1lbnRUcmVlV2Fsa2VyKGRvYywgbm9kZSwgZWxlbWVudCA9PiB7XG4gICAgICByZXR1cm4gcHJvY2Vzc05vZGUoZWxlbWVudCwgcmVtb3ZlZCk7XG4gICAgfSk7XG4gICAgaWYgKHdhbGtlcikge1xuICAgICAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgIC8qIEl0ZXJhdGluZyBmb3IgdGhlIHNha2Ugb2YgY2FsbGluZyBwcm9jZXNzTm9kZSgpIGNhbGxiYWNrLiAqL1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzTm9kZShlbGVtZW50LCByZW1vdmVkKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghZWxlbWVudC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgIC8vIEl0IG1pZ2h0IGFjdHVhbGx5IGJlIGEgdGV4dCBub2RlLlxuICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgfVxuICAgIGNvbnN0IHVpZCA9IGVsZW1lbnQuX190YWJzdGVyRWxlbWVudFVJRDtcbiAgICBpZiAodWlkICYmIGVsZW1lbnRCeVVJZCkge1xuICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgZGVsZXRlIGVsZW1lbnRCeVVJZFt1aWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKF9hID0gZWxlbWVudEJ5VUlkW3VpZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVsZW1lbnRCeVVJZFt1aWRdID0gbmV3IFdlYWtIVE1MRWxlbWVudChnZXRXaW5kb3csIGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ2V0VGFic3Rlck9uRWxlbWVudCh0YWJzdGVyLCBlbGVtZW50KSB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZShUQUJTVEVSX0FUVFJJQlVURV9OQU1FKSkge1xuICAgICAgdXBkYXRlVGFic3RlckJ5QXR0cmlidXRlKHRhYnN0ZXIsIGVsZW1lbnQsIHJlbW92ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgfVxuICBjb25zdCBvYnNlcnZlciA9IGRvbS5jcmVhdGVNdXRhdGlvbk9ic2VydmVyKG9uTXV0YXRpb24pO1xuICBpZiAoc3luY1N0YXRlKSB7XG4gICAgdXBkYXRlVGFic3RlckVsZW1lbnRzKGdldFdpbmRvdygpLmRvY3VtZW50LmJvZHkpO1xuICB9XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jLCB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIHN1YnRyZWU6IHRydWUsXG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtUQUJTVEVSX0FUVFJJQlVURV9OQU1FXVxuICB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH07XG59XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmNvbnN0IF9jb25kaXRpb25DaGVja1RpbWVvdXQgPSAxMDA7XG5jbGFzcyBPYnNlcnZlZEVsZW1lbnRBUEkgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICBjb25zdHJ1Y3Rvcih0YWJzdGVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl93YWl0aW5nID0ge307XG4gICAgdGhpcy5fbGFzdFJlcXVlc3RGb2N1c0lkID0gMDtcbiAgICB0aGlzLl9vYnNlcnZlZEJ5SWQgPSB7fTtcbiAgICB0aGlzLl9vYnNlcnZlZEJ5TmFtZSA9IHt9O1xuICAgIHRoaXMuX2N1cnJlbnRSZXF1ZXN0VGltZXN0YW1wID0gMDtcbiAgICB0aGlzLl9vbkZvY3VzID0gZSA9PiB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5fY3VycmVudFJlcXVlc3Q7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgY29uc3QgZGVsdGEgPSBEYXRlLm5vdygpIC0gdGhpcy5fY3VycmVudFJlcXVlc3RUaW1lc3RhbXA7XG4gICAgICAgICAgY29uc3Qgc2V0dGxlVGltZSA9IDMwMDtcbiAgICAgICAgICBpZiAoZGVsdGEgPj0gc2V0dGxlVGltZSkge1xuICAgICAgICAgICAgLy8gR2l2aW5nIHNvbWUgdGltZSBmb3IgdGhlIGZvY3VzIHRvIHNldHRsZSBiZWZvcmVcbiAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgY2FuY2VsbGluZyB0aGUgY3VycmVudCByZXF1ZXN0IG9uIGZvY3VzIGNoYW5nZS5cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jdXJyZW50UmVxdWVzdDtcbiAgICAgICAgICAgIC8vIFByb3ZpZGUgY2FsbGJhY2sgdG8gYWNjZXNzIGZvY3VzZWQgZWxlbWVudCB1c2luZyBXZWFrUmVmIHRvIGF2b2lkIG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudFJlZiA9IG5ldyBXZWFrUmVmKGUpO1xuICAgICAgICAgICAgY3VycmVudC5kaWFnbm9zdGljcy5nZXRDYW5jZWxUcmlnZ2VyaW5nRWxlbWVudCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICByZXR1cm4gKF9hID0gZWxlbWVudFJlZi5kZXJlZigpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGN1cnJlbnQuZGlhZ25vc3RpY3MucmVhc29uID0gT2JzZXJ2ZWRFbGVtZW50RmFpbHVyZVJlYXNvbnMuQ2FuY2VsZWRGb2N1c0NoYW5nZTtcbiAgICAgICAgICAgIGN1cnJlbnQuY2FuY2VsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9uT2JzZXJ2ZWRFbGVtZW50VXBkYXRlID0gZWxlbWVudCA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3Qgb2JzZXJ2ZWQgPSAoX2EgPSBnZXRUYWJzdGVyT25FbGVtZW50KHRoaXMuX3RhYnN0ZXIsIGVsZW1lbnQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub2JzZXJ2ZWQ7XG4gICAgICBjb25zdCB1aWQgPSBnZXRFbGVtZW50VUlkKHRoaXMuX3dpbiwgZWxlbWVudCk7XG4gICAgICBsZXQgaW5mbyA9IHRoaXMuX29ic2VydmVkQnlJZFt1aWRdO1xuICAgICAgaWYgKG9ic2VydmVkICYmIGRvY3VtZW50Q29udGFpbnMoZWxlbWVudC5vd25lckRvY3VtZW50LCBlbGVtZW50KSkge1xuICAgICAgICBjb25zdCBpc05ld0VsZW1lbnQgPSAhaW5mbztcbiAgICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgICAgaW5mbyA9IHRoaXMuX29ic2VydmVkQnlJZFt1aWRdID0ge1xuICAgICAgICAgICAgZWxlbWVudDogbmV3IFdlYWtIVE1MRWxlbWVudCh0aGlzLl93aW4sIGVsZW1lbnQpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBvYnNlcnZlZC5uYW1lcy5zb3J0KCk7XG4gICAgICAgIGNvbnN0IG9ic2VydmVkTmFtZXMgPSBvYnNlcnZlZC5uYW1lcztcbiAgICAgICAgY29uc3QgcHJldk5hbWVzID0gaW5mby5wcmV2TmFtZXM7IC8vIHByZXZOYW1lcyBhcmUgYWxyZWFkeSBzb3J0ZWRcbiAgICAgICAgaWYgKHRoaXMuX2lzT2JzZXJ2ZWROYW1lc1VwZGF0ZWQob2JzZXJ2ZWROYW1lcywgcHJldk5hbWVzKSkge1xuICAgICAgICAgIGlmIChwcmV2TmFtZXMpIHtcbiAgICAgICAgICAgIHByZXZOYW1lcy5mb3JFYWNoKHByZXZOYW1lID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgb2JuID0gdGhpcy5fb2JzZXJ2ZWRCeU5hbWVbcHJldk5hbWVdO1xuICAgICAgICAgICAgICBpZiAob2JuICYmIG9iblt1aWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9ibikubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIG9iblt1aWRdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fb2JzZXJ2ZWRCeU5hbWVbcHJldk5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluZm8ucHJldk5hbWVzID0gb2JzZXJ2ZWROYW1lcztcbiAgICAgICAgICB0aGlzLl9ub3RpZnlPYnNlcnZlZEVsZW1lbnRDaGFuZ2UoZWxlbWVudCwgb2JzZXJ2ZWROYW1lcywgcHJldk5hbWVzLCBpc05ld0VsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIG9ic2VydmVkTmFtZXMuZm9yRWFjaChvYnNlcnZlZE5hbWUgPT4ge1xuICAgICAgICAgIGxldCBvYm4gPSB0aGlzLl9vYnNlcnZlZEJ5TmFtZVtvYnNlcnZlZE5hbWVdO1xuICAgICAgICAgIGlmICghb2JuKSB7XG4gICAgICAgICAgICBvYm4gPSB0aGlzLl9vYnNlcnZlZEJ5TmFtZVtvYnNlcnZlZE5hbWVdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgb2JuW3VpZF0gPSBpbmZvO1xuICAgICAgICAgIHRoaXMuX3dhaXRDb25kaXRpb25hbChvYnNlcnZlZE5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaW5mbykge1xuICAgICAgICBjb25zdCBwcmV2TmFtZXMgPSBpbmZvLnByZXZOYW1lcztcbiAgICAgICAgaWYgKHByZXZOYW1lcykge1xuICAgICAgICAgIHByZXZOYW1lcy5mb3JFYWNoKHByZXZOYW1lID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9ibiA9IHRoaXMuX29ic2VydmVkQnlOYW1lW3ByZXZOYW1lXTtcbiAgICAgICAgICAgIGlmIChvYm4gJiYgb2JuW3VpZF0pIHtcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9ibikubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYm5bdWlkXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fb2JzZXJ2ZWRCeU5hbWVbcHJldk5hbWVdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgKF9iID0gdGhpcy5vbk9ic2VydmVkRWxlbWVudENoYW5nZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcywge1xuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIHR5cGU6IFwicmVtb3ZlZFwiLFxuICAgICAgICAgICAgbmFtZXM6IFtdLFxuICAgICAgICAgICAgcmVtb3ZlZE5hbWVzOiBwcmV2TmFtZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fb2JzZXJ2ZWRCeUlkW3VpZF07XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl90YWJzdGVyID0gdGFic3RlcjtcbiAgICB0aGlzLl93aW4gPSB0YWJzdGVyLmdldFdpbmRvdztcbiAgICB0YWJzdGVyLnF1ZXVlSW5pdCgoKSA9PiB7XG4gICAgICB0aGlzLl90YWJzdGVyLmZvY3VzZWRFbGVtZW50LnN1YnNjcmliZSh0aGlzLl9vbkZvY3VzKTtcbiAgICB9KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQudW5zdWJzY3JpYmUodGhpcy5fb25Gb2N1cyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5fd2FpdGluZykpIHtcbiAgICAgIHRoaXMuX3JlamVjdFdhaXRpbmcoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5fb2JzZXJ2ZWRCeUlkID0ge307XG4gICAgdGhpcy5fb2JzZXJ2ZWRCeU5hbWUgPSB7fTtcbiAgICB0aGlzLm9uT2JzZXJ2ZWRFbGVtZW50Q2hhbmdlID0gdW5kZWZpbmVkO1xuICB9XG4gIF9yZWplY3RXYWl0aW5nKGtleSwgc2hvdWxkUmVzb2x2ZSkge1xuICAgIGNvbnN0IHcgPSB0aGlzLl93YWl0aW5nW2tleV07XG4gICAgaWYgKHcpIHtcbiAgICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgICAgaWYgKHcudGltZXIpIHtcbiAgICAgICAgd2luLmNsZWFyVGltZW91dCh3LnRpbWVyKTtcbiAgICAgIH1cbiAgICAgIGlmICh3LmNvbmRpdGlvblRpbWVyKSB7XG4gICAgICAgIHdpbi5jbGVhclRpbWVvdXQody5jb25kaXRpb25UaW1lcik7XG4gICAgICB9XG4gICAgICBpZiAoIXNob3VsZFJlc29sdmUgJiYgdy5yZWplY3QpIHtcbiAgICAgICAgdy5yZWplY3QoKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkUmVzb2x2ZSAmJiB3LnJlc29sdmUpIHtcbiAgICAgICAgdy5yZXNvbHZlKG51bGwpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuX3dhaXRpbmdba2V5XTtcbiAgICB9XG4gIH1cbiAgX3BvcHVsYXRlVGltZW91dERpYWdub3N0aWNzKHJlcXVlc3QsIG9ic2VydmVkTmFtZSwgdGltZW91dCwgc3RhcnRUaW1lKSB7XG4gICAgY29uc3QgZWxlbWVudEluRE9NID0gdGhpcy5nZXRFbGVtZW50KG9ic2VydmVkTmFtZSk7XG4gICAgY29uc3QgaW5ET00gPSAhIWVsZW1lbnRJbkRPTTtcbiAgICBsZXQgaXNBY2Nlc3NpYmxlO1xuICAgIGxldCBpc0ZvY3VzYWJsZTtcbiAgICBsZXQgcmVhc29uO1xuICAgIGlmICghZWxlbWVudEluRE9NKSB7XG4gICAgICByZWFzb24gPSBPYnNlcnZlZEVsZW1lbnRGYWlsdXJlUmVhc29ucy5UaW1lb3V0RWxlbWVudE5vdEluRE9NO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0FjY2Vzc2libGUgPSB0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5pc0FjY2Vzc2libGUoZWxlbWVudEluRE9NKTtcbiAgICAgIGlzRm9jdXNhYmxlID0gdGhpcy5fdGFic3Rlci5mb2N1c2FibGUuaXNGb2N1c2FibGUoZWxlbWVudEluRE9NLCB0cnVlKTtcbiAgICAgIGlmICghaXNBY2Nlc3NpYmxlKSB7XG4gICAgICAgIHJlYXNvbiA9IE9ic2VydmVkRWxlbWVudEZhaWx1cmVSZWFzb25zLlRpbWVvdXRFbGVtZW50Tm90QWNjZXNzaWJsZTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRm9jdXNhYmxlKSB7XG4gICAgICAgIHJlYXNvbiA9IE9ic2VydmVkRWxlbWVudEZhaWx1cmVSZWFzb25zLlRpbWVvdXRFbGVtZW50Tm90Rm9jdXNhYmxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVhc29uID0gT2JzZXJ2ZWRFbGVtZW50RmFpbHVyZVJlYXNvbnMuVGltZW91dEVsZW1lbnROb3RSZWFkeTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdC5kaWFnbm9zdGljcy5yZWFzb24gPSByZWFzb247XG4gICAgcmVxdWVzdC5kaWFnbm9zdGljcy53YWl0Rm9yRWxlbWVudER1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICByZXF1ZXN0LmRpYWdub3N0aWNzLnRhcmdldFN0YXRlID0ge1xuICAgICAgaW5ET00sXG4gICAgICBpc0FjY2Vzc2libGUsXG4gICAgICBpc0ZvY3VzYWJsZVxuICAgIH07XG4gIH1cbiAgX2lzT2JzZXJ2ZWROYW1lc1VwZGF0ZWQoY3VyLCBwcmV2KSB7XG4gICAgaWYgKCFwcmV2IHx8IGN1ci5sZW5ndGggIT09IHByZXYubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXIubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChjdXJbaV0gIT09IHByZXZbaV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBfbm90aWZ5T2JzZXJ2ZWRFbGVtZW50Q2hhbmdlKGVsZW1lbnQsIG9ic2VydmVkTmFtZXMsIHByZXZOYW1lcywgaXNOZXdFbGVtZW50KSB7XG4gICAgaWYgKCF0aGlzLm9uT2JzZXJ2ZWRFbGVtZW50Q2hhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFkZGVkTmFtZXMgPSBvYnNlcnZlZE5hbWVzLmZpbHRlcihuYW1lID0+ICFwcmV2TmFtZXMgfHwgIXByZXZOYW1lcy5pbmNsdWRlcyhuYW1lKSk7XG4gICAgY29uc3QgcmVtb3ZlZE5hbWVzID0gcHJldk5hbWVzID8gcHJldk5hbWVzLmZpbHRlcihuYW1lID0+ICFvYnNlcnZlZE5hbWVzLmluY2x1ZGVzKG5hbWUpKSA6IFtdO1xuICAgIGlmIChpc05ld0VsZW1lbnQpIHtcbiAgICAgIC8vIEJyYW5kIG5ldyBlbGVtZW50IGFkZGVkXG4gICAgICB0aGlzLm9uT2JzZXJ2ZWRFbGVtZW50Q2hhbmdlKHtcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgdHlwZTogXCJhZGRlZFwiLFxuICAgICAgICBuYW1lczogb2JzZXJ2ZWROYW1lcyxcbiAgICAgICAgYWRkZWROYW1lczogb2JzZXJ2ZWROYW1lc1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChhZGRlZE5hbWVzLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIEV4aXN0aW5nIGVsZW1lbnQgd2l0aCBuYW1lcyB1cGRhdGVkXG4gICAgICB0aGlzLm9uT2JzZXJ2ZWRFbGVtZW50Q2hhbmdlKHtcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgdHlwZTogXCJ1cGRhdGVkXCIsXG4gICAgICAgIG5hbWVzOiBvYnNlcnZlZE5hbWVzLFxuICAgICAgICBhZGRlZE5hbWVzOiBhZGRlZE5hbWVzLmxlbmd0aCA+IDAgPyBhZGRlZE5hbWVzIDogdW5kZWZpbmVkLFxuICAgICAgICByZW1vdmVkTmFtZXM6IHJlbW92ZWROYW1lcy5sZW5ndGggPiAwID8gcmVtb3ZlZE5hbWVzIDogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgb2JzZXJ2ZWQgbmFtZXMgd2l0aCB0aGVpciByZXNwZWN0aXZlIGVsZW1lbnRzIGFuZCBmdWxsIG5hbWVzIGFycmF5c1xuICAgKlxuICAgKiBAcmV0dXJucyBNYXA8c3RyaW5nLCBBcnJheTx7IGVsZW1lbnQ6IEhUTUxFbGVtZW50OyBuYW1lczogc3RyaW5nW10gfT4+IEEgbWFwIHdoZXJlIGtleXMgYXJlIG9ic2VydmVkIG5hbWVzXG4gICAqIGFuZCB2YWx1ZXMgYXJlIGFycmF5cyBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIGVsZW1lbnQgYW5kIGl0cyBjb21wbGV0ZSBuYW1lcyBhcnJheSAoaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSBkZWZpbmVkKVxuICAgKi9cbiAgZ2V0QWxsT2JzZXJ2ZWRFbGVtZW50cygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKHRoaXMuX29ic2VydmVkQnlOYW1lKSkge1xuICAgICAgY29uc3QgZWxlbWVudHNXaXRoTmFtZXMgPSBbXTtcbiAgICAgIGNvbnN0IG9ic2VydmVkID0gdGhpcy5fb2JzZXJ2ZWRCeU5hbWVbbmFtZV07XG4gICAgICBmb3IgKGNvbnN0IHVpZCBvZiBPYmplY3Qua2V5cyhvYnNlcnZlZCkpIHtcbiAgICAgICAgY29uc3QgZWwgPSBvYnNlcnZlZFt1aWRdLmVsZW1lbnQuZ2V0KCk7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLl9vYnNlcnZlZEJ5SWRbdWlkXTtcbiAgICAgICAgICBlbGVtZW50c1dpdGhOYW1lcy5wdXNoKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsLFxuICAgICAgICAgICAgbmFtZXM6IChpbmZvID09PSBudWxsIHx8IGluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZm8ucHJldk5hbWVzKSB8fCBbXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudHNXaXRoTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQuc2V0KG5hbWUsIGVsZW1lbnRzV2l0aE5hbWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBleGlzdGluZyBlbGVtZW50IGJ5IG9ic2VydmVkIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIG9ic2VydmVkTmFtZSBBbiBvYnNlcnZlZCBuYW1lXG4gICAqIEBwYXJhbSBhY2Nlc3NpYmlsaXR5IE9wdGlvbmFsbHksIHJldHVybiBvbmx5IGlmIHRoZSBlbGVtZW50IGlzIGFjY2Vzc2libGUgb3IgZm9jdXNhYmxlXG4gICAqIEByZXR1cm5zIEhUTUxFbGVtZW50IHwgbnVsbFxuICAgKi9cbiAgZ2V0RWxlbWVudChvYnNlcnZlZE5hbWUsIGFjY2Vzc2liaWxpdHkpIHtcbiAgICBjb25zdCBvID0gdGhpcy5fb2JzZXJ2ZWRCeU5hbWVbb2JzZXJ2ZWROYW1lXTtcbiAgICBpZiAobykge1xuICAgICAgZm9yIChjb25zdCB1aWQgb2YgT2JqZWN0LmtleXMobykpIHtcbiAgICAgICAgbGV0IGVsID0gb1t1aWRdLmVsZW1lbnQuZ2V0KCkgfHwgbnVsbDtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgaWYgKGFjY2Vzc2liaWxpdHkgPT09IE9ic2VydmVkRWxlbWVudEFjY2Vzc2liaWxpdGllcy5BY2Nlc3NpYmxlICYmICF0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5pc0FjY2Vzc2libGUoZWwpIHx8IGFjY2Vzc2liaWxpdHkgPT09IE9ic2VydmVkRWxlbWVudEFjY2Vzc2liaWxpdGllcy5Gb2N1c2FibGUgJiYgIXRoaXMuX3RhYnN0ZXIuZm9jdXNhYmxlLmlzRm9jdXNhYmxlKGVsLCB0cnVlKSkge1xuICAgICAgICAgICAgZWwgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgb1t1aWRdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9vYnNlcnZlZEJ5SWRbdWlkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgdGhlIGVsZW1lbnQgdG8gYXBwZWFyIGluIHRoZSBET00gYW5kIHJldHVybnMgaXQuXG4gICAqXG4gICAqIEBwYXJhbSBvYnNlcnZlZE5hbWUgQW4gb2JzZXJ2ZWQgbmFtZVxuICAgKiBAcGFyYW0gdGltZW91dCBXYWl0IG5vIGxvbmdlciB0aGFuIHRoaXMgdGltZW91dFxuICAgKiBAcGFyYW0gYWNjZXNzaWJpbGl0eSBPcHRpb25hbGx5LCB3YWl0IGZvciB0aGUgZWxlbWVudCB0byBhbHNvIGJlY29tZSBhY2Nlc3NpYmxlIG9yIGZvY3VzYWJsZSBiZWZvcmUgcmV0dXJuaW5nIGl0XG4gICAqIEByZXR1cm5zIFByb21pc2U8SFRNTEVsZW1lbnQgfCBudWxsPlxuICAgKi9cbiAgd2FpdEVsZW1lbnQob2JzZXJ2ZWROYW1lLCB0aW1lb3V0LCBhY2Nlc3NpYmlsaXR5KSB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBlbCA9IHRoaXMuZ2V0RWxlbWVudChvYnNlcnZlZE5hbWUsIGFjY2Vzc2liaWxpdHkpO1xuICAgIGlmIChlbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiBnZXRQcm9taXNlKHRoaXMuX3dpbikucmVzb2x2ZShlbCksXG4gICAgICAgIGNhbmNlbDogKCkgPT4ge1xuICAgICAgICAgIC8qKi9cbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzOiBPYnNlcnZlZEVsZW1lbnRSZXF1ZXN0U3RhdHVzZXMuU3VjY2VlZGVkLFxuICAgICAgICBkaWFnbm9zdGljczoge1xuICAgICAgICAgIHdhaXRGb3JFbGVtZW50RHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHByZWZpeDtcbiAgICBpZiAoYWNjZXNzaWJpbGl0eSA9PT0gT2JzZXJ2ZWRFbGVtZW50QWNjZXNzaWJpbGl0aWVzLkFjY2Vzc2libGUpIHtcbiAgICAgIHByZWZpeCA9IFwiYVwiO1xuICAgIH0gZWxzZSBpZiAoYWNjZXNzaWJpbGl0eSA9PT0gT2JzZXJ2ZWRFbGVtZW50QWNjZXNzaWJpbGl0aWVzLkZvY3VzYWJsZSkge1xuICAgICAgcHJlZml4ID0gXCJmXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeCA9IFwiX1wiO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBwcmVmaXggKyBvYnNlcnZlZE5hbWU7XG4gICAgbGV0IHcgPSB0aGlzLl93YWl0aW5nW2tleV07XG4gICAgaWYgKHcgJiYgdy5yZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gdy5yZXF1ZXN0O1xuICAgIH1cbiAgICB3ID0gdGhpcy5fd2FpdGluZ1trZXldID0ge1xuICAgICAgdGltZXI6IHRoaXMuX3dpbigpLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAody5jb25kaXRpb25UaW1lcikge1xuICAgICAgICAgIHRoaXMuX3dpbigpLmNsZWFyVGltZW91dCh3LmNvbmRpdGlvblRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fd2FpdGluZ1trZXldO1xuICAgICAgICBpZiAody5yZXF1ZXN0KSB7XG4gICAgICAgICAgdy5yZXF1ZXN0LnN0YXR1cyA9IE9ic2VydmVkRWxlbWVudFJlcXVlc3RTdGF0dXNlcy5UaW1lZE91dDtcbiAgICAgICAgICB0aGlzLl9wb3B1bGF0ZVRpbWVvdXREaWFnbm9zdGljcyh3LnJlcXVlc3QsIG9ic2VydmVkTmFtZSwgdGltZW91dCwgc3RhcnRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAody5yZXNvbHZlKSB7XG4gICAgICAgICAgdy5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9LCB0aW1lb3V0KVxuICAgIH07XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyAoZ2V0UHJvbWlzZSh0aGlzLl93aW4pKSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB3LnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgdy5yZWplY3QgPSByZWplY3Q7XG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgLy8gSWdub3JlIHRoZSBlcnJvciwgaXQgaXMgZXhwZWN0ZWQgdG8gYmUgcmVqZWN0ZWQgd2hlbiB0aGUgcmVxdWVzdCBpcyBjYW5jZWxlZC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICByZXN1bHQ6IHByb21pc2UsXG4gICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSBPYnNlcnZlZEVsZW1lbnRSZXF1ZXN0U3RhdHVzZXMuV2FpdGluZykge1xuICAgICAgICAgIC8vIGNhbmNlbCgpIGZ1bmN0aW9uIGlzIGNhbGxhYmxlIGJ5IHVzZXIsIHNvbWVvbmUgbWlnaHQgY2FsbCBpdCBhZnRlciByZXF1ZXN0IGlzIGZpbmlzaGVkLFxuICAgICAgICAgIC8vIHdlIGFyZSBtYWtpbmcgc3VyZSB0aGF0IHN0YXR1cyBvZiBhIGZpbmlzaGVkIHJlcXVlc3QgaXMgbm90IG92ZXJyaWRlbi5cbiAgICAgICAgICByZXF1ZXN0LnN0YXR1cyA9IE9ic2VydmVkRWxlbWVudFJlcXVlc3RTdGF0dXNlcy5DYW5jZWxlZDtcbiAgICAgICAgICByZXF1ZXN0LmRpYWdub3N0aWNzLndhaXRGb3JFbGVtZW50RHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlamVjdFdhaXRpbmcoa2V5LCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICBzdGF0dXM6IE9ic2VydmVkRWxlbWVudFJlcXVlc3RTdGF0dXNlcy5XYWl0aW5nLFxuICAgICAgZGlhZ25vc3RpY3M6IHt9XG4gICAgfTtcbiAgICB3LnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIGlmIChhY2Nlc3NpYmlsaXR5ICYmIHRoaXMuZ2V0RWxlbWVudChvYnNlcnZlZE5hbWUpKSB7XG4gICAgICAvLyBJZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudCBpcyBhbHJlYWQgaW4gRE9NLCBidXQgbm90IGFjY2Vzc2libGUgeWV0LFxuICAgICAgLy8gd2UgbmVlZCB0byBydW4gdGhlIHdhaXQgbG9naWMuXG4gICAgICB0aGlzLl93YWl0Q29uZGl0aW9uYWwob2JzZXJ2ZWROYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cbiAgcmVxdWVzdEZvY3VzKG9ic2VydmVkTmFtZSwgdGltZW91dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVxdWVzdElkID0gKyt0aGlzLl9sYXN0UmVxdWVzdEZvY3VzSWQ7XG4gICAgY29uc3QgY3VycmVudFJlcXVlc3RGb2N1cyA9IHRoaXMuX2N1cnJlbnRSZXF1ZXN0O1xuICAgIGlmIChjdXJyZW50UmVxdWVzdEZvY3VzKSB7XG4gICAgICBjdXJyZW50UmVxdWVzdEZvY3VzLmRpYWdub3N0aWNzLnJlYXNvbiA9IE9ic2VydmVkRWxlbWVudEZhaWx1cmVSZWFzb25zLlN1cGVyc2VkZWRCeU5ld1JlcXVlc3Q7XG4gICAgICBjdXJyZW50UmVxdWVzdEZvY3VzLmNhbmNlbCgpO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy53YWl0RWxlbWVudChvYnNlcnZlZE5hbWUsIHRpbWVvdXQsIE9ic2VydmVkRWxlbWVudEFjY2Vzc2liaWxpdGllcy5Gb2N1c2FibGUpO1xuICAgIHRoaXMuX2N1cnJlbnRSZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICB0aGlzLl9jdXJyZW50UmVxdWVzdFRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcmV0ID0ge1xuICAgICAgcmVzdWx0OiByZXF1ZXN0LnJlc3VsdC50aGVuKGVsZW1lbnQgPT4ge1xuICAgICAgICBpZiAodGhpcy5fbGFzdFJlcXVlc3RGb2N1c0lkICE9PSByZXF1ZXN0SWQpIHtcbiAgICAgICAgICByZXF1ZXN0LmRpYWdub3N0aWNzLnJlYXNvbiA9IE9ic2VydmVkRWxlbWVudEZhaWx1cmVSZWFzb25zLlN1cGVyc2VkZWRCeU5ld1JlcXVlc3Q7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgIC8vIEVsZW1lbnQgd2FzIG5vdCBmb3VuZCAtIHJlYXNvbiBzaG91bGQgYWxyZWFkeSBiZSBzZXQgYnkgdGltZW91dCBvciBjYW5jZWxsYXRpb25cbiAgICAgICAgICAvLyBJZiBub3Qgc2V0LCBkZWZhdWx0IHRvIHRpbWVvdXQgcmVhc29uXG4gICAgICAgICAgaWYgKHJlcXVlc3QuZGlhZ25vc3RpY3MucmVhc29uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuZGlhZ25vc3RpY3MucmVhc29uID0gT2JzZXJ2ZWRFbGVtZW50RmFpbHVyZVJlYXNvbnMuVGltZW91dEVsZW1lbnROb3RJbkRPTTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvY3VzUmVzdWx0ID0gdGhpcy5fdGFic3Rlci5mb2N1c2VkRWxlbWVudC5mb2N1cyhlbGVtZW50LCB0cnVlLCB1bmRlZmluZWQsIG9wdGlvbnMucHJldmVudFNjcm9sbCk7XG4gICAgICAgIGlmICghZm9jdXNSZXN1bHQpIHtcbiAgICAgICAgICAvLyBGb2N1cyBjYWxsIGZhaWxlZFxuICAgICAgICAgIHJlcXVlc3QuZGlhZ25vc3RpY3MucmVhc29uID0gT2JzZXJ2ZWRFbGVtZW50RmFpbHVyZVJlYXNvbnMuRm9jdXNDYWxsRmFpbGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb2N1c1Jlc3VsdDtcbiAgICAgIH0pLFxuICAgICAgY2FuY2VsOiAoKSA9PiB7XG4gICAgICAgIHJlcXVlc3QuY2FuY2VsKCk7XG4gICAgICB9LFxuICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgIGRpYWdub3N0aWNzOiByZXF1ZXN0LmRpYWdub3N0aWNzXG4gICAgfTtcbiAgICByZXF1ZXN0LnJlc3VsdC5maW5hbGx5KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50UmVxdWVzdCA9PT0gcmVxdWVzdCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fY3VycmVudFJlcXVlc3Q7XG4gICAgICB9XG4gICAgICByZXQuc3RhdHVzID0gcmVxdWVzdC5zdGF0dXM7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBfd2FpdENvbmRpdGlvbmFsKG9ic2VydmVkTmFtZSkge1xuICAgIGNvbnN0IHdhaXRpbmdFbGVtZW50S2V5ID0gXCJfXCIgKyBvYnNlcnZlZE5hbWU7XG4gICAgY29uc3Qgd2FpdGluZ0FjY2Vzc2libGVFbGVtZW50S2V5ID0gXCJhXCIgKyBvYnNlcnZlZE5hbWU7XG4gICAgY29uc3Qgd2FpdGluZ0ZvY3VzYWJsZUVsZW1lbnRLZXkgPSBcImZcIiArIG9ic2VydmVkTmFtZTtcbiAgICBjb25zdCB3YWl0aW5nRWxlbWVudCA9IHRoaXMuX3dhaXRpbmdbd2FpdGluZ0VsZW1lbnRLZXldO1xuICAgIGNvbnN0IHdhaXRpbmdBY2Nlc3NpYmxlRWxlbWVudCA9IHRoaXMuX3dhaXRpbmdbd2FpdGluZ0FjY2Vzc2libGVFbGVtZW50S2V5XTtcbiAgICBjb25zdCB3YWl0aW5nRm9jdXNhYmxlRWxlbWVudCA9IHRoaXMuX3dhaXRpbmdbd2FpdGluZ0ZvY3VzYWJsZUVsZW1lbnRLZXldO1xuICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgIGNvbnN0IHJlc29sdmUgPSAoZWxlbWVudCwga2V5LCB3YWl0aW5nLCBhY2Nlc3NpYmlsaXR5KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBvYnNlcnZlZCA9IChfYSA9IGdldFRhYnN0ZXJPbkVsZW1lbnQodGhpcy5fdGFic3RlciwgZWxlbWVudCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vYnNlcnZlZDtcbiAgICAgIGlmICghb2JzZXJ2ZWQgfHwgIW9ic2VydmVkLm5hbWVzLmluY2x1ZGVzKG9ic2VydmVkTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHdhaXRpbmcudGltZXIpIHtcbiAgICAgICAgd2luLmNsZWFyVGltZW91dCh3YWl0aW5nLnRpbWVyKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLl93YWl0aW5nW2tleV07XG4gICAgICBpZiAod2FpdGluZy5yZXF1ZXN0KSB7XG4gICAgICAgIHdhaXRpbmcucmVxdWVzdC5zdGF0dXMgPSBPYnNlcnZlZEVsZW1lbnRSZXF1ZXN0U3RhdHVzZXMuU3VjY2VlZGVkO1xuICAgICAgfVxuICAgICAgaWYgKHdhaXRpbmcucmVzb2x2ZSkge1xuICAgICAgICB3YWl0aW5nLnJlc29sdmUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIoZWxlbWVudCwge1xuICAgICAgICBuYW1lczogW29ic2VydmVkTmFtZV0sXG4gICAgICAgIGRldGFpbHM6IG9ic2VydmVkLmRldGFpbHMsXG4gICAgICAgIGFjY2Vzc2liaWxpdHlcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKHdhaXRpbmdFbGVtZW50KSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KG9ic2VydmVkTmFtZSk7XG4gICAgICBpZiAoZWxlbWVudCAmJiBkb2N1bWVudENvbnRhaW5zKGVsZW1lbnQub3duZXJEb2N1bWVudCwgZWxlbWVudCkpIHtcbiAgICAgICAgcmVzb2x2ZShlbGVtZW50LCB3YWl0aW5nRWxlbWVudEtleSwgd2FpdGluZ0VsZW1lbnQsIE9ic2VydmVkRWxlbWVudEFjY2Vzc2liaWxpdGllcy5BbnkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAod2FpdGluZ0FjY2Vzc2libGVFbGVtZW50ICYmICF3YWl0aW5nQWNjZXNzaWJsZUVsZW1lbnQuY29uZGl0aW9uVGltZXIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVBY2Nlc3NpYmxlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KG9ic2VydmVkTmFtZSk7XG4gICAgICAgIGlmIChlbGVtZW50ICYmIGRvY3VtZW50Q29udGFpbnMoZWxlbWVudC5vd25lckRvY3VtZW50LCBlbGVtZW50KSAmJiB0aGlzLl90YWJzdGVyLmZvY3VzYWJsZS5pc0FjY2Vzc2libGUoZWxlbWVudCkpIHtcbiAgICAgICAgICByZXNvbHZlKGVsZW1lbnQsIHdhaXRpbmdBY2Nlc3NpYmxlRWxlbWVudEtleSwgd2FpdGluZ0FjY2Vzc2libGVFbGVtZW50LCBPYnNlcnZlZEVsZW1lbnRBY2Nlc3NpYmlsaXRpZXMuQWNjZXNzaWJsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FpdGluZ0FjY2Vzc2libGVFbGVtZW50LmNvbmRpdGlvblRpbWVyID0gd2luLnNldFRpbWVvdXQocmVzb2x2ZUFjY2Vzc2libGUsIF9jb25kaXRpb25DaGVja1RpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVzb2x2ZUFjY2Vzc2libGUoKTtcbiAgICB9XG4gICAgaWYgKHdhaXRpbmdGb2N1c2FibGVFbGVtZW50ICYmICF3YWl0aW5nRm9jdXNhYmxlRWxlbWVudC5jb25kaXRpb25UaW1lcikge1xuICAgICAgY29uc3QgcmVzb2x2ZUZvY3VzYWJsZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudChvYnNlcnZlZE5hbWUpO1xuICAgICAgICBpZiAoZWxlbWVudCAmJiBkb2N1bWVudENvbnRhaW5zKGVsZW1lbnQub3duZXJEb2N1bWVudCwgZWxlbWVudCkgJiYgdGhpcy5fdGFic3Rlci5mb2N1c2FibGUuaXNGb2N1c2FibGUoZWxlbWVudCwgdHJ1ZSkpIHtcbiAgICAgICAgICByZXNvbHZlKGVsZW1lbnQsIHdhaXRpbmdGb2N1c2FibGVFbGVtZW50S2V5LCB3YWl0aW5nRm9jdXNhYmxlRWxlbWVudCwgT2JzZXJ2ZWRFbGVtZW50QWNjZXNzaWJpbGl0aWVzLkZvY3VzYWJsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FpdGluZ0ZvY3VzYWJsZUVsZW1lbnQuY29uZGl0aW9uVGltZXIgPSB3aW4uc2V0VGltZW91dChyZXNvbHZlRm9jdXNhYmxlLCBfY29uZGl0aW9uQ2hlY2tUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlc29sdmVGb2N1c2FibGUoKTtcbiAgICB9XG4gIH1cbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBhcmVhQ2xhc3M6IFwidGFic3Rlci1mb2N1cy1vdXRsaW5lLWFyZWFcIixcbiAgb3V0bGluZUNsYXNzOiBcInRhYnN0ZXItZm9jdXMtb3V0bGluZVwiLFxuICBvdXRsaW5lQ29sb3I6IFwiI2ZmNDUwMFwiLFxuICBvdXRsaW5lV2lkdGg6IDIsXG4gIHpJbmRleDogMjE0NzQ4MzY0N1xufTtcbmxldCBfcHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5jbGFzcyBPdXRsaW5lUG9zaXRpb24ge1xuICBjb25zdHJ1Y3RvcihsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcbiAgfVxuICBlcXVhbHNUbyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmxlZnQgPT09IG90aGVyLmxlZnQgJiYgdGhpcy50b3AgPT09IG90aGVyLnRvcCAmJiB0aGlzLnJpZ2h0ID09PSBvdGhlci5yaWdodCAmJiB0aGlzLmJvdHRvbSA9PT0gb3RoZXIuYm90dG9tO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgT3V0bGluZVBvc2l0aW9uKHRoaXMubGVmdCwgdGhpcy50b3AsIHRoaXMucmlnaHQsIHRoaXMuYm90dG9tKTtcbiAgfVxufVxuY2xhc3MgT3V0bGluZUFQSSB7XG4gIGNvbnN0cnVjdG9yKHRhYnN0ZXIpIHtcbiAgICB0aGlzLl9pc1Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLl9hbGxPdXRsaW5lRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl9pbml0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5fdGFic3Rlci5rZXlib2FyZE5hdmlnYXRpb24uc3Vic2NyaWJlKHRoaXMuX29uS2V5Ym9hcmROYXZpZ2F0aW9uU3RhdGVDaGFuZ2VkKTtcbiAgICAgIHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuc3Vic2NyaWJlKHRoaXMuX29uRm9jdXMpO1xuICAgICAgY29uc3Qgd2luID0gdGhpcy5fd2luKCk7XG4gICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLl9vblNjcm9sbCwgdHJ1ZSk7IC8vIENhcHR1cmUhXG4gICAgICBpZiAodGhpcy5fZnVsbFNjcmVlbkV2ZW50TmFtZSkge1xuICAgICAgICB3aW4uZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9mdWxsU2NyZWVuRXZlbnROYW1lLCB0aGlzLl9vbkZ1bGxTY3JlZW5DaGFuZ2VkKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX29uRnVsbFNjcmVlbkNoYW5nZWQgPSBlID0+IHtcbiAgICAgIGlmICghdGhpcy5fZnVsbFNjcmVlbkVsZW1lbnROYW1lIHx8ICFlLnRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldC5ib2R5IHx8IGUudGFyZ2V0O1xuICAgICAgY29uc3Qgb3V0bGluZUVsZW1lbnRzID0gdGhpcy5fZ2V0RE9NKHRhcmdldCk7XG4gICAgICBpZiAodGFyZ2V0Lm93bmVyRG9jdW1lbnQgJiYgb3V0bGluZUVsZW1lbnRzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IGZzRWxlbWVudCA9IHRhcmdldC5vd25lckRvY3VtZW50W3RoaXMuX2Z1bGxTY3JlZW5FbGVtZW50TmFtZV07XG4gICAgICAgIGlmIChmc0VsZW1lbnQpIHtcbiAgICAgICAgICBmc0VsZW1lbnQuYXBwZW5kQ2hpbGQob3V0bGluZUVsZW1lbnRzLmNvbnRhaW5lcik7XG4gICAgICAgICAgdGhpcy5fZnVsbFNjcmVlbkVsZW1lbnQgPSBmc0VsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0Lm93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRsaW5lRWxlbWVudHMuY29udGFpbmVyKTtcbiAgICAgICAgICB0aGlzLl9mdWxsU2NyZWVuRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25LZXlib2FyZE5hdmlnYXRpb25TdGF0ZUNoYW5nZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkZvY3VzKHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQuZ2V0Rm9jdXNlZEVsZW1lbnQoKSk7XG4gICAgfTtcbiAgICB0aGlzLl9vbkZvY3VzID0gZSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3VwZGF0ZUVsZW1lbnQoZSkgJiYgdGhpcy5faXNWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuX3NldFZpc2liaWxpdHkoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fb25TY3JvbGwgPSBlID0+IHtcbiAgICAgIGlmICghdGhpcy5fb3V0bGluZWRFbGVtZW50IHx8ICFPdXRsaW5lQVBJLl9pc1BhcmVudENoaWxkKGUudGFyZ2V0LCB0aGlzLl9vdXRsaW5lZEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2N1clBvcyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3NldE91dGxpbmVQb3NpdGlvbigpO1xuICAgIH07XG4gICAgdGhpcy5fdGFic3RlciA9IHRhYnN0ZXI7XG4gICAgdGhpcy5fd2luID0gdGFic3Rlci5nZXRXaW5kb3c7XG4gICAgdGFic3Rlci5xdWV1ZUluaXQodGhpcy5faW5pdCk7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKFwib25mdWxsc2NyZWVuY2hhbmdlXCIgaW4gZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5fZnVsbFNjcmVlbkV2ZW50TmFtZSA9IFwiZnVsbHNjcmVlbmNoYW5nZVwiO1xuICAgICAgICB0aGlzLl9mdWxsU2NyZWVuRWxlbWVudE5hbWUgPSBcImZ1bGxzY3JlZW5FbGVtZW50XCI7XG4gICAgICB9IGVsc2UgaWYgKFwib253ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIgaW4gZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5fZnVsbFNjcmVlbkV2ZW50TmFtZSA9IFwid2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiO1xuICAgICAgICB0aGlzLl9mdWxsU2NyZWVuRWxlbWVudE5hbWUgPSBcIndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50XCI7XG4gICAgICB9IGVsc2UgaWYgKFwib25tb3pmdWxsc2NyZWVuY2hhbmdlXCIgaW4gZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5fZnVsbFNjcmVlbkV2ZW50TmFtZSA9IFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiO1xuICAgICAgICB0aGlzLl9mdWxsU2NyZWVuRWxlbWVudE5hbWUgPSBcIm1vekZ1bGxTY3JlZW5FbGVtZW50XCI7XG4gICAgICB9IGVsc2UgaWYgKFwib25tc2Z1bGxzY3JlZW5jaGFuZ2VcIiBpbiBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLl9mdWxsU2NyZWVuRXZlbnROYW1lID0gXCJtc2Z1bGxzY3JlZW5jaGFuZ2VcIjtcbiAgICAgICAgdGhpcy5fZnVsbFNjcmVlbkVsZW1lbnROYW1lID0gXCJtc0Z1bGxzY3JlZW5FbGVtZW50XCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldHVwKHByb3BzKSB7XG4gICAgX3Byb3BzID0ge1xuICAgICAgLi4uX3Byb3BzLFxuICAgICAgLi4ucHJvcHNcbiAgICB9O1xuICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgIGlmICghd2luLl9fdGFic3Rlck91dGxpbmUpIHtcbiAgICAgIHdpbi5fX3RhYnN0ZXJPdXRsaW5lID0ge307XG4gICAgfVxuICAgIGlmICghd2luLl9fdGFic3Rlck91dGxpbmUuc3R5bGUpIHtcbiAgICAgIHdpbi5fX3RhYnN0ZXJPdXRsaW5lLnN0eWxlID0gYXBwZW5kU3R5bGVzKHdpbi5kb2N1bWVudCwgX3Byb3BzKTtcbiAgICB9XG4gICAgaWYgKCFwcm9wcyB8fCAhcHJvcHMuYXJlYUNsYXNzKSB7XG4gICAgICB3aW4uZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGRlZmF1bHRQcm9wcy5hcmVhQ2xhc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW4uZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKGRlZmF1bHRQcm9wcy5hcmVhQ2xhc3MpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IHdpbiA9IHRoaXMuX3dpbigpO1xuICAgIGlmICh0aGlzLl91cGRhdGVUaW1lcikge1xuICAgICAgd2luLmNsZWFyVGltZW91dCh0aGlzLl91cGRhdGVUaW1lcik7XG4gICAgICB0aGlzLl91cGRhdGVUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5fdGFic3Rlci5rZXlib2FyZE5hdmlnYXRpb24udW5zdWJzY3JpYmUodGhpcy5fb25LZXlib2FyZE5hdmlnYXRpb25TdGF0ZUNoYW5nZWQpO1xuICAgIHRoaXMuX3RhYnN0ZXIuZm9jdXNlZEVsZW1lbnQudW5zdWJzY3JpYmUodGhpcy5fb25Gb2N1cyk7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5fb25TY3JvbGwsIHRydWUpO1xuICAgIGlmICh0aGlzLl9mdWxsU2NyZWVuRXZlbnROYW1lKSB7XG4gICAgICB3aW4uZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9mdWxsU2NyZWVuRXZlbnROYW1lLCB0aGlzLl9vbkZ1bGxTY3JlZW5DaGFuZ2VkKTtcbiAgICB9XG4gICAgdGhpcy5fYWxsT3V0bGluZUVsZW1lbnRzLmZvckVhY2gob3V0bGluZUVsZW1lbnRzID0+IHRoaXMuX3JlbW92ZURPTShvdXRsaW5lRWxlbWVudHMuY29udGFpbmVyKSk7XG4gICAgdGhpcy5fYWxsT3V0bGluZUVsZW1lbnRzID0gW107XG4gICAgZGVsZXRlIHRoaXMuX291dGxpbmVkRWxlbWVudDtcbiAgICBkZWxldGUgdGhpcy5fY3VyUG9zO1xuICAgIGRlbGV0ZSB0aGlzLl9jdXJPdXRsaW5lRWxlbWVudHM7XG4gICAgZGVsZXRlIHRoaXMuX2Z1bGxTY3JlZW5FbGVtZW50O1xuICB9XG4gIF9zaG91bGRTaG93Q3VzdG9tT3V0bGluZShlbGVtZW50KSB7XG4gICAgY29uc3QgdGFic3Rlck9uRWxlbWVudCA9IGdldFRhYnN0ZXJPbkVsZW1lbnQodGhpcy5fdGFic3RlciwgZWxlbWVudCk7XG4gICAgaWYgKHRhYnN0ZXJPbkVsZW1lbnQgJiYgdGFic3Rlck9uRWxlbWVudC5vdXRsaW5lICYmIHRhYnN0ZXJPbkVsZW1lbnQub3V0bGluZS5pc0lnbm9yZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGVsZW1lbnQ7IGk7IGkgPSBpLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGlmIChpLmNsYXNzTGlzdCAmJiBpLmNsYXNzTGlzdC5jb250YWlucyhfcHJvcHMuYXJlYUNsYXNzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIF91cGRhdGVFbGVtZW50KGUpIHtcbiAgICB0aGlzLl9vdXRsaW5lZEVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuX3VwZGF0ZVRpbWVyKSB7XG4gICAgICB0aGlzLl93aW4oKS5jbGVhclRpbWVvdXQodGhpcy5fdXBkYXRlVGltZXIpO1xuICAgICAgdGhpcy5fdXBkYXRlVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuX2N1clBvcyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoIXRoaXMuX3RhYnN0ZXIua2V5Ym9hcmROYXZpZ2F0aW9uLmlzTmF2aWdhdGluZ1dpdGhLZXlib2FyZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChlKSB7XG4gICAgICAvLyBUT0RPOiBJdCdzIGhhcmQgKGFuZCBub3QgbmVjZXNzYXJ5KSB0byBjb21lIHVwIHdpdGggZXZlcnkgcG9zc2libGVcbiAgICAgIC8vIGNvbmRpdGlvbiB3aGVuIHRoZXJlIHNob3VsZCBiZSBubyBvdXRsaW5lLCBpdCdzIGJldHRlciB0byBhZGQgYW5cbiAgICAgIC8vIEFQSSB0byBjdXN0b21pemUgdGhlIGlnbm9yZXMuXG4gICAgICBpZiAoZS50YWdOYW1lID09PSBcIklOUFVUXCIpIHtcbiAgICAgICAgY29uc3QgaW5wdXRUeXBlID0gZS50eXBlO1xuICAgICAgICBjb25zdCBvdXRsaW5lZElucHV0VHlwZXMgPSB7XG4gICAgICAgICAgYnV0dG9uOiB0cnVlLFxuICAgICAgICAgIGNoZWNrYm94OiB0cnVlLFxuICAgICAgICAgIGZpbGU6IHRydWUsXG4gICAgICAgICAgaW1hZ2U6IHRydWUsXG4gICAgICAgICAgcmFkaW86IHRydWUsXG4gICAgICAgICAgcmFuZ2U6IHRydWUsXG4gICAgICAgICAgcmVzZXQ6IHRydWUsXG4gICAgICAgICAgc3VibWl0OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmICghKGlucHV0VHlwZSBpbiBvdXRsaW5lZElucHV0VHlwZXMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGUudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiIHx8IGUuY29udGVudEVkaXRhYmxlID09PSBcInRydWVcIiB8fCBlLnRhZ05hbWUgPT09IFwiSUZSQU1FXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9zaG91bGRTaG93Q3VzdG9tT3V0bGluZShlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fdGFic3Rlci5rZXlib2FyZE5hdmlnYXRpb24uaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkKCkpIHtcbiAgICAgICAgdGhpcy5fb3V0bGluZWRFbGVtZW50ID0gZTtcbiAgICAgICAgdGhpcy5fdXBkYXRlT3V0bGluZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBfdXBkYXRlT3V0bGluZSgpIHtcbiAgICB0aGlzLl9zZXRPdXRsaW5lUG9zaXRpb24oKTtcbiAgICBpZiAodGhpcy5fdXBkYXRlVGltZXIpIHtcbiAgICAgIHRoaXMuX3dpbigpLmNsZWFyVGltZW91dCh0aGlzLl91cGRhdGVUaW1lcik7XG4gICAgICB0aGlzLl91cGRhdGVUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9vdXRsaW5lZEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlVGltZXIgPSB0aGlzLl93aW4oKS5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fdXBkYXRlT3V0bGluZSgpO1xuICAgIH0sIDMwKTtcbiAgfVxuICBfc2V0VmlzaWJpbGl0eSh2aXNpYmxlKSB7XG4gICAgdGhpcy5faXNWaXNpYmxlID0gdmlzaWJsZTtcbiAgICBpZiAodGhpcy5fY3VyT3V0bGluZUVsZW1lbnRzKSB7XG4gICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICB0aGlzLl9jdXJPdXRsaW5lRWxlbWVudHMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoYCR7X3Byb3BzLm91dGxpbmVDbGFzc31fdmlzaWJsZWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY3VyT3V0bGluZUVsZW1lbnRzLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKGAke19wcm9wcy5vdXRsaW5lQ2xhc3N9X3Zpc2libGVgKTtcbiAgICAgICAgdGhpcy5fY3VyUG9zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2V0T3V0bGluZVBvc2l0aW9uKCkge1xuICAgIGlmICghdGhpcy5fb3V0bGluZWRFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBib3VuZGluZ1JlY3QgPSBnZXRCb3VuZGluZ1JlY3QodGhpcy5fd2luLCB0aGlzLl9vdXRsaW5lZEVsZW1lbnQpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gbmV3IE91dGxpbmVQb3NpdGlvbihib3VuZGluZ1JlY3QubGVmdCwgYm91bmRpbmdSZWN0LnRvcCwgYm91bmRpbmdSZWN0LnJpZ2h0LCBib3VuZGluZ1JlY3QuYm90dG9tKTtcbiAgICBpZiAodGhpcy5fY3VyUG9zICYmIHBvc2l0aW9uLmVxdWFsc1RvKHRoaXMuX2N1clBvcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZUVsZW1lbnRzID0gdGhpcy5fZ2V0RE9NKHRoaXMuX291dGxpbmVkRWxlbWVudCk7XG4gICAgY29uc3Qgd2luID0gdGhpcy5fb3V0bGluZWRFbGVtZW50Lm93bmVyRG9jdW1lbnQgJiYgdGhpcy5fb3V0bGluZWRFbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgaWYgKCFvdXRsaW5lRWxlbWVudHMgfHwgIXdpbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY3VyT3V0bGluZUVsZW1lbnRzICE9PSBvdXRsaW5lRWxlbWVudHMpIHtcbiAgICAgIHRoaXMuX3NldFZpc2liaWxpdHkoZmFsc2UpO1xuICAgICAgdGhpcy5fY3VyT3V0bGluZUVsZW1lbnRzID0gb3V0bGluZUVsZW1lbnRzO1xuICAgIH1cbiAgICB0aGlzLl9jdXJQb3MgPSBwb3NpdGlvbjtcbiAgICBjb25zdCBwID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICBsZXQgaGFzQWJzb2x1dGVQb3NpdGlvbmVkUGFyZW50ID0gZmFsc2U7XG4gICAgbGV0IGhhc0ZpeGVkUG9zaXRpb25lZFBhcmVudCA9IGZhbHNlO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG91dGxpbmVFbGVtZW50cy5jb250YWluZXI7XG4gICAgY29uc3Qgc2Nyb2xsaW5nRWxlbWVudCA9IGNvbnRhaW5lciAmJiBjb250YWluZXIub3duZXJEb2N1bWVudCAmJiBjb250YWluZXIub3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50O1xuICAgIGlmICghc2Nyb2xsaW5nRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBwYXJlbnQgPSB0aGlzLl9vdXRsaW5lZEVsZW1lbnQucGFyZW50RWxlbWVudDsgcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7IHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBtaWdodCBiZSBwYXJ0aWFsbHkgdmlzaWJsZSB3aXRoaW4gaXRzIHNjcm9sbGFibGUgcGFyZW50LFxuICAgICAgLy8gcmVkdWNlIHRoZSBib3VuZGluZyByZWN0IGlmIHRoaXMgaXMgdGhlIGNhc2UuXG4gICAgICBpZiAocGFyZW50ID09PSB0aGlzLl9mdWxsU2NyZWVuRWxlbWVudCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJvdW5kaW5nUmVjdCA9IGdldEJvdW5kaW5nUmVjdCh0aGlzLl93aW4sIHBhcmVudCk7XG4gICAgICBjb25zdCB3aW4gPSBwYXJlbnQub3duZXJEb2N1bWVudCAmJiBwYXJlbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgIGlmICghd2luKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW4uZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBjb21wdXRlZFN0eWxlLnBvc2l0aW9uO1xuICAgICAgaWYgKHBvc2l0aW9uID09PSBcImFic29sdXRlXCIpIHtcbiAgICAgICAgaGFzQWJzb2x1dGVQb3NpdGlvbmVkUGFyZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwiZml4ZWRcIiB8fCBwb3NpdGlvbiA9PT0gXCJzdGlja3lcIikge1xuICAgICAgICBoYXNGaXhlZFBvc2l0aW9uZWRQYXJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgPT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNBYnNvbHV0ZVBvc2l0aW9uZWRQYXJlbnQgJiYgIWhhc0ZpeGVkUG9zaXRpb25lZFBhcmVudCB8fCBjb21wdXRlZFN0eWxlLm92ZXJmbG93ID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgIGlmIChib3VuZGluZ1JlY3QubGVmdCA+IHAubGVmdCkge1xuICAgICAgICAgIHAubGVmdCA9IGJvdW5kaW5nUmVjdC5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChib3VuZGluZ1JlY3QudG9wID4gcC50b3ApIHtcbiAgICAgICAgICBwLnRvcCA9IGJvdW5kaW5nUmVjdC50b3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvdW5kaW5nUmVjdC5yaWdodCA8IHAucmlnaHQpIHtcbiAgICAgICAgICBwLnJpZ2h0ID0gYm91bmRpbmdSZWN0LnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChib3VuZGluZ1JlY3QuYm90dG9tIDwgcC5ib3R0b20pIHtcbiAgICAgICAgICBwLmJvdHRvbSA9IGJvdW5kaW5nUmVjdC5ib3R0b207XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYWxsUmVjdCA9IGdldEJvdW5kaW5nUmVjdCh0aGlzLl93aW4sIHNjcm9sbGluZ0VsZW1lbnQpO1xuICAgIGNvbnN0IGFsbFdpZHRoID0gYWxsUmVjdC5sZWZ0ICsgYWxsUmVjdC5yaWdodDtcbiAgICBjb25zdCBhbGxIZWlnaHQgPSBhbGxSZWN0LnRvcCArIGFsbFJlY3QuYm90dG9tO1xuICAgIGNvbnN0IG93ID0gX3Byb3BzLm91dGxpbmVXaWR0aDtcbiAgICBwLmxlZnQgPSBwLmxlZnQgPiBvdyA/IHAubGVmdCAtIG93IDogMDtcbiAgICBwLnRvcCA9IHAudG9wID4gb3cgPyBwLnRvcCAtIG93IDogMDtcbiAgICBwLnJpZ2h0ID0gcC5yaWdodCA8IGFsbFdpZHRoIC0gb3cgPyBwLnJpZ2h0ICsgb3cgOiBhbGxXaWR0aDtcbiAgICBwLmJvdHRvbSA9IHAuYm90dG9tIDwgYWxsSGVpZ2h0IC0gb3cgPyBwLmJvdHRvbSArIG93IDogYWxsSGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gcC5yaWdodCAtIHAubGVmdDtcbiAgICBjb25zdCBoZWlnaHQgPSBwLmJvdHRvbSAtIHAudG9wO1xuICAgIGlmICh3aWR0aCA+IG93ICogMiAmJiBoZWlnaHQgPiBvdyAqIDIpIHtcbiAgICAgIGNvbnN0IGxlZnRCb3JkZXJOb2RlID0gb3V0bGluZUVsZW1lbnRzLmxlZnQ7XG4gICAgICBjb25zdCB0b3BCb3JkZXJOb2RlID0gb3V0bGluZUVsZW1lbnRzLnRvcDtcbiAgICAgIGNvbnN0IHJpZ2h0Qm9yZGVyTm9kZSA9IG91dGxpbmVFbGVtZW50cy5yaWdodDtcbiAgICAgIGNvbnN0IGJvdHRvbUJvcmRlck5vZGUgPSBvdXRsaW5lRWxlbWVudHMuYm90dG9tO1xuICAgICAgY29uc3Qgc3ggPSB0aGlzLl9mdWxsU2NyZWVuRWxlbWVudCB8fCBoYXNGaXhlZFBvc2l0aW9uZWRQYXJlbnQgPyAwIDogd2luLnBhZ2VYT2Zmc2V0O1xuICAgICAgY29uc3Qgc3kgPSB0aGlzLl9mdWxsU2NyZWVuRWxlbWVudCB8fCBoYXNGaXhlZFBvc2l0aW9uZWRQYXJlbnQgPyAwIDogd2luLnBhZ2VZT2Zmc2V0O1xuICAgICAgY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gaGFzRml4ZWRQb3NpdGlvbmVkUGFyZW50ID8gXCJmaXhlZFwiIDogXCJhYnNvbHV0ZVwiO1xuICAgICAgY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmQgPSBfcHJvcHMub3V0bGluZUNvbG9yO1xuICAgICAgbGVmdEJvcmRlck5vZGUuc3R5bGUud2lkdGggPSByaWdodEJvcmRlck5vZGUuc3R5bGUud2lkdGggPSB0b3BCb3JkZXJOb2RlLnN0eWxlLmhlaWdodCA9IGJvdHRvbUJvcmRlck5vZGUuc3R5bGUuaGVpZ2h0ID0gX3Byb3BzLm91dGxpbmVXaWR0aCArIFwicHhcIjtcbiAgICAgIGxlZnRCb3JkZXJOb2RlLnN0eWxlLmxlZnQgPSB0b3BCb3JkZXJOb2RlLnN0eWxlLmxlZnQgPSBib3R0b21Cb3JkZXJOb2RlLnN0eWxlLmxlZnQgPSBwLmxlZnQgKyBzeCArIFwicHhcIjtcbiAgICAgIHJpZ2h0Qm9yZGVyTm9kZS5zdHlsZS5sZWZ0ID0gcC5sZWZ0ICsgc3ggKyB3aWR0aCAtIG93ICsgXCJweFwiO1xuICAgICAgbGVmdEJvcmRlck5vZGUuc3R5bGUudG9wID0gcmlnaHRCb3JkZXJOb2RlLnN0eWxlLnRvcCA9IHRvcEJvcmRlck5vZGUuc3R5bGUudG9wID0gcC50b3AgKyBzeSArIFwicHhcIjtcbiAgICAgIGJvdHRvbUJvcmRlck5vZGUuc3R5bGUudG9wID0gcC50b3AgKyBzeSArIGhlaWdodCAtIG93ICsgXCJweFwiO1xuICAgICAgbGVmdEJvcmRlck5vZGUuc3R5bGUuaGVpZ2h0ID0gcmlnaHRCb3JkZXJOb2RlLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICAgIHRvcEJvcmRlck5vZGUuc3R5bGUud2lkdGggPSBib3R0b21Cb3JkZXJOb2RlLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgICB0aGlzLl9zZXRWaXNpYmlsaXR5KHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRWaXNpYmlsaXR5KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgX2dldERPTShjb250ZXh0RWxlbWVudCkge1xuICAgIGNvbnN0IGRvYyA9IGNvbnRleHRFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgY29uc3Qgd2luID0gZG9jICYmIGRvYy5kZWZhdWx0VmlldztcbiAgICBpZiAoIWRvYyB8fCAhd2luIHx8ICF3aW4uX190YWJzdGVyT3V0bGluZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCF3aW4uX190YWJzdGVyT3V0bGluZS5zdHlsZSkge1xuICAgICAgd2luLl9fdGFic3Rlck91dGxpbmUuc3R5bGUgPSBhcHBlbmRTdHlsZXMoZG9jLCBfcHJvcHMpO1xuICAgIH1cbiAgICBpZiAoIXdpbi5fX3RhYnN0ZXJPdXRsaW5lLmVsZW1lbnRzKSB7XG4gICAgICBjb25zdCBvdXRsaW5lRWxlbWVudHMgPSB7XG4gICAgICAgIGNvbnRhaW5lcjogZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgIGxlZnQ6IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICB0b3A6IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICByaWdodDogZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgIGJvdHRvbTogZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIH07XG4gICAgICBvdXRsaW5lRWxlbWVudHMuY29udGFpbmVyLmNsYXNzTmFtZSA9IF9wcm9wcy5vdXRsaW5lQ2xhc3M7XG4gICAgICBvdXRsaW5lRWxlbWVudHMubGVmdC5jbGFzc05hbWUgPSBgJHtfcHJvcHMub3V0bGluZUNsYXNzfV9fbGVmdGA7XG4gICAgICBvdXRsaW5lRWxlbWVudHMudG9wLmNsYXNzTmFtZSA9IGAke19wcm9wcy5vdXRsaW5lQ2xhc3N9X190b3BgO1xuICAgICAgb3V0bGluZUVsZW1lbnRzLnJpZ2h0LmNsYXNzTmFtZSA9IGAke19wcm9wcy5vdXRsaW5lQ2xhc3N9X19yaWdodGA7XG4gICAgICBvdXRsaW5lRWxlbWVudHMuYm90dG9tLmNsYXNzTmFtZSA9IGAke19wcm9wcy5vdXRsaW5lQ2xhc3N9X19ib3R0b21gO1xuICAgICAgb3V0bGluZUVsZW1lbnRzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChvdXRsaW5lRWxlbWVudHMubGVmdCk7XG4gICAgICBvdXRsaW5lRWxlbWVudHMuY29udGFpbmVyLmFwcGVuZENoaWxkKG91dGxpbmVFbGVtZW50cy50b3ApO1xuICAgICAgb3V0bGluZUVsZW1lbnRzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChvdXRsaW5lRWxlbWVudHMucmlnaHQpO1xuICAgICAgb3V0bGluZUVsZW1lbnRzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChvdXRsaW5lRWxlbWVudHMuYm90dG9tKTtcbiAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKG91dGxpbmVFbGVtZW50cy5jb250YWluZXIpO1xuICAgICAgd2luLl9fdGFic3Rlck91dGxpbmUuZWxlbWVudHMgPSBvdXRsaW5lRWxlbWVudHM7XG4gICAgICAvLyBUT0RPOiBNYWtlIGEgZ2FyYmFnZSBjb2xsZWN0b3IgdG8gcmVtb3ZlIHRoZSByZWZlcmVuY2VzXG4gICAgICAvLyB0byB0aGUgb3V0bGluZXMgd2hpY2ggYXJlIG5vd2hlcmUgaW4gdGhlIERPTSBhbnltb3JlLlxuICAgICAgdGhpcy5fYWxsT3V0bGluZUVsZW1lbnRzLnB1c2gob3V0bGluZUVsZW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbi5fX3RhYnN0ZXJPdXRsaW5lLmVsZW1lbnRzO1xuICB9XG4gIF9yZW1vdmVET00oY29udGV4dEVsZW1lbnQpIHtcbiAgICBjb25zdCB3aW4gPSBjb250ZXh0RWxlbWVudC5vd25lckRvY3VtZW50ICYmIGNvbnRleHRFbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgY29uc3Qgb3V0bGluZSA9IHdpbiAmJiB3aW4uX190YWJzdGVyT3V0bGluZTtcbiAgICBpZiAoIW91dGxpbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG91dGxpbmUuc3R5bGUgJiYgb3V0bGluZS5zdHlsZS5wYXJlbnROb2RlKSB7XG4gICAgICBvdXRsaW5lLnN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob3V0bGluZS5zdHlsZSk7XG4gICAgICBkZWxldGUgb3V0bGluZS5zdHlsZTtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZUVsZW1lbnRzID0gb3V0bGluZSAmJiBvdXRsaW5lLmVsZW1lbnRzO1xuICAgIGlmIChvdXRsaW5lRWxlbWVudHMpIHtcbiAgICAgIGlmIChvdXRsaW5lRWxlbWVudHMuY29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgb3V0bGluZUVsZW1lbnRzLmNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG91dGxpbmVFbGVtZW50cy5jb250YWluZXIpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIG91dGxpbmUuZWxlbWVudHM7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfaXNQYXJlbnRDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkID09PSBwYXJlbnQgfHxcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxuICAgICEhKHBhcmVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihjaGlsZCkgJiBkb2N1bWVudC5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpO1xuICB9XG59XG5mdW5jdGlvbiBhcHBlbmRTdHlsZXMoZG9jdW1lbnQsIHByb3BzKSB7XG4gIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShnZXRPdXRsaW5lU3R5bGVzKHByb3BzKSkpO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gZ2V0T3V0bGluZVN0eWxlcyhwcm9wcykge1xuICByZXR1cm4gYFxuLiR7cHJvcHMuYXJlYUNsYXNzfSAqLCAuJHtwcm9wcy5hcmVhQ2xhc3N9ICo6Zm9jdXMge1xub3V0bGluZTogbm9uZSAhaW1wb3J0YW50O1xufVxuXG4uJHtwcm9wcy5vdXRsaW5lQ2xhc3N9IHtcbmRpc3BsYXk6IG5vbmU7XG5wb3NpdGlvbjogYWJzb2x1dGU7XG53aWR0aDogMDtcbmhlaWdodDogMDtcbmxlZnQ6IDA7XG50b3A6IDA7XG56LWluZGV4OiAke3Byb3BzLnpJbmRleH07XG59XG5cbi4ke3Byb3BzLm91dGxpbmVDbGFzc30uJHtwcm9wcy5vdXRsaW5lQ2xhc3N9X3Zpc2libGUge1xuZGlzcGxheTogYmxvY2s7XG59XG5cbi4ke3Byb3BzLm91dGxpbmVDbGFzc31fX2xlZnQsXG4uJHtwcm9wcy5vdXRsaW5lQ2xhc3N9X190b3AsXG4uJHtwcm9wcy5vdXRsaW5lQ2xhc3N9X19yaWdodCxcbi4ke3Byb3BzLm91dGxpbmVDbGFzc31fX2JvdHRvbSB7XG5wb3NpdGlvbjogYWJzb2x1dGU7XG5iYWNrZ3JvdW5kOiBpbmhlcml0O1xufWA7XG59XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQWxsb3dzIGRlZmF1bHQgb3IgdXNlciBmb2N1cyBiZWhhdmlvdXIgb24gdGhlIERPTSBzdWJ0cmVlXG4gKiBpLmUuIFRhYnN0ZXIgd2lsbCBub3QgY29udHJvbCBmb2N1cyBldmVudHMgd2l0aGluIGFuIHVuY29udHJvbGxlZCBhcmVhXG4gKi9cbmNsYXNzIFVuY29udHJvbGxlZEFQSSB7XG4gIGNvbnN0cnVjdG9yKGlzVW5jb250cm9sbGVkQ29tcGxldGVseSkge1xuICAgIHRoaXMuX2lzVW5jb250cm9sbGVkQ29tcGxldGVseSA9IGlzVW5jb250cm9sbGVkQ29tcGxldGVseTtcbiAgfVxuICBpc1VuY29udHJvbGxlZENvbXBsZXRlbHkoZWxlbWVudCwgY29tcGxldGVseSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBpc1VuY29udHJvbGxlZENvbXBsZXRlbHkgPSAoX2EgPSB0aGlzLl9pc1VuY29udHJvbGxlZENvbXBsZXRlbHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGVsZW1lbnQsIGNvbXBsZXRlbHkpO1xuICAgIC8vIElmIGlzVW5jb250cm9sbGVkQ29tcGxldGVseSBjYWxsYmFjayBpcyBub3QgZGVmaW5lZCBvciByZXR1cm5zIHVuZGVmaW5lZCwgdGhlbiB0aGUgZGVmYXVsdFxuICAgIC8vIGJlaGF2aW91ciBpcyB0byByZXR1cm4gdGhlIHVuY29udHJvbGxlZC5jb21wbGV0ZWx5IHZhbHVlIGZyb20gdGhlIGVsZW1lbnQuXG4gICAgcmV0dXJuIGlzVW5jb250cm9sbGVkQ29tcGxldGVseSA9PT0gdW5kZWZpbmVkID8gY29tcGxldGVseSA6IGlzVW5jb250cm9sbGVkQ29tcGxldGVseTtcbiAgfVxufVxuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5jbGFzcyBSZXN0b3JlciBleHRlbmRzIFRhYnN0ZXJQYXJ0IHtcbiAgY29uc3RydWN0b3IodGFic3RlciwgZWxlbWVudCwgcHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgc3VwZXIodGFic3RlciwgZWxlbWVudCwgcHJvcHMpO1xuICAgIHRoaXMuX2hhc0ZvY3VzID0gZmFsc2U7XG4gICAgdGhpcy5fb25Gb2N1c091dCA9IGUgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgZWxlbWVudCA9IChfYSA9IHRoaXMuX2VsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKTtcbiAgICAgIGlmIChlbGVtZW50ICYmIGUucmVsYXRlZFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IFJlc3RvcmVyUmVzdG9yZUZvY3VzRXZlbnQoKSk7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudCAmJiAhZG9tLm5vZGVDb250YWlucyhlbGVtZW50LCBlLnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgIHRoaXMuX2hhc0ZvY3VzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbkZvY3VzSW4gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9oYXNGb2N1cyA9IHRydWU7XG4gICAgfTtcbiAgICBpZiAodGhpcy5fcHJvcHMudHlwZSA9PT0gUmVzdG9yZXJUeXBlcy5Tb3VyY2UpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSAoX2EgPSB0aGlzLl9lbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCk7XG4gICAgICBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuX29uRm9jdXNPdXQpO1xuICAgICAgZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuX29uRm9jdXNJbik7XG4gICAgICAvLyBzZXQgaGFzRm9jdXMgd2hlbiB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCwgaW4gY2FzZSBmb2N1cyBoYXMgYWxyZWFkeSBtb3ZlZCB3aXRoaW4gaXRcbiAgICAgIHRoaXMuX2hhc0ZvY3VzID0gZG9tLm5vZGVDb250YWlucyhlbGVtZW50LCBlbGVtZW50ICYmIGRvbS5nZXRBY3RpdmVFbGVtZW50KGVsZW1lbnQub3duZXJEb2N1bWVudCkpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGhpcy5fcHJvcHMudHlwZSA9PT0gUmVzdG9yZXJUeXBlcy5Tb3VyY2UpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSAoX2EgPSB0aGlzLl9lbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCk7XG4gICAgICBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuX29uRm9jdXNPdXQpO1xuICAgICAgZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuX29uRm9jdXNJbik7XG4gICAgICBpZiAodGhpcy5faGFzRm9jdXMpIHtcbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy5fdGFic3Rlci5nZXRXaW5kb3coKS5kb2N1bWVudDtcbiAgICAgICAgZG9jLmJvZHkuZGlzcGF0Y2hFdmVudChuZXcgUmVzdG9yZXJSZXN0b3JlRm9jdXNFdmVudCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNsYXNzIEhpc3Rvcnkge1xuICBjb25zdHJ1Y3RvcihnZXRXaW5kb3cpIHtcbiAgICB0aGlzLl9zdGFjayA9IFtdO1xuICAgIHRoaXMuX2dldFdpbmRvdyA9IGdldFdpbmRvdztcbiAgfVxuICAvKipcbiAgICogUHVzaCBhIHdlYWsgZWxlbWVudCB0byB0aGUgdG9wIG9mIHRoZSBoaXN0b3J5IHN0YWNrLlxuICAgKiBJZiB0aGUgc3RhY2sgaXMgZnVsbCwgdGhlIGJvdHRvbSB3ZWFrIGVsZW1lbnQgaXMgcmVtb3ZlZC5cbiAgICogSWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFjaywgaXQgaXMgbm90IGR1cGxpY2F0ZWQuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gRG9uJ3QgZHVwbGljYXRlIHRoZSB0b3Agb2YgaGlzdG9yeVxuICAgIGlmICgoKF9hID0gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoIC0gMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKSkgPT09IGVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0YWNrLmxlbmd0aCA+IEhpc3RvcnkuREVQVEgpIHtcbiAgICAgIHRoaXMuX3N0YWNrLnNoaWZ0KCk7XG4gICAgfVxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IFdlYWtIVE1MRWxlbWVudCh0aGlzLl9nZXRXaW5kb3csIGVsZW1lbnQpKTtcbiAgfVxuICAvKipcbiAgICogUG9wIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhlIGhpc3RvcnkgdGhhdCBzYXRpc2ZpZXMgdGhlIGNhbGxiYWNrLlxuICAgKiBUaGUgaGlzdG9yeSBpcyBzZWFyY2hlZCBmcm9tIHRoZSB0b3AgdG8gdGhlIGJvdHRvbSAoZnJvbSB0aGUgbW9zdCByZWNlbnQgdG8gdGhlIGxlYXN0IHJlY2VudCkuXG4gICAqXG4gICAqIElmIGEgd2VhayByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgaXMgYnJva2VuLFxuICAgKiBvciB0aGUgZWxlbWVudCBpcyBubyBsb25nZXIgaW4gdGhlIERPTSxcbiAgICogdGhlIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrIHdoaWxlIHBvcHBpbmcuXG4gICAqXG4gICAqIElmIG5vIG1hdGNoaW5nIGVsZW1lbnQgaXMgZm91bmQsIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAgICogSWYgdGhlIHN0YWNrIGlzIGVtcHR5LCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBwb3AoZmlsdGVyID0gKCkgPT4gdHJ1ZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBkb2MgPSB0aGlzLl9nZXRXaW5kb3coKS5kb2N1bWVudDtcbiAgICBmb3IgKGxldCBpbmRleCA9IHRoaXMuX3N0YWNrLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgIGNvbnN0IG1heWJlRWxlbWVudCA9IChfYSA9IHRoaXMuX3N0YWNrLnBvcCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCk7XG4gICAgICBpZiAobWF5YmVFbGVtZW50ICYmIGRvbS5ub2RlQ29udGFpbnMoZG9jLmJvZHksIGRvbS5nZXRQYXJlbnRFbGVtZW50KG1heWJlRWxlbWVudCkpICYmIGZpbHRlcihtYXliZUVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBtYXliZUVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cbkhpc3RvcnkuREVQVEggPSAxMDtcbmNsYXNzIFJlc3RvcmVyQVBJIHtcbiAgY29uc3RydWN0b3IodGFic3Rlcikge1xuICAgIHRoaXMuX29uUmVzdG9yZUZvY3VzID0gZSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgdGhpcy5fZm9jdXNlZEVsZW1lbnRTdGF0ZS5jYW5jZWxBc3luY0ZvY3VzKEFzeW5jRm9jdXNTb3VyY2VzLlJlc3RvcmVyKTtcbiAgICAgIC8vIFNoYWRvd0RPTSB3aWxsIGhhdmUgc2hhZG93Um9vdCBhcyBlLnRhcmdldC5cbiAgICAgIGNvbnN0IHNvdXJjZSA9IGUuY29tcG9zZWRQYXRoKClbMF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIC8vIHNvdXJjZSBpZCBtdXN0IGJlIHJlY292ZXJlZCBiZWZvcmUgc291cmNlIGlzIHJlbW92ZWQgZnJvbSBET01cbiAgICAgICAgLy8gb3RoZXJ3aXNlIGl0J2xsIGJlIHVucmVhY2hhYmxlXG4gICAgICAgIC8vIChhcyB0YWJzdGVyIG9uIGVsZW1lbnQgd2lsbCBub3QgYmUgYXZhaWxhYmxlIHRocm91Z2ggZ2V0VGFic3Rlck9uRWxlbWVudClcbiAgICAgICAgY29uc3Qgc291cmNlSWQgPSAoX2IgPSAoX2EgPSBnZXRUYWJzdGVyT25FbGVtZW50KHRoaXMuX3RhYnN0ZXIsIHNvdXJjZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXN0b3JlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldFByb3BzKCkuaWQ7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWRFbGVtZW50U3RhdGUucmVxdWVzdEFzeW5jRm9jdXMoQXN5bmNGb2N1c1NvdXJjZXMuUmVzdG9yZXIsICgpID0+IHRoaXMuX3Jlc3RvcmVGb2N1cyhzb3VyY2UsIHNvdXJjZUlkKSwgMCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9vbkZvY3VzSW4gPSBlbGVtZW50ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0YWJzdGVyQXR0cmlidXRlID0gZ2V0VGFic3Rlck9uRWxlbWVudCh0aGlzLl90YWJzdGVyLCBlbGVtZW50KTtcbiAgICAgIGlmICgoKF9hID0gdGFic3RlckF0dHJpYnV0ZSA9PT0gbnVsbCB8fCB0YWJzdGVyQXR0cmlidXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWJzdGVyQXR0cmlidXRlLnJlc3RvcmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UHJvcHMoKS50eXBlKSAhPT0gUmVzdG9yZXJUeXBlcy5UYXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5faGlzdG9yeS5wdXNoKGVsZW1lbnQpO1xuICAgIH07XG4gICAgdGhpcy5fcmVzdG9yZUZvY3VzID0gKHNvdXJjZSwgc291cmNlSWQpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIC8vIGRvbid0IHJlc3RvcmUgZm9jdXMgaWYgZm9jdXMgaXNuJ3QgbG9zdCB0byBib2R5XG4gICAgICBjb25zdCBkb2MgPSB0aGlzLl9nZXRXaW5kb3coKS5kb2N1bWVudDtcbiAgICAgIGlmIChkb20uZ2V0QWN0aXZlRWxlbWVudChkb2MpICE9PSBkb2MuYm9keSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAvLyBjbGlja2luZyBvbiBhbnkgZW1wdHkgc3BhY2UgZm9jdXNlcyBib2R5IC0gdGhpcyBpcyBjYW4gYmUgYSBmYWxzZSBwb3NpdGl2ZVxuICAgICAgIXRoaXMuX2tleWJvYXJkTmF2U3RhdGUuaXNOYXZpZ2F0aW5nV2l0aEtleWJvYXJkKCkgJiZcbiAgICAgIC8vIFNvdXJjZSBubyBsb25nZXIgZXhpc3RzIG9uIERPTSAtIGFsd2F5cyByZXN0b3JlIGZvY3VzXG4gICAgICBkb20ubm9kZUNvbnRhaW5zKGRvYy5ib2R5LCBzb3VyY2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdldElkID0gZWxlbWVudCA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHJlc3RvcmVyUHJvcHMgPSAoX2IgPSAoX2EgPSBnZXRUYWJzdGVyT25FbGVtZW50KHRoaXMuX3RhYnN0ZXIsIGVsZW1lbnQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzdG9yZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRQcm9wcygpO1xuICAgICAgICAvLyBXZSByZXR1cm4gaWQgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIGFjdHVhbCByZXN0b3JlciBvbiB0aGUgZWxlbWVudCxcbiAgICAgICAgLy8gYW5kIG51bGwgb3RoZXJ3aXNlLiBUbyBmaWx0ZXIgb3V0IGVsZW1lbnRzIHRoYXQgaGFkIHJlc3RvcmVycyBpbiB0aGVpciBsaWZldGltZVxuICAgICAgICAvLyBidXQgZG9uJ3QgaGF2ZSB0aGVtIGFueW1vcmUuXG4gICAgICAgIHJldHVybiByZXN0b3JlclByb3BzID8gcmVzdG9yZXJQcm9wcy5pZCA6IG51bGw7XG4gICAgICB9O1xuICAgICAgLy8gc291cmNlSWQgaXMgdW5kZWZpbmVkIG9yIHN0cmluZywgaWYgdGhlcmUgaXMgbm8gUmVzdG9yZXIgb24gdGhlIHRhcmdldCwgdGhlIGVsZW1lbnQgd2lsbFxuICAgICAgLy8gYmUgZmlsdGVyZWQgb3V0IGJlY2F1c2UgZ2V0SWQoKSB3aWxsIHJldHVybiBudWxsLlxuICAgICAgKF9hID0gdGhpcy5faGlzdG9yeS5wb3AodGFyZ2V0ID0+IHNvdXJjZUlkID09PSBnZXRJZCh0YXJnZXQpKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gICAgfTtcbiAgICB0aGlzLl90YWJzdGVyID0gdGFic3RlcjtcbiAgICB0aGlzLl9nZXRXaW5kb3cgPSB0YWJzdGVyLmdldFdpbmRvdztcbiAgICB0aGlzLl9nZXRXaW5kb3coKS5hZGRFdmVudExpc3RlbmVyKFJlc3RvcmVyUmVzdG9yZUZvY3VzRXZlbnROYW1lLCB0aGlzLl9vblJlc3RvcmVGb2N1cyk7XG4gICAgdGhpcy5faGlzdG9yeSA9IG5ldyBIaXN0b3J5KHRoaXMuX2dldFdpbmRvdyk7XG4gICAgdGhpcy5fa2V5Ym9hcmROYXZTdGF0ZSA9IHRhYnN0ZXIua2V5Ym9hcmROYXZpZ2F0aW9uO1xuICAgIHRoaXMuX2ZvY3VzZWRFbGVtZW50U3RhdGUgPSB0YWJzdGVyLmZvY3VzZWRFbGVtZW50O1xuICAgIHRoaXMuX2ZvY3VzZWRFbGVtZW50U3RhdGUuc3Vic2NyaWJlKHRoaXMuX29uRm9jdXNJbik7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjb25zdCB3aW4gPSB0aGlzLl9nZXRXaW5kb3coKTtcbiAgICB0aGlzLl9mb2N1c2VkRWxlbWVudFN0YXRlLnVuc3Vic2NyaWJlKHRoaXMuX29uRm9jdXNJbik7XG4gICAgdGhpcy5fZm9jdXNlZEVsZW1lbnRTdGF0ZS5jYW5jZWxBc3luY0ZvY3VzKEFzeW5jRm9jdXNTb3VyY2VzLlJlc3RvcmVyKTtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihSZXN0b3JlclJlc3RvcmVGb2N1c0V2ZW50TmFtZSwgdGhpcy5fb25SZXN0b3JlRm9jdXMpO1xuICB9XG4gIGNyZWF0ZVJlc3RvcmVyKGVsZW1lbnQsIHByb3BzKSB7XG4gICAgY29uc3QgcmVzdG9yZXIgPSBuZXcgUmVzdG9yZXIodGhpcy5fdGFic3RlciwgZWxlbWVudCwgcHJvcHMpO1xuICAgIC8vIEZvY3VzIG1pZ2h0IGFscmVhZHkgYmUgb24gYSByZXN0b3JlciB0YXJnZXQgd2hlbiBpdCBnZXRzIGNyZWF0ZWQgc28gdGhlIGZvY3VzaW4gd2lsbCBub3QgZG8gYW55dGhpbmdcbiAgICBpZiAocHJvcHMudHlwZSA9PT0gUmVzdG9yZXJUeXBlcy5UYXJnZXQgJiYgZG9tLmdldEFjdGl2ZUVsZW1lbnQoZWxlbWVudC5vd25lckRvY3VtZW50KSA9PT0gZWxlbWVudCkge1xuICAgICAgdGhpcy5faGlzdG9yeS5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdG9yZXI7XG4gIH1cbn1cblxuLyohXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIHtcbiAgdmFyIF9hO1xuICBsZXQgYWN0aXZlRWxlbWVudCA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICB3aGlsZSAoKF9hID0gYWN0aXZlRWxlbWVudCA9PT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVFbGVtZW50KSB7XG4gICAgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICB9XG4gIHJldHVybiBhY3RpdmVFbGVtZW50O1xufVxuZnVuY3Rpb24gbm9kZUNvbnRhaW5zKG5vZGUsIG90aGVyTm9kZSkge1xuICB2YXIgX2EsIF9iO1xuICBpZiAoIW5vZGUgfHwgIW90aGVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgY3VycmVudE5vZGUgPSBvdGhlck5vZGU7XG4gIHdoaWxlIChjdXJyZW50Tm9kZSkge1xuICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gbm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3VycmVudE5vZGUuYXNzaWduZWRFbGVtZW50cyAhPT0gXCJmdW5jdGlvblwiICYmICgoX2EgPSBjdXJyZW50Tm9kZS5hc3NpZ25lZFNsb3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnROb2RlKSkge1xuICAgICAgLy8gRWxlbWVudCBpcyBzbG90dGVkXG4gICAgICBjdXJyZW50Tm9kZSA9IChfYiA9IGN1cnJlbnROb2RlLmFzc2lnbmVkU2xvdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gZG9jdW1lbnQuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgLy8gRWxlbWVudCBpcyBpbiBzaGFkb3cgcm9vdFxuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmIG5vZGUuaG9zdCkge1xuICAgIHJldHVybiBub2RlLmhvc3Q7XG4gIH1cbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudEVsZW1lbnQoZWxlbWVudCkge1xuICBmb3IgKGxldCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTsgcGFyZW50Tm9kZTsgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiBwYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0Q2hpbGQobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAobm9kZS5zaGFkb3dSb290KSB7XG4gICAgY29uc3QgY2hpbGQgPSBnZXRGaXJzdENoaWxkKG5vZGUuc2hhZG93Um9vdCk7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIC8vIElmIHRoZSBhdHRhY2hlZCBzaGFkb3dSb290IGhhcyBubyBjaGlsZHJlbiwganVzdCB0cnkgb3JkaW5hcnkgY2hpbGRyZW4sXG4gICAgLy8gdGhhdCBtaWdodCBjb21lIGFmdGVyLlxuICB9XG4gIHJldHVybiBub2RlLmZpcnN0Q2hpbGQ7XG59XG5mdW5jdGlvbiBnZXRMYXN0Q2hpbGQkMShub2RlKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghbm9kZS5sYXN0Q2hpbGQgJiYgbm9kZS5zaGFkb3dSb290KSB7XG4gICAgcmV0dXJuIGdldExhc3RDaGlsZCQxKG5vZGUuc2hhZG93Um9vdCk7XG4gIH1cbiAgcmV0dXJuIG5vZGUubGFzdENoaWxkO1xufVxuZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcobm9kZSkge1xuICByZXR1cm4gKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5uZXh0U2libGluZykgfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFByZXZpb3VzU2libGluZyhub2RlKSB7XG4gIHZhciBfYTtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IHNpYmxpbmcgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgaWYgKCFzaWJsaW5nICYmICgoX2EgPSBub2RlLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaGFkb3dSb290KSkge1xuICAgIHNpYmxpbmcgPSBnZXRMYXN0Q2hpbGQkMShub2RlLnBhcmVudEVsZW1lbnQuc2hhZG93Um9vdCk7XG4gIH1cbiAgcmV0dXJuIHNpYmxpbmc7XG59XG5mdW5jdGlvbiBnZXRGaXJzdEVsZW1lbnRDaGlsZChlbGVtZW50KSB7XG4gIGxldCBjaGlsZCA9IGdldEZpcnN0Q2hpbGQoZWxlbWVudCk7XG4gIHdoaWxlIChjaGlsZCAmJiBjaGlsZC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICBjaGlsZCA9IGdldE5leHRTaWJsaW5nKGNoaWxkKTtcbiAgfVxuICByZXR1cm4gY2hpbGQ7XG59XG5mdW5jdGlvbiBnZXRMYXN0RWxlbWVudENoaWxkKGVsZW1lbnQpIHtcbiAgbGV0IGNoaWxkID0gZ2V0TGFzdENoaWxkJDEoZWxlbWVudCk7XG4gIHdoaWxlIChjaGlsZCAmJiBjaGlsZC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICBjaGlsZCA9IGdldFByZXZpb3VzU2libGluZyhjaGlsZCk7XG4gIH1cbiAgcmV0dXJuIGNoaWxkO1xufVxuZnVuY3Rpb24gZ2V0TmV4dEVsZW1lbnRTaWJsaW5nKGVsZW1lbnQpIHtcbiAgbGV0IHNpYmxpbmcgPSBnZXROZXh0U2libGluZyhlbGVtZW50KTtcbiAgd2hpbGUgKHNpYmxpbmcgJiYgc2libGluZy5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICBzaWJsaW5nID0gZ2V0TmV4dFNpYmxpbmcoc2libGluZyk7XG4gIH1cbiAgcmV0dXJuIHNpYmxpbmc7XG59XG5mdW5jdGlvbiBnZXRQcmV2aW91c0VsZW1lbnRTaWJsaW5nKGVsZW1lbnQpIHtcbiAgbGV0IHNpYmxpbmcgPSBnZXRQcmV2aW91c1NpYmxpbmcoZWxlbWVudCk7XG4gIHdoaWxlIChzaWJsaW5nICYmIHNpYmxpbmcubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgc2libGluZyA9IGdldFByZXZpb3VzU2libGluZyhzaWJsaW5nKTtcbiAgfVxuICByZXR1cm4gc2libGluZztcbn1cbmZ1bmN0aW9uIGFwcGVuZENoaWxkKHBhcmVudCwgY2hpbGQpIHtcbiAgY29uc3Qgc2hhZG93Um9vdCA9IHBhcmVudC5zaGFkb3dSb290O1xuICByZXR1cm4gc2hhZG93Um9vdCA/IHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoY2hpbGQpIDogcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnQsIGNoaWxkLCByZWZlcmVuY2VDaGlsZCkge1xuICBjb25zdCBzaGFkb3dSb290ID0gcGFyZW50LnNoYWRvd1Jvb3Q7XG4gIHJldHVybiBzaGFkb3dSb290ID8gc2hhZG93Um9vdC5pbnNlcnRCZWZvcmUoY2hpbGQsIHJlZmVyZW5jZUNoaWxkKSA6IHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHJlZmVyZW5jZUNoaWxkKTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihyZWYpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB3aW4gPSAoX2EgPSByZWYub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlZmF1bHRWaWV3O1xuICBpZiAoIXdpbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZvciAobGV0IGVsID0gcmVmOyBlbDsgZWwgPSBlbC5wYXJlbnROb2RlKSB7XG4gICAgaWYgKGVsLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgIGNvbnN0IHRtcCA9IGVsO1xuICAgICAgLy8gU2hhZG93Um9vdC5nZXRTZWxlY3Rpb24oKSBleGlzdHMgb25seSBpbiBDaHJvbWUuXG4gICAgICBpZiAodG1wLmdldFNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gdG1wLmdldFNlbGVjdGlvbigpIHx8IG51bGw7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHdpbi5nZXRTZWxlY3Rpb24oKSB8fCBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudHNCeU5hbWUocmVmZXJlbmNlRWxlbWVudCwgbmFtZSkge1xuICBmb3IgKGxldCBlbCA9IHJlZmVyZW5jZUVsZW1lbnQ7IGVsOyBlbCA9IGVsLnBhcmVudE5vZGUpIHtcbiAgICBpZiAoZWwubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgLy8gU2hhZG93IHJvb3QgZG9lc24ndCBoYXZlIGdldEVsZW1lbnRzQnlOYW1lKCkuLi5cbiAgICAgIHJldHVybiBlbC5xdWVyeVNlbGVjdG9yQWxsKGBbbmFtZT0ke25hbWV9XWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVmZXJlbmNlRWxlbWVudC5vd25lckRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKG5hbWUpO1xufVxuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBnZXRMYXN0Q2hpbGQoY29udGFpbmVyKSB7XG4gIGxldCBsYXN0Q2hpbGQgPSBudWxsO1xuICBmb3IgKGxldCBpID0gZ2V0TGFzdEVsZW1lbnRDaGlsZChjb250YWluZXIpOyBpOyBpID0gZ2V0TGFzdEVsZW1lbnRDaGlsZChpKSkge1xuICAgIGxhc3RDaGlsZCA9IGk7XG4gIH1cbiAgcmV0dXJuIGxhc3RDaGlsZCB8fCB1bmRlZmluZWQ7XG59XG5jbGFzcyBTaGFkb3dUcmVlV2Fsa2VyIHtcbiAgY29uc3RydWN0b3IoZG9jLCByb290LCB3aGF0VG9TaG93LCBmaWx0ZXIpIHtcbiAgICB0aGlzLl93YWxrZXJTdGFjayA9IFtdO1xuICAgIHRoaXMuX2N1cnJlbnRTZXRGb3IgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fYWNjZXB0Tm9kZSA9IG5vZGUgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBub2RlLnNoYWRvd1Jvb3Q7XG4gICAgICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICAgICAgY29uc3Qgd2Fsa2VyID0gdGhpcy5fZG9jLmNyZWF0ZVRyZWVXYWxrZXIoc2hhZG93Um9vdCwgdGhpcy53aGF0VG9TaG93LCB7XG4gICAgICAgICAgICBhY2NlcHROb2RlOiB0aGlzLl9hY2NlcHROb2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fd2Fsa2VyU3RhY2sudW5zaGlmdCh3YWxrZXIpO1xuICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmZpbHRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICgoX2EgPSB0aGlzLmZpbHRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2VwdE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlci5hY2NlcHROb2RlKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5maWx0ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICB9O1xuICAgIHRoaXMuX2RvYyA9IGRvYztcbiAgICB0aGlzLnJvb3QgPSByb290O1xuICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyICE9PSBudWxsICYmIGZpbHRlciAhPT0gdm9pZCAwID8gZmlsdGVyIDogbnVsbDtcbiAgICB0aGlzLndoYXRUb1Nob3cgPSB3aGF0VG9TaG93ICE9PSBudWxsICYmIHdoYXRUb1Nob3cgIT09IHZvaWQgMCA/IHdoYXRUb1Nob3cgOiBOb2RlRmlsdGVyLlNIT1dfQUxMO1xuICAgIHRoaXMuX2N1cnJlbnROb2RlID0gcm9vdDtcbiAgICB0aGlzLl93YWxrZXJTdGFjay51bnNoaWZ0KGRvYy5jcmVhdGVUcmVlV2Fsa2VyKHJvb3QsIHdoYXRUb1Nob3csIHRoaXMuX2FjY2VwdE5vZGUpKTtcbiAgICBjb25zdCBzaGFkb3dSb290ID0gcm9vdC5zaGFkb3dSb290O1xuICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICBjb25zdCB3YWxrZXIgPSB0aGlzLl9kb2MuY3JlYXRlVHJlZVdhbGtlcihzaGFkb3dSb290LCB0aGlzLndoYXRUb1Nob3csIHtcbiAgICAgICAgYWNjZXB0Tm9kZTogdGhpcy5fYWNjZXB0Tm9kZVxuICAgICAgfSk7XG4gICAgICB0aGlzLl93YWxrZXJTdGFjay51bnNoaWZ0KHdhbGtlcik7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50Tm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudE5vZGU7XG4gIH1cbiAgc2V0IGN1cnJlbnROb2RlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGVDb250YWlucyh0aGlzLnJvb3QsIG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IGN1cnJlbnROb2RlIHRvIGEgbm9kZSB0aGF0IGlzIG5vdCBjb250YWluZWQgYnkgdGhlIHJvb3Qgbm9kZS5cIik7XG4gICAgfVxuICAgIGNvbnN0IHdhbGtlcnMgPSBbXTtcbiAgICBsZXQgY3VyTm9kZSA9IG5vZGU7XG4gICAgbGV0IGN1cnJlbnRXYWxrZXJDdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgdGhpcy5fY3VycmVudE5vZGUgPSBub2RlO1xuICAgIHdoaWxlIChjdXJOb2RlICYmIGN1ck5vZGUgIT09IHRoaXMucm9vdCkge1xuICAgICAgaWYgKGN1ck5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgICBjb25zdCBzaGFkb3dSb290ID0gY3VyTm9kZTtcbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gdGhpcy5fZG9jLmNyZWF0ZVRyZWVXYWxrZXIoc2hhZG93Um9vdCwgdGhpcy53aGF0VG9TaG93LCB7XG4gICAgICAgICAgYWNjZXB0Tm9kZTogdGhpcy5fYWNjZXB0Tm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgd2Fsa2Vycy5wdXNoKHdhbGtlcik7XG4gICAgICAgIHdhbGtlci5jdXJyZW50Tm9kZSA9IGN1cnJlbnRXYWxrZXJDdXJyZW50Tm9kZTtcbiAgICAgICAgdGhpcy5fY3VycmVudFNldEZvci5hZGQod2Fsa2VyKTtcbiAgICAgICAgY3VyTm9kZSA9IGN1cnJlbnRXYWxrZXJDdXJyZW50Tm9kZSA9IHNoYWRvd1Jvb3QuaG9zdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1ck5vZGUgPSBjdXJOb2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHdhbGtlciA9IHRoaXMuX2RvYy5jcmVhdGVUcmVlV2Fsa2VyKHRoaXMucm9vdCwgdGhpcy53aGF0VG9TaG93LCB7XG4gICAgICBhY2NlcHROb2RlOiB0aGlzLl9hY2NlcHROb2RlXG4gICAgfSk7XG4gICAgd2Fsa2Vycy5wdXNoKHdhbGtlcik7XG4gICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gY3VycmVudFdhbGtlckN1cnJlbnROb2RlO1xuICAgIHRoaXMuX2N1cnJlbnRTZXRGb3IuYWRkKHdhbGtlcik7XG4gICAgdGhpcy5fd2Fsa2VyU3RhY2sgPSB3YWxrZXJzO1xuICB9XG4gIGZpcnN0Q2hpbGQoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGFzdENoaWxkKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIG5leHROb2RlKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBuZXh0Tm9kZSA9IHRoaXMuX3dhbGtlclN0YWNrWzBdLm5leHROb2RlKCk7XG4gICAgaWYgKG5leHROb2RlKSB7XG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gbmV4dE5vZGUuc2hhZG93Um9vdDtcbiAgICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICAgIGxldCBub2RlUmVzdWx0O1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZmlsdGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBub2RlUmVzdWx0ID0gdGhpcy5maWx0ZXIobmV4dE5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKChfYSA9IHRoaXMuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXB0Tm9kZSkge1xuICAgICAgICAgIG5vZGVSZXN1bHQgPSB0aGlzLmZpbHRlci5hY2NlcHROb2RlKG5leHROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZVJlc3VsdCA9PT0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHROb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIF9hY2NlcHROb2RlIHNob3VsZCBoYXZlIGFkZGVkIG5ldyB3YWxrZXIgZm9yIHRoaXMgc2hhZG93LFxuICAgICAgICAvLyBnbyBpbiByZWN1cnNpdmVseS5cbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dE5vZGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX3dhbGtlclN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5fd2Fsa2VyU3RhY2suc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dE5vZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwcmV2aW91c05vZGUoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBjdXJyZW50V2Fsa2VyID0gdGhpcy5fd2Fsa2VyU3RhY2tbMF07XG4gICAgaWYgKGN1cnJlbnRXYWxrZXIuY3VycmVudE5vZGUgPT09IGN1cnJlbnRXYWxrZXIucm9vdCkge1xuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRTZXRGb3IuaGFzKGN1cnJlbnRXYWxrZXIpKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRTZXRGb3IuZGVsZXRlKGN1cnJlbnRXYWxrZXIpO1xuICAgICAgICBpZiAodGhpcy5fd2Fsa2VyU3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMuX3dhbGtlclN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXNOb2RlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IGdldExhc3RDaGlsZChjdXJyZW50V2Fsa2VyLnJvb3QpO1xuICAgICAgaWYgKGxhc3RDaGlsZCkge1xuICAgICAgICBjdXJyZW50V2Fsa2VyLmN1cnJlbnROb2RlID0gbGFzdENoaWxkO1xuICAgICAgICBsZXQgbm9kZVJlc3VsdDtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmZpbHRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgbm9kZVJlc3VsdCA9IHRoaXMuZmlsdGVyKGxhc3RDaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKF9hID0gdGhpcy5maWx0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2NlcHROb2RlKSB7XG4gICAgICAgICAgbm9kZVJlc3VsdCA9IHRoaXMuZmlsdGVyLmFjY2VwdE5vZGUobGFzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZVJlc3VsdCA9PT0gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUKSB7XG4gICAgICAgICAgcmV0dXJuIGxhc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c05vZGUgPSBjdXJyZW50V2Fsa2VyLnByZXZpb3VzTm9kZSgpO1xuICAgIGlmIChwcmV2aW91c05vZGUpIHtcbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBwcmV2aW91c05vZGUuc2hhZG93Um9vdDtcbiAgICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICAgIGxldCBub2RlUmVzdWx0O1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZmlsdGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBub2RlUmVzdWx0ID0gdGhpcy5maWx0ZXIocHJldmlvdXNOb2RlKTtcbiAgICAgICAgfSBlbHNlIGlmICgoX2IgPSB0aGlzLmZpbHRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFjY2VwdE5vZGUpIHtcbiAgICAgICAgICBub2RlUmVzdWx0ID0gdGhpcy5maWx0ZXIuYWNjZXB0Tm9kZShwcmV2aW91c05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlUmVzdWx0ID09PSBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQpIHtcbiAgICAgICAgICByZXR1cm4gcHJldmlvdXNOb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIF9hY2NlcHROb2RlIHNob3VsZCBoYXZlIGFkZGVkIG5ldyB3YWxrZXIgZm9yIHRoaXMgc2hhZG93LFxuICAgICAgICAvLyBnbyBpbiByZWN1cnNpdmVseS5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXNOb2RlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJldmlvdXNOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fd2Fsa2VyU3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLl93YWxrZXJTdGFjay5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91c05vZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBuZXh0U2libGluZygpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBwcmV2aW91c1NpYmxpbmcoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcGFyZW50Tm9kZSgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlU2hhZG93VHJlZVdhbGtlcihkb2MsIHJvb3QsIHdoYXRUb1Nob3csIGZpbHRlcikge1xuICByZXR1cm4gbmV3IFNoYWRvd1RyZWVXYWxrZXIoZG9jLCByb290LCB3aGF0VG9TaG93LCBmaWx0ZXIpO1xufVxuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5jbGFzcyBTaGFkb3dNdXRhdGlvbk9ic2VydmVyIHtcbiAgc3RhdGljIF9vdmVycmlkZUF0dGFjaFNoYWRvdyh3aW4pIHtcbiAgICBjb25zdCBvcmlnQXR0YWNoU2hhZG93ID0gd2luLkVsZW1lbnQucHJvdG90eXBlLmF0dGFjaFNoYWRvdztcbiAgICBpZiAob3JpZ0F0dGFjaFNoYWRvdy5fX29yaWdBdHRhY2hTaGFkb3cpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoU2hhZG93ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBvcmlnQXR0YWNoU2hhZG93LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICBmb3IgKGNvbnN0IHNoYWRvd09ic2VydmVyIG9mIFNoYWRvd011dGF0aW9uT2JzZXJ2ZXIuX3NoYWRvd09ic2VydmVycykge1xuICAgICAgICBzaGFkb3dPYnNlcnZlci5fYWRkU3ViT2JzZXJ2ZXIoc2hhZG93Um9vdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hhZG93Um9vdDtcbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmF0dGFjaFNoYWRvdy5fX29yaWdBdHRhY2hTaGFkb3cgPSBvcmlnQXR0YWNoU2hhZG93O1xuICB9XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5faXNPYnNlcnZpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9jYWxsYmFja1dyYXBwZXIgPSAobXV0YXRpb25zLCBvYnNlcnZlcikgPT4ge1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICBjb25zdCByZW1vdmVkID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzO1xuICAgICAgICAgIGNvbnN0IGFkZGVkID0gbXV0YXRpb24uYWRkZWROb2RlcztcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3dhbGtTaGFkb3dzKHJlbW92ZWRbaV0sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl93YWxrU2hhZG93cyhhZGRlZFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWxsYmFjayhtdXRhdGlvbnMsIG9ic2VydmVyKTtcbiAgICB9O1xuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9jYWxsYmFja1dyYXBwZXIpO1xuICAgIHRoaXMuX3N1Yk9ic2VydmVycyA9IG5ldyBNYXAoKTtcbiAgfVxuICBfYWRkU3ViT2JzZXJ2ZXIoc2hhZG93Um9vdCkge1xuICAgIGlmICghdGhpcy5fb3B0aW9ucyB8fCAhdGhpcy5fY2FsbGJhY2sgfHwgdGhpcy5fc3ViT2JzZXJ2ZXJzLmhhcyhzaGFkb3dSb290KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zdWJ0cmVlICYmIG5vZGVDb250YWlucyh0aGlzLl9yb290LCBzaGFkb3dSb290KSkge1xuICAgICAgY29uc3Qgc3ViT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9jYWxsYmFja1dyYXBwZXIpO1xuICAgICAgdGhpcy5fc3ViT2JzZXJ2ZXJzLnNldChzaGFkb3dSb290LCBzdWJPYnNlcnZlcik7XG4gICAgICBpZiAodGhpcy5faXNPYnNlcnZpbmcpIHtcbiAgICAgICAgc3ViT2JzZXJ2ZXIub2JzZXJ2ZShzaGFkb3dSb290LCB0aGlzLl9vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3dhbGtTaGFkb3dzKHNoYWRvd1Jvb3QpO1xuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuX2lzT2JzZXJ2aW5nID0gZmFsc2U7XG4gICAgZGVsZXRlIHRoaXMuX29wdGlvbnM7XG4gICAgU2hhZG93TXV0YXRpb25PYnNlcnZlci5fc2hhZG93T2JzZXJ2ZXJzLmRlbGV0ZSh0aGlzKTtcbiAgICBmb3IgKGNvbnN0IHN1Yk9ic2VydmVyIG9mIHRoaXMuX3N1Yk9ic2VydmVycy52YWx1ZXMoKSkge1xuICAgICAgc3ViT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICB0aGlzLl9zdWJPYnNlcnZlcnMuY2xlYXIoKTtcbiAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgb2JzZXJ2ZSh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkb2MgPSB0YXJnZXQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSA/IHRhcmdldCA6IHRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIGNvbnN0IHdpbiA9IGRvYyA9PT0gbnVsbCB8fCBkb2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvYy5kZWZhdWx0VmlldztcbiAgICBpZiAoIWRvYyB8fCAhd2luKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFNoYWRvd011dGF0aW9uT2JzZXJ2ZXIuX292ZXJyaWRlQXR0YWNoU2hhZG93KHdpbik7XG4gICAgU2hhZG93TXV0YXRpb25PYnNlcnZlci5fc2hhZG93T2JzZXJ2ZXJzLmFkZCh0aGlzKTtcbiAgICB0aGlzLl9yb290ID0gdGFyZ2V0O1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2lzT2JzZXJ2aW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRhcmdldCwgb3B0aW9ucyk7XG4gICAgdGhpcy5fd2Fsa1NoYWRvd3ModGFyZ2V0KTtcbiAgfVxuICBfd2Fsa1NoYWRvd3ModGFyZ2V0LCByZW1vdmUpIHtcbiAgICBjb25zdCBkb2MgPSB0YXJnZXQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSA/IHRhcmdldCA6IHRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIGlmICghZG9jKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0YXJnZXQgPT09IGRvYykge1xuICAgICAgdGFyZ2V0ID0gZG9jLmJvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSB0YXJnZXQuc2hhZG93Um9vdDtcbiAgICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICAgIHRoaXMuX2FkZFN1Yk9ic2VydmVyKHNoYWRvd1Jvb3QpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHdhbGtlciA9IGRvYy5jcmVhdGVUcmVlV2Fsa2VyKHRhcmdldCwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIHtcbiAgICAgIGFjY2VwdE5vZGU6IG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJPYnNlcnZlciA9IHRoaXMuX3N1Yk9ic2VydmVycy5nZXQobm9kZSk7XG4gICAgICAgICAgICBpZiAoc3ViT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgc3ViT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICB0aGlzLl9zdWJPYnNlcnZlcnMuZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzaGFkb3dSb290ID0gbm9kZS5zaGFkb3dSb290O1xuICAgICAgICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWRkU3ViT2JzZXJ2ZXIoc2hhZG93Um9vdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHdhbGtlci5uZXh0Tm9kZSgpO1xuICB9XG4gIHRha2VSZWNvcmRzKCkge1xuICAgIGNvbnN0IHJlY29yZHMgPSB0aGlzLl9vYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgIGZvciAoY29uc3Qgc3ViT2JzZXJ2ZXIgb2YgdGhpcy5fc3ViT2JzZXJ2ZXJzLnZhbHVlcygpKSB7XG4gICAgICByZWNvcmRzLnB1c2goLi4uc3ViT2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gICAgfVxuICAgIHJldHVybiByZWNvcmRzO1xuICB9XG59XG5TaGFkb3dNdXRhdGlvbk9ic2VydmVyLl9zaGFkb3dPYnNlcnZlcnMgPSAvKiNfX1BVUkVfXyovbmV3IFNldCgpO1xuZnVuY3Rpb24gY3JlYXRlU2hhZG93TXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaykge1xuICByZXR1cm4gbmV3IFNoYWRvd011dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spO1xufVxuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBzaGFkb3dRdWVyeVNlbGVjdG9yKG5vZGUsIHNlbGVjdG9yLCBhbGwpIHtcbiAgLy8gVE9ETzogVGhpcyBpcyBwcm9iYWJseSBzbG93LiBPcHRpbWl6ZSB0byB1c2UgZWFjaCBzaGFkb3dSb290J3MgcXVlcnlTZWxlY3Rvci9xdWVyeVNlbGVjdG9yQWxsXG4gIC8vICAgICAgIGluc3RlYWQgb2Ygd2Fsa2luZyB0aGUgdHJlZS5cbiAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgd2Fsayhub2RlLCBzZWxlY3Rvcik7XG4gIHJldHVybiBlbGVtZW50cztcbiAgZnVuY3Rpb24gd2Fsayhmcm9tLCBzZWxlY3Rvcikge1xuICAgIGxldCBlbCA9IG51bGw7XG4gICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihmcm9tLCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwge1xuICAgICAgYWNjZXB0Tm9kZTogbiA9PiB7XG4gICAgICAgIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIGlmIChuLm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBlbCA9IG47XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgICAgICAgIHJldHVybiBhbGwgPyBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQIDogTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzaGFkb3dSb290ID0gbi5zaGFkb3dSb290O1xuICAgICAgICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICAgICAgICB3YWxrKHNoYWRvd1Jvb3QsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgIHJldHVybiAhYWxsICYmIGVsZW1lbnRzLmxlbmd0aCA/IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCA6IE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHdhbGtlci5uZXh0Tm9kZSgpO1xuICB9XG59XG5mdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsKG5vZGUsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBzaGFkb3dRdWVyeVNlbGVjdG9yKG5vZGUsIHNlbGVjdG9yLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3Iobm9kZSwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNoYWRvd1F1ZXJ5U2VsZWN0b3Iobm9kZSwgc2VsZWN0b3IsIGZhbHNlKVswXSB8fCBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudEJ5SWQoZG9jLCBpZCkge1xuICByZXR1cm4gcXVlcnlTZWxlY3Rvcihkb2MsIFwiI1wiICsgaWQpO1xufVxuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vLyBUT0RPOiBUaGUgZnVuY3Rpb25zIGJlbG93IGRvIG5vdCBjb25zaWRlciBTaGFkb3cgRE9NIHNsb3RzIHlldC4gV2Ugd2lsbCBiZSBhZGRpbmdcbi8vIHN1cHBvcnQgZm9yIHNsb3RzIGFzIHRoZSBuZWVkIGFyaXNlcy5cblxudmFyIHNoYWRvd0RPTUFQSSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICAgIGNyZWF0ZU11dGF0aW9uT2JzZXJ2ZXI6IGNyZWF0ZVNoYWRvd011dGF0aW9uT2JzZXJ2ZXIsXG4gICAgY3JlYXRlVHJlZVdhbGtlcjogY3JlYXRlU2hhZG93VHJlZVdhbGtlcixcbiAgICBnZXRBY3RpdmVFbGVtZW50OiBnZXRBY3RpdmVFbGVtZW50LFxuICAgIGdldEVsZW1lbnRCeUlkOiBnZXRFbGVtZW50QnlJZCxcbiAgICBnZXRFbGVtZW50c0J5TmFtZTogZ2V0RWxlbWVudHNCeU5hbWUsXG4gICAgZ2V0Rmlyc3RDaGlsZDogZ2V0Rmlyc3RDaGlsZCxcbiAgICBnZXRGaXJzdEVsZW1lbnRDaGlsZDogZ2V0Rmlyc3RFbGVtZW50Q2hpbGQsXG4gICAgZ2V0TGFzdENoaWxkOiBnZXRMYXN0Q2hpbGQkMSxcbiAgICBnZXRMYXN0RWxlbWVudENoaWxkOiBnZXRMYXN0RWxlbWVudENoaWxkLFxuICAgIGdldE5leHRFbGVtZW50U2libGluZzogZ2V0TmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgIGdldE5leHRTaWJsaW5nOiBnZXROZXh0U2libGluZyxcbiAgICBnZXRQYXJlbnRFbGVtZW50OiBnZXRQYXJlbnRFbGVtZW50LFxuICAgIGdldFBhcmVudE5vZGU6IGdldFBhcmVudE5vZGUsXG4gICAgZ2V0UHJldmlvdXNFbGVtZW50U2libGluZzogZ2V0UHJldmlvdXNFbGVtZW50U2libGluZyxcbiAgICBnZXRQcmV2aW91c1NpYmxpbmc6IGdldFByZXZpb3VzU2libGluZyxcbiAgICBnZXRTZWxlY3Rpb246IGdldFNlbGVjdGlvbixcbiAgICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgICBub2RlQ29udGFpbnM6IG5vZGVDb250YWlucyxcbiAgICBxdWVyeVNlbGVjdG9yOiBxdWVyeVNlbGVjdG9yLFxuICAgIHF1ZXJ5U2VsZWN0b3JBbGw6IHF1ZXJ5U2VsZWN0b3JBbGxcbn0pO1xuXG4vKiFcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5jbGFzcyBUYWJzdGVyIHtcbiAgY29uc3RydWN0b3IodGFic3Rlcikge1xuICAgIHRoaXMua2V5Ym9hcmROYXZpZ2F0aW9uID0gdGFic3Rlci5rZXlib2FyZE5hdmlnYXRpb247XG4gICAgdGhpcy5mb2N1c2VkRWxlbWVudCA9IHRhYnN0ZXIuZm9jdXNlZEVsZW1lbnQ7XG4gICAgdGhpcy5mb2N1c2FibGUgPSB0YWJzdGVyLmZvY3VzYWJsZTtcbiAgICB0aGlzLnJvb3QgPSB0YWJzdGVyLnJvb3Q7XG4gICAgdGhpcy51bmNvbnRyb2xsZWQgPSB0YWJzdGVyLnVuY29udHJvbGxlZDtcbiAgICB0aGlzLmNvcmUgPSB0YWJzdGVyO1xuICB9XG59XG4vKipcbiAqIEV4dGVuZHMgV2luZG93IHRvIGluY2x1ZGUgYW4gaW50ZXJuYWwgVGFic3RlciBpbnN0YW5jZS5cbiAqL1xuY2xhc3MgVGFic3RlckNvcmUge1xuICBjb25zdHJ1Y3Rvcih3aW4sIHByb3BzKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB0aGlzLl9mb3JnZXRNZW1vcml6ZWRFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuX3dyYXBwZXJzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2luaXRRdWV1ZSA9IFtdO1xuICAgIHRoaXMuX3ZlcnNpb24gPSBcIjguNy4wXCI7XG4gICAgdGhpcy5fbm9vcCA9IGZhbHNlO1xuICAgIHRoaXMuZ2V0V2luZG93ID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl93aW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXNpbmcgZGlzcG9zZWQgVGFic3Rlci5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fd2luO1xuICAgIH07XG4gICAgdGhpcy5fc3RvcmFnZSA9IGNyZWF0ZVdlYWtNYXAod2luKTtcbiAgICB0aGlzLl93aW4gPSB3aW47XG4gICAgY29uc3QgZ2V0V2luZG93ID0gdGhpcy5nZXRXaW5kb3c7XG4gICAgaWYgKHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wcy5ET01BUEkpIHtcbiAgICAgIHNldERPTUFQSSh7XG4gICAgICAgIC4uLnByb3BzLkRPTUFQSVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMua2V5Ym9hcmROYXZpZ2F0aW9uID0gbmV3IEtleWJvYXJkTmF2aWdhdGlvblN0YXRlKGdldFdpbmRvdyk7XG4gICAgdGhpcy5mb2N1c2VkRWxlbWVudCA9IG5ldyBGb2N1c2VkRWxlbWVudFN0YXRlKHRoaXMsIGdldFdpbmRvdyk7XG4gICAgdGhpcy5mb2N1c2FibGUgPSBuZXcgRm9jdXNhYmxlQVBJKHRoaXMpO1xuICAgIHRoaXMucm9vdCA9IG5ldyBSb290QVBJKHRoaXMsIHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wcy5hdXRvUm9vdCk7XG4gICAgdGhpcy51bmNvbnRyb2xsZWQgPSBuZXcgVW5jb250cm9sbGVkQVBJKFxuICAgIC8vIFRPRE86IFJlbW92ZSBjaGVja1VuY29udHJvbGxlZFRyYXBwaW5nRm9jdXMgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICAocHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLmNoZWNrVW5jb250cm9sbGVkQ29tcGxldGVseSkgfHwgKHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wcy5jaGVja1VuY29udHJvbGxlZFRyYXBwaW5nRm9jdXMpKTtcbiAgICB0aGlzLmNvbnRyb2xUYWIgPSAoX2EgPSBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuY29udHJvbFRhYikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcbiAgICB0aGlzLnJvb3REdW1teUlucHV0cyA9ICEhKHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wcy5yb290RHVtbXlJbnB1dHMpO1xuICAgIHRoaXMuX2R1bW15T2JzZXJ2ZXIgPSBuZXcgRHVtbXlJbnB1dE9ic2VydmVyKGdldFdpbmRvdyk7XG4gICAgdGhpcy5nZXRQYXJlbnQgPSAoX2IgPSBwcm9wcyA9PT0gbnVsbCB8fCBwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvcHMuZ2V0UGFyZW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkb20uZ2V0UGFyZW50Tm9kZTtcbiAgICB0aGlzLmludGVybmFsID0ge1xuICAgICAgc3RvcE9ic2VydmVyOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl91bm9ic2VydmUpIHtcbiAgICAgICAgICB0aGlzLl91bm9ic2VydmUoKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fdW5vYnNlcnZlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzdW1lT2JzZXJ2ZXI6IHN5bmNTdGF0ZSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5fdW5vYnNlcnZlKSB7XG4gICAgICAgICAgY29uc3QgZG9jID0gZ2V0V2luZG93KCkuZG9jdW1lbnQ7XG4gICAgICAgICAgdGhpcy5fdW5vYnNlcnZlID0gb2JzZXJ2ZU11dGF0aW9ucyhkb2MsIHRoaXMsIHVwZGF0ZVRhYnN0ZXJCeUF0dHJpYnV0ZSwgc3luY1N0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgc3RhcnRGYWtlV2Vha1JlZnNDbGVhbnVwKGdldFdpbmRvdyk7XG4gICAgLy8gR2l2ZXMgYSB0aWNrIHRvIHRoZSBob3N0IGFwcCB0byBpbml0aWFsaXplIG90aGVyIHRhYnN0ZXJcbiAgICAvLyBBUElzIGJlZm9yZSB0YWJzdGVyIHN0YXJ0cyBvYnNlcnZpbmcgYXR0cmlidXRlcy5cbiAgICB0aGlzLnF1ZXVlSW5pdCgoKSA9PiB7XG4gICAgICB0aGlzLmludGVybmFsLnJlc3VtZU9ic2VydmVyKHRydWUpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBNZXJnZXMgZXh0ZXJuYWwgcHJvcHMgd2l0aCB0aGUgY3VycmVudCBwcm9wcy4gTm90IGFsbFxuICAgKiBwcm9wcyBjYW4vc2hvdWxkIGJlIG1lcmdlYWJsZSwgc28gbGV0J3MgYWRkIG1vcmUgYXMgd2UgbW92ZSBvbi5cbiAgICogQHBhcmFtIHByb3BzIFRhYnN0ZXIgcHJvcHNcbiAgICovXG4gIF9tZXJnZVByb3BzKHByb3BzKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5nZXRQYXJlbnQgPSAoX2EgPSBwcm9wcy5nZXRQYXJlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuZ2V0UGFyZW50O1xuICB9XG4gIGNyZWF0ZVRhYnN0ZXIobm9SZWZDb3VudCwgcHJvcHMpIHtcbiAgICBjb25zdCB3cmFwcGVyID0gbmV3IFRhYnN0ZXIodGhpcyk7XG4gICAgaWYgKCFub1JlZkNvdW50KSB7XG4gICAgICB0aGlzLl93cmFwcGVycy5hZGQod3JhcHBlcik7XG4gICAgfVxuICAgIHRoaXMuX21lcmdlUHJvcHMocHJvcHMpO1xuICAgIHJldHVybiB3cmFwcGVyO1xuICB9XG4gIGRpc3Bvc2VUYWJzdGVyKHdyYXBwZXIsIGFsbEluc3RhbmNlcykge1xuICAgIGlmIChhbGxJbnN0YW5jZXMpIHtcbiAgICAgIHRoaXMuX3dyYXBwZXJzLmNsZWFyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dyYXBwZXJzLmRlbGV0ZSh3cmFwcGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3dyYXBwZXJzLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgdGhpcy5pbnRlcm5hbC5zdG9wT2JzZXJ2ZXIoKTtcbiAgICBjb25zdCB3aW4gPSB0aGlzLl93aW47XG4gICAgd2luID09PSBudWxsIHx8IHdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luLmNsZWFyVGltZW91dCh0aGlzLl9pbml0VGltZXIpO1xuICAgIGRlbGV0ZSB0aGlzLl9pbml0VGltZXI7XG4gICAgdGhpcy5faW5pdFF1ZXVlID0gW107XG4gICAgdGhpcy5fZm9yZ2V0TWVtb3JpemVkRWxlbWVudHMgPSBbXTtcbiAgICBpZiAod2luICYmIHRoaXMuX2ZvcmdldE1lbW9yaXplZFRpbWVyKSB7XG4gICAgICB3aW4uY2xlYXJUaW1lb3V0KHRoaXMuX2ZvcmdldE1lbW9yaXplZFRpbWVyKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9mb3JnZXRNZW1vcml6ZWRUaW1lcjtcbiAgICB9XG4gICAgKF9hID0gdGhpcy5vdXRsaW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xuICAgIChfYiA9IHRoaXMuY3Jvc3NPcmlnaW4pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNwb3NlKCk7XG4gICAgKF9jID0gdGhpcy5kZWxvc2VyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGlzcG9zZSgpO1xuICAgIChfZCA9IHRoaXMuZ3JvdXBwZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5kaXNwb3NlKCk7XG4gICAgKF9lID0gdGhpcy5tb3ZlcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmRpc3Bvc2UoKTtcbiAgICAoX2YgPSB0aGlzLm1vZGFsaXplcikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmRpc3Bvc2UoKTtcbiAgICAoX2cgPSB0aGlzLm9ic2VydmVkRWxlbWVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmRpc3Bvc2UoKTtcbiAgICAoX2ggPSB0aGlzLnJlc3RvcmVyKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZGlzcG9zZSgpO1xuICAgIHRoaXMua2V5Ym9hcmROYXZpZ2F0aW9uLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmZvY3VzYWJsZS5kaXNwb3NlKCk7XG4gICAgdGhpcy5mb2N1c2VkRWxlbWVudC5kaXNwb3NlKCk7XG4gICAgdGhpcy5yb290LmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9kdW1teU9ic2VydmVyLmRpc3Bvc2UoKTtcbiAgICBzdG9wRmFrZVdlYWtSZWZzQ2xlYW51cEFuZENsZWFyU3RvcmFnZSh0aGlzLmdldFdpbmRvdyk7XG4gICAgY2xlYXJFbGVtZW50Q2FjaGUodGhpcy5nZXRXaW5kb3cpO1xuICAgIHRoaXMuX3N0b3JhZ2UgPSBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuX3dyYXBwZXJzLmNsZWFyKCk7XG4gICAgaWYgKHdpbikge1xuICAgICAgZGlzcG9zZUluc3RhbmNlQ29udGV4dCh3aW4pO1xuICAgICAgZGVsZXRlIHdpbi5fX3RhYnN0ZXJJbnN0YW5jZTtcbiAgICAgIGRlbGV0ZSB0aGlzLl93aW47XG4gICAgfVxuICB9XG4gIHN0b3JhZ2VFbnRyeShlbGVtZW50LCBhZGRyZW1vdmUpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5fc3RvcmFnZTtcbiAgICBsZXQgZW50cnkgPSBzdG9yYWdlLmdldChlbGVtZW50KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGlmIChhZGRyZW1vdmUgPT09IGZhbHNlICYmIE9iamVjdC5rZXlzKGVudHJ5KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3RvcmFnZS5kZWxldGUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhZGRyZW1vdmUgPT09IHRydWUpIHtcbiAgICAgIGVudHJ5ID0ge307XG4gICAgICBzdG9yYWdlLnNldChlbGVtZW50LCBlbnRyeSk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeTtcbiAgfVxuICBmb3JjZUNsZWFudXAoKSB7XG4gICAgaWYgKCF0aGlzLl93aW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZm9yZ2V0TWVtb3JpemVkRWxlbWVudHMucHVzaCh0aGlzLl93aW4uZG9jdW1lbnQuYm9keSk7XG4gICAgaWYgKHRoaXMuX2ZvcmdldE1lbW9yaXplZFRpbWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2ZvcmdldE1lbW9yaXplZFRpbWVyID0gdGhpcy5fd2luLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZGVsZXRlIHRoaXMuX2ZvcmdldE1lbW9yaXplZFRpbWVyO1xuICAgICAgZm9yIChsZXQgZWwgPSB0aGlzLl9mb3JnZXRNZW1vcml6ZWRFbGVtZW50cy5zaGlmdCgpOyBlbDsgZWwgPSB0aGlzLl9mb3JnZXRNZW1vcml6ZWRFbGVtZW50cy5zaGlmdCgpKSB7XG4gICAgICAgIGNsZWFyRWxlbWVudENhY2hlKHRoaXMuZ2V0V2luZG93LCBlbCk7XG4gICAgICAgIEZvY3VzZWRFbGVtZW50U3RhdGUuZm9yZ2V0TWVtb3JpemVkKHRoaXMuZm9jdXNlZEVsZW1lbnQsIGVsKTtcbiAgICAgIH1cbiAgICB9LCAwKTtcbiAgICBjbGVhbnVwRmFrZVdlYWtSZWZzKHRoaXMuZ2V0V2luZG93LCB0cnVlKTtcbiAgfVxuICBxdWV1ZUluaXQoY2FsbGJhY2spIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLl93aW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faW5pdFF1ZXVlLnB1c2goY2FsbGJhY2spO1xuICAgIGlmICghdGhpcy5faW5pdFRpbWVyKSB7XG4gICAgICB0aGlzLl9pbml0VGltZXIgPSAoX2EgPSB0aGlzLl93aW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2luaXRUaW1lcjtcbiAgICAgICAgdGhpcy5kcmFpbkluaXRRdWV1ZSgpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG4gIGRyYWluSW5pdFF1ZXVlKCkge1xuICAgIGlmICghdGhpcy5fd2luKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5faW5pdFF1ZXVlO1xuICAgIC8vIFJlc2V0dGluZyB0aGUgcXVldWUgYmVmb3JlIGNhbGxpbmcgdGhlIGNhbGxiYWNrcyB0byBhdm9pZCByZWN1cnNpb24uXG4gICAgdGhpcy5faW5pdFF1ZXVlID0gW107XG4gICAgcXVldWUuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjaygpKTtcbiAgfVxufVxuZnVuY3Rpb24gZm9yY2VDbGVhbnVwKHRhYnN0ZXIpIHtcbiAgLy8gVGhlIG9ubHkgbGVnaXQgY2FzZSBmb3IgY2FsbGluZyB0aGlzIG1ldGhvZCBpcyB3aGVuIHlvdSd2ZSBjb21wbGV0ZWx5IHJlbW92ZWRcbiAgLy8gdGhlIGFwcGxpY2F0aW9uIERPTSBhbmQgbm90IGdvaW5nIHRvIGFkZCB0aGUgbmV3IG9uZSBmb3IgYSB3aGlsZS5cbiAgY29uc3QgdGFic3RlckNvcmUgPSB0YWJzdGVyLmNvcmU7XG4gIHRhYnN0ZXJDb3JlLmZvcmNlQ2xlYW51cCgpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFRhYnN0ZXIsIHJldHVybnMgdGhlIGN1cnJlbnQgd2luZG93IGluc3RhbmNlIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVUYWJzdGVyKHdpbiwgcHJvcHMpIHtcbiAgbGV0IHRhYnN0ZXIgPSBnZXRDdXJyZW50VGFic3Rlcih3aW4pO1xuICBpZiAodGFic3Rlcikge1xuICAgIHJldHVybiB0YWJzdGVyLmNyZWF0ZVRhYnN0ZXIoZmFsc2UsIHByb3BzKTtcbiAgfVxuICB0YWJzdGVyID0gbmV3IFRhYnN0ZXJDb3JlKHdpbiwgcHJvcHMpO1xuICB3aW4uX190YWJzdGVySW5zdGFuY2UgPSB0YWJzdGVyO1xuICByZXR1cm4gdGFic3Rlci5jcmVhdGVUYWJzdGVyKCk7XG59XG4vKipcbiAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgVGFic3RlciBpZiBpdCB3YXMgY3JlYXRlZCBiZWZvcmUgb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0VGFic3Rlcih3aW4pIHtcbiAgY29uc3QgdGFic3RlciA9IGdldEN1cnJlbnRUYWJzdGVyKHdpbik7XG4gIHJldHVybiB0YWJzdGVyID8gdGFic3Rlci5jcmVhdGVUYWJzdGVyKHRydWUpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFNoYWRvd0RPTUFQSSgpIHtcbiAgcmV0dXJuIHNoYWRvd0RPTUFQSTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBncm91cHBlciBpbnN0YW5jZSBvciByZXR1cm5zIGFuIGV4aXN0aW5nIG9uZVxuICogQHBhcmFtIHRhYnN0ZXIgVGFic3RlciBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBnZXRHcm91cHBlcih0YWJzdGVyKSB7XG4gIGNvbnN0IHRhYnN0ZXJDb3JlID0gdGFic3Rlci5jb3JlO1xuICBpZiAoIXRhYnN0ZXJDb3JlLmdyb3VwcGVyKSB7XG4gICAgdGFic3RlckNvcmUuZ3JvdXBwZXIgPSBuZXcgR3JvdXBwZXJBUEkodGFic3RlckNvcmUsIHRhYnN0ZXJDb3JlLmdldFdpbmRvdyk7XG4gIH1cbiAgcmV0dXJuIHRhYnN0ZXJDb3JlLmdyb3VwcGVyO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1vdmVyIGluc3RhbmNlIG9yIHJldHVybnMgYW4gZXhpc3Rpbmcgb25lXG4gKiBAcGFyYW0gdGFic3RlciBUYWJzdGVyIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGdldE1vdmVyKHRhYnN0ZXIpIHtcbiAgY29uc3QgdGFic3RlckNvcmUgPSB0YWJzdGVyLmNvcmU7XG4gIGlmICghdGFic3RlckNvcmUubW92ZXIpIHtcbiAgICB0YWJzdGVyQ29yZS5tb3ZlciA9IG5ldyBNb3ZlckFQSSh0YWJzdGVyQ29yZSwgdGFic3RlckNvcmUuZ2V0V2luZG93KTtcbiAgfVxuICByZXR1cm4gdGFic3RlckNvcmUubW92ZXI7XG59XG5mdW5jdGlvbiBnZXRPdXRsaW5lKHRhYnN0ZXIpIHtcbiAgY29uc3QgdGFic3RlckNvcmUgPSB0YWJzdGVyLmNvcmU7XG4gIGlmICghdGFic3RlckNvcmUub3V0bGluZSkge1xuICAgIHRhYnN0ZXJDb3JlLm91dGxpbmUgPSBuZXcgT3V0bGluZUFQSSh0YWJzdGVyQ29yZSk7XG4gIH1cbiAgcmV0dXJuIHRhYnN0ZXJDb3JlLm91dGxpbmU7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbmV3IGRlbG9zZXIgaW5zdGFuY2Ugb3IgcmV0dXJucyBhbiBleGlzdGluZyBvbmVcbiAqIEBwYXJhbSB0YWJzdGVyIFRhYnN0ZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSBwcm9wcyBEZWxvc2VyIHByb3BzXG4gKi9cbmZ1bmN0aW9uIGdldERlbG9zZXIodGFic3RlciwgcHJvcHMpIHtcbiAgY29uc3QgdGFic3RlckNvcmUgPSB0YWJzdGVyLmNvcmU7XG4gIGlmICghdGFic3RlckNvcmUuZGVsb3Nlcikge1xuICAgIHRhYnN0ZXJDb3JlLmRlbG9zZXIgPSBuZXcgRGVsb3NlckFQSSh0YWJzdGVyQ29yZSwgcHJvcHMpO1xuICB9XG4gIHJldHVybiB0YWJzdGVyQ29yZS5kZWxvc2VyO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1vZGFsaXplciBpbnN0YW5jZSBvciByZXR1cm5zIGFuIGV4aXN0aW5nIG9uZVxuICogQHBhcmFtIHRhYnN0ZXIgVGFic3RlciBpbnN0YW5jZVxuICogQHBhcmFtIGFsd2F5c0FjY2Vzc2libGVTZWxlY3RvciBXaGVuIE1vZGFsaXplciBpcyBhY3RpdmUsIHdlIHB1dFxuICogYXJpYS1oaWRkZW4gdG8gZXZlcnl0aGluZyBlbHNlIHRvIGhpZGUgaXQgZnJvbSBzY3JlZW4gcmVhZGVycy4gVGhpcyBDU1NcbiAqIHNlbGVjdG9yIGFsbG93cyB0byBleGNsdWRlIHNvbWUgZWxlbWVudHMgZnJvbSB0aGlzIGJlaGF2aW91ci4gRm9yIGV4YW1wbGUsXG4gKiB0aGlzIGNvdWxkIGJlIHVzZWQgdG8gZXhjbHVkZSBhcmlhLWxpdmUgcmVnaW9uIHdpdGggdGhlIGFwcGxpY2F0aW9uLXdpZGVcbiAqIHN0YXR1cyBhbm5vdW5jZW1lbnRzLlxuICogQHBhcmFtIGFjY2Vzc2libGVDaGVjayBBbiBvcHRpb25hbCBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAqIGFjdGl2ZSBNb2RhbGl6ZXIgd2FudHMgdG8gaGlkZSBhbiBlbGVtZW50IHRoYXQgZG9lc24ndCBiZWxvbmcgdG8gaXQgZnJvbVxuICogdGhlIHNjcmVlbiByZWFkZXJzIGJ5IHNldHRpbmcgYXJpYS1oaWRkZW4uIFNpbWlsYXIgdG8gYWx3YXlzQWNjZXNzaWJsZVNlbGVjdG9yXG4gKiBidXQgYWxsb3dzIHRvIGFkZHJlc3MgdGhlIGVsZW1lbnRzIHByb2dyYW1tYXRpY2FsbHkgcmF0aGVyIHRoYW4gd2l0aCBhIHNlbGVjdG9yLlxuICogSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZSwgdGhlIGVsZW1lbnQgd2lsbCBub3QgcmVjZWl2ZSBhcmlhLWhpZGRlbi5cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kYWxpemVyKHRhYnN0ZXIsXG4vLyBAZGVwcmVjYXRlZCB1c2UgYWNjZXNzaWJsZUNoZWNrLlxuYWx3YXlzQWNjZXNzaWJsZVNlbGVjdG9yLCBhY2Nlc3NpYmxlQ2hlY2spIHtcbiAgY29uc3QgdGFic3RlckNvcmUgPSB0YWJzdGVyLmNvcmU7XG4gIGlmICghdGFic3RlckNvcmUubW9kYWxpemVyKSB7XG4gICAgdGFic3RlckNvcmUubW9kYWxpemVyID0gbmV3IE1vZGFsaXplckFQSSh0YWJzdGVyQ29yZSwgYWx3YXlzQWNjZXNzaWJsZVNlbGVjdG9yLCBhY2Nlc3NpYmxlQ2hlY2spO1xuICB9XG4gIHJldHVybiB0YWJzdGVyQ29yZS5tb2RhbGl6ZXI7XG59XG5mdW5jdGlvbiBnZXRPYnNlcnZlZEVsZW1lbnQodGFic3Rlcikge1xuICBjb25zdCB0YWJzdGVyQ29yZSA9IHRhYnN0ZXIuY29yZTtcbiAgaWYgKCF0YWJzdGVyQ29yZS5vYnNlcnZlZEVsZW1lbnQpIHtcbiAgICB0YWJzdGVyQ29yZS5vYnNlcnZlZEVsZW1lbnQgPSBuZXcgT2JzZXJ2ZWRFbGVtZW50QVBJKHRhYnN0ZXJDb3JlKTtcbiAgfVxuICByZXR1cm4gdGFic3RlckNvcmUub2JzZXJ2ZWRFbGVtZW50O1xufVxuZnVuY3Rpb24gZ2V0Q3Jvc3NPcmlnaW4odGFic3Rlcikge1xuICBjb25zdCB0YWJzdGVyQ29yZSA9IHRhYnN0ZXIuY29yZTtcbiAgaWYgKCF0YWJzdGVyQ29yZS5jcm9zc09yaWdpbikge1xuICAgIGdldERlbG9zZXIodGFic3Rlcik7XG4gICAgZ2V0TW9kYWxpemVyKHRhYnN0ZXIpO1xuICAgIGdldE1vdmVyKHRhYnN0ZXIpO1xuICAgIGdldEdyb3VwcGVyKHRhYnN0ZXIpO1xuICAgIGdldE91dGxpbmUodGFic3Rlcik7XG4gICAgZ2V0T2JzZXJ2ZWRFbGVtZW50KHRhYnN0ZXIpO1xuICAgIHRhYnN0ZXJDb3JlLmNyb3NzT3JpZ2luID0gbmV3IENyb3NzT3JpZ2luQVBJKHRhYnN0ZXJDb3JlKTtcbiAgfVxuICByZXR1cm4gdGFic3RlckNvcmUuY3Jvc3NPcmlnaW47XG59XG5mdW5jdGlvbiBnZXRJbnRlcm5hbCh0YWJzdGVyKSB7XG4gIGNvbnN0IHRhYnN0ZXJDb3JlID0gdGFic3Rlci5jb3JlO1xuICByZXR1cm4gdGFic3RlckNvcmUuaW50ZXJuYWw7XG59XG5mdW5jdGlvbiBnZXRSZXN0b3Jlcih0YWJzdGVyKSB7XG4gIGNvbnN0IHRhYnN0ZXJDb3JlID0gdGFic3Rlci5jb3JlO1xuICBpZiAoIXRhYnN0ZXJDb3JlLnJlc3RvcmVyKSB7XG4gICAgdGFic3RlckNvcmUucmVzdG9yZXIgPSBuZXcgUmVzdG9yZXJBUEkodGFic3RlckNvcmUpO1xuICB9XG4gIHJldHVybiB0YWJzdGVyQ29yZS5yZXN0b3Jlcjtcbn1cbmZ1bmN0aW9uIGRpc3Bvc2VUYWJzdGVyKHRhYnN0ZXIsIGFsbEluc3RhbmNlcykge1xuICB0YWJzdGVyLmNvcmUuZGlzcG9zZVRhYnN0ZXIodGFic3RlciwgYWxsSW5zdGFuY2VzKTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBUYWJzdGVyIGlmIGl0IGFscmVhZHkgZXhpc3RzIG9uIHRoZSB3aW5kb3cgLlxuICogQHBhcmFtIHdpbiB3aW5kb3cgaW5zdGFuY2UgdGhhdCBjb3VsZCBjb250YWluIGFuIFRhYnN0ZXIgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldEN1cnJlbnRUYWJzdGVyKHdpbikge1xuICByZXR1cm4gd2luLl9fdGFic3Rlckluc3RhbmNlO1xufVxuLyoqXG4gKiBBbGxvd3MgdG8gbWFrZSBUYWJzdGVyIG5vbiBvcGVyYXRpb25hbC4gSW50ZW5kZWQgZm9yIHBlcmZvcm1hbmNlIGRlYnVnZ2luZyAoYW5kIG90aGVyXG4gKiBraW5kcyBvZiBkZWJ1Z2dpbmcpLCB5b3UgY2FuIHN3aXRjaCBUYWJzdGVyIG9mZiB3aXRob3V0IGNoYW5naW5nIHRoZSBhcHBsaWNhdGlvbiBjb2RlXG4gKiB0aGF0IGNvbnN1bWVzIGl0LlxuICogQHBhcmFtIHRhYnN0ZXIgYSByZWZlcmVuY2UgY3JlYXRlZCBieSBjcmVhdGVUYWJzdGVyKCkuXG4gKiBAcGFyYW0gbm9vcCB0cnVlIGlmIHlvdSB3YW50IHRvIG1ha2UgVGFic3RlciBub29wLCBmYWxzZSBpZiB5b3Ugd2FudCB0byB0dXJuIGl0IGJhY2suXG4gKi9cbmZ1bmN0aW9uIG1ha2VOb09wKHRhYnN0ZXIsIG5vb3ApIHtcbiAgY29uc3QgY29yZSA9IHRhYnN0ZXIuY29yZTtcbiAgaWYgKGNvcmUuX25vb3AgIT09IG5vb3ApIHtcbiAgICBjb3JlLl9ub29wID0gbm9vcDtcbiAgICBjb25zdCBwcm9jZXNzTm9kZSA9IGVsZW1lbnQgPT4ge1xuICAgICAgaWYgKCFlbGVtZW50LmdldEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgICAgIH1cbiAgICAgIGlmIChnZXRUYWJzdGVyT25FbGVtZW50KGNvcmUsIGVsZW1lbnQpIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKFRBQlNURVJfQVRUUklCVVRFX05BTUUpKSB7XG4gICAgICAgIHVwZGF0ZVRhYnN0ZXJCeUF0dHJpYnV0ZShjb3JlLCBlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgIH07XG4gICAgY29uc3QgZG9jID0gY29yZS5nZXRXaW5kb3coKS5kb2N1bWVudDtcbiAgICBjb25zdCBib2R5ID0gZG9jLmJvZHk7XG4gICAgcHJvY2Vzc05vZGUoYm9keSk7XG4gICAgY29uc3Qgd2Fsa2VyID0gY3JlYXRlRWxlbWVudFRyZWVXYWxrZXIoZG9jLCBib2R5LCBwcm9jZXNzTm9kZSk7XG4gICAgaWYgKHdhbGtlcikge1xuICAgICAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgIC8qIEl0ZXJhdGluZyBmb3IgdGhlIHNha2Ugb2YgY2FsbGluZyBwcm9jZXNzTm9kZSgpIGNhbGxiYWNrLiAqL1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNOb09wKHRhYnN0ZXIpIHtcbiAgcmV0dXJuIHRhYnN0ZXIuX25vb3A7XG59XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxudmFyIFR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxudmFyIEV2ZW50c1R5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbi8qIVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGlzIG9ic29sZXRlLCB1c2UgbmF0aXZlIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgR3JvdXBwZXJNb3ZlRm9jdXNFdmVudCguLi4pKS4gKi9cbmZ1bmN0aW9uIGRpc3BhdGNoR3JvdXBwZXJNb3ZlRm9jdXNFdmVudCh0YXJnZXQsIGFjdGlvbikge1xuICByZXR1cm4gdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEdyb3VwcGVyTW92ZUZvY3VzRXZlbnQoe1xuICAgIGFjdGlvblxuICB9KSk7XG59XG4vKiogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBpcyBvYnNvbGV0ZSwgdXNlIG5hdGl2ZSBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IE1vdmVyTW92ZUZvY3VzRXZlbnQoLi4uKSkuICovXG5mdW5jdGlvbiBkaXNwYXRjaE1vdmVyTW92ZUZvY3VzRXZlbnQodGFyZ2V0LCBrZXkpIHtcbiAgcmV0dXJuIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBNb3Zlck1vdmVGb2N1c0V2ZW50KHtcbiAgICBrZXlcbiAgfSkpO1xufVxuLyoqIEBkZXByZWNhdGVkIFRoaXMgZnVuY3Rpb24gaXMgb2Jzb2xldGUsIHVzZSBuYXRpdmUgZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBNb3Zlck1lbW9yaXplZEVsZW1lbnRFdmVudCguLi4pKS4gKi9cbmZ1bmN0aW9uIGRpc3BhdGNoTW92ZXJNZW1vcml6ZWRFbGVtZW50RXZlbnQodGFyZ2V0LCBtZW1vcml6ZWRFbGVtZW50KSB7XG4gIHJldHVybiB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgTW92ZXJNZW1vcml6ZWRFbGVtZW50RXZlbnQoe1xuICAgIG1lbW9yaXplZEVsZW1lbnRcbiAgfSkpO1xufVxuXG5leHBvcnQgeyBBc3luY0ZvY3VzU291cmNlcywgRGVsb3NlckZvY3VzTG9zdEV2ZW50LCBEZWxvc2VyRm9jdXNMb3N0RXZlbnROYW1lLCBEZWxvc2VyUmVzdG9yZUZvY3VzRXZlbnQsIERlbG9zZXJSZXN0b3JlRm9jdXNFdmVudE5hbWUsIERlbG9zZXJTdHJhdGVnaWVzLCBFdmVudHNUeXBlcywgRk9DVVNBQkxFX1NFTEVDVE9SLCBHcm91cHBlck1vdmVGb2N1c0FjdGlvbnMsIEdyb3VwcGVyTW92ZUZvY3VzRXZlbnQsIEdyb3VwcGVyTW92ZUZvY3VzRXZlbnROYW1lLCBHcm91cHBlclRhYmJhYmlsaXRpZXMsIE1vZGFsaXplckFjdGl2ZUV2ZW50LCBNb2RhbGl6ZXJBY3RpdmVFdmVudE5hbWUsIE1vZGFsaXplckZvY3VzSW5FdmVudE5hbWUsIE1vZGFsaXplckZvY3VzT3V0RXZlbnROYW1lLCBNb2RhbGl6ZXJJbmFjdGl2ZUV2ZW50LCBNb2RhbGl6ZXJJbmFjdGl2ZUV2ZW50TmFtZSwgTW92ZXJEaXJlY3Rpb25zLCBNb3ZlcktleXMsIE1vdmVyTWVtb3JpemVkRWxlbWVudEV2ZW50LCBNb3Zlck1lbW9yaXplZEVsZW1lbnRFdmVudE5hbWUsIE1vdmVyTW92ZUZvY3VzRXZlbnQsIE1vdmVyTW92ZUZvY3VzRXZlbnROYW1lLCBNb3ZlclN0YXRlRXZlbnQsIE1vdmVyU3RhdGVFdmVudE5hbWUsIE9ic2VydmVkRWxlbWVudEFjY2Vzc2liaWxpdGllcywgT2JzZXJ2ZWRFbGVtZW50RmFpbHVyZVJlYXNvbnMsIE9ic2VydmVkRWxlbWVudFJlcXVlc3RTdGF0dXNlcywgUmVzdG9yZUZvY3VzT3JkZXJzLCBSZXN0b3JlclJlc3RvcmVGb2N1c0V2ZW50LCBSZXN0b3JlclJlc3RvcmVGb2N1c0V2ZW50TmFtZSwgUmVzdG9yZXJUeXBlcywgUm9vdEJsdXJFdmVudCwgUm9vdEJsdXJFdmVudE5hbWUsIFJvb3RGb2N1c0V2ZW50LCBSb290Rm9jdXNFdmVudE5hbWUsIFN5c0R1bW15SW5wdXRzUG9zaXRpb25zLCBUQUJTVEVSX0FUVFJJQlVURV9OQU1FLCBUQUJTVEVSX0RVTU1ZX0lOUFVUX0FUVFJJQlVURV9OQU1FLCBUYWJzdGVyQ3VzdG9tRXZlbnQsIFRhYnN0ZXJGb2N1c0luRXZlbnQsIFRhYnN0ZXJGb2N1c0luRXZlbnROYW1lLCBUYWJzdGVyRm9jdXNPdXRFdmVudCwgVGFic3RlckZvY3VzT3V0RXZlbnROYW1lLCBUYWJzdGVyTW92ZUZvY3VzRXZlbnQsIFRhYnN0ZXJNb3ZlRm9jdXNFdmVudE5hbWUsIFR5cGVzLCBWaXNpYmlsaXRpZXMsIGNyZWF0ZVRhYnN0ZXIsIGRpc3BhdGNoR3JvdXBwZXJNb3ZlRm9jdXNFdmVudCwgZGlzcGF0Y2hNb3Zlck1lbW9yaXplZEVsZW1lbnRFdmVudCwgZGlzcGF0Y2hNb3Zlck1vdmVGb2N1c0V2ZW50LCBkaXNwb3NlVGFic3RlciwgZm9yY2VDbGVhbnVwLCBnZXRDcm9zc09yaWdpbiwgZ2V0RGVsb3NlciwgZ2V0RHVtbXlJbnB1dENvbnRhaW5lciwgZ2V0R3JvdXBwZXIsIGdldEludGVybmFsLCBnZXRNb2RhbGl6ZXIsIGdldE1vdmVyLCBnZXRPYnNlcnZlZEVsZW1lbnQsIGdldE91dGxpbmUsIGdldFJlc3RvcmVyLCBnZXRTaGFkb3dET01BUEksIGdldFRhYnN0ZXIsIGdldFRhYnN0ZXJBdHRyaWJ1dGUsIGlzTm9PcCwgbWFrZU5vT3AsIG1lcmdlVGFic3RlclByb3BzLCBzZXRUYWJzdGVyQXR0cmlidXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJzdGVyLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tabster/dist/tabster.esm.js\n");

/***/ })

};
;