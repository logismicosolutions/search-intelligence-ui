"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/embla-carousel-fade";
exports.ids = ["vendor-chunks/embla-carousel-fade"];
exports.modules = {

/***/ "(ssr)/./node_modules/embla-carousel-fade/cjs/embla-carousel-fade.cjs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/embla-carousel-fade/cjs/embla-carousel-fade.cjs.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("\n\nfunction clampNumber(number, min, max) {\n  return Math.min(Math.max(number, min), max);\n}\nfunction isNumber(value) {\n  return typeof value === 'number' && !isNaN(value);\n}\n\nfunction Fade(userOptions = {}) {\n  const fullOpacity = 1;\n  const noOpacity = 0;\n  const fadeFriction = 0.68;\n  let emblaApi;\n  let opacities = [];\n  let fadeToNextDistance;\n  let distanceFromPointerDown = 0;\n  let fadeVelocity = 0;\n  let progress = 0;\n  let shouldFadePair = false;\n  let defaultSettledBehaviour;\n  let defaultProgressBehaviour;\n  function init(emblaApiInstance) {\n    emblaApi = emblaApiInstance;\n    const selectedSnap = emblaApi.selectedScrollSnap();\n    const {\n      scrollBody,\n      containerRect,\n      axis\n    } = emblaApi.internalEngine();\n    const containerSize = axis.measureSize(containerRect);\n    fadeToNextDistance = clampNumber(containerSize * 0.75, 200, 500);\n    shouldFadePair = false;\n    opacities = emblaApi.scrollSnapList().map((_, index) => index === selectedSnap ? fullOpacity : noOpacity);\n    defaultSettledBehaviour = scrollBody.settled;\n    defaultProgressBehaviour = emblaApi.scrollProgress;\n    scrollBody.settled = settled;\n    emblaApi.scrollProgress = scrollProgress;\n    emblaApi.on('select', select).on('slideFocus', fadeToSelectedSnapInstantly).on('pointerDown', pointerDown).on('pointerUp', pointerUp);\n    disableScroll();\n    fadeToSelectedSnapInstantly();\n  }\n  function destroy() {\n    const {\n      scrollBody\n    } = emblaApi.internalEngine();\n    scrollBody.settled = defaultSettledBehaviour;\n    emblaApi.scrollProgress = defaultProgressBehaviour;\n    emblaApi.off('select', select).off('slideFocus', fadeToSelectedSnapInstantly).off('pointerDown', pointerDown).off('pointerUp', pointerUp);\n    emblaApi.slideNodes().forEach(slideNode => {\n      const slideStyle = slideNode.style;\n      slideStyle.opacity = '';\n      slideStyle.transform = '';\n      slideStyle.pointerEvents = '';\n      if (!slideNode.getAttribute('style')) slideNode.removeAttribute('style');\n    });\n  }\n  function fadeToSelectedSnapInstantly() {\n    const selectedSnap = emblaApi.selectedScrollSnap();\n    setOpacities(selectedSnap, fullOpacity);\n  }\n  function pointerUp() {\n    shouldFadePair = false;\n  }\n  function pointerDown() {\n    shouldFadePair = false;\n    distanceFromPointerDown = 0;\n    fadeVelocity = 0;\n  }\n  function select() {\n    const duration = emblaApi.internalEngine().scrollBody.duration();\n    fadeVelocity = duration ? 0 : fullOpacity;\n    shouldFadePair = true;\n    if (!duration) fadeToSelectedSnapInstantly();\n  }\n  function getSlideTransform(position) {\n    const {\n      axis\n    } = emblaApi.internalEngine();\n    const translateAxis = axis.scroll.toUpperCase();\n    return `translate${translateAxis}(${axis.direction(position)}px)`;\n  }\n  function disableScroll() {\n    const {\n      translate,\n      slideLooper\n    } = emblaApi.internalEngine();\n    translate.clear();\n    translate.toggleActive(false);\n    slideLooper.loopPoints.forEach(({\n      translate\n    }) => {\n      translate.clear();\n      translate.toggleActive(false);\n    });\n  }\n  function lockExcessiveScroll(fadeIndex) {\n    const {\n      scrollSnaps,\n      location,\n      target\n    } = emblaApi.internalEngine();\n    if (!isNumber(fadeIndex) || opacities[fadeIndex] < 0.5) return;\n    location.set(scrollSnaps[fadeIndex]);\n    target.set(location);\n  }\n  function setOpacities(fadeIndex, velocity) {\n    const scrollSnaps = emblaApi.scrollSnapList();\n    scrollSnaps.forEach((_, indexA) => {\n      const absVelocity = Math.abs(velocity);\n      const currentOpacity = opacities[indexA];\n      const isFadeIndex = indexA === fadeIndex;\n      const nextOpacity = isFadeIndex ? currentOpacity + absVelocity : currentOpacity - absVelocity;\n      const clampedOpacity = clampNumber(nextOpacity, noOpacity, fullOpacity);\n      opacities[indexA] = clampedOpacity;\n      const fadePair = isFadeIndex && shouldFadePair;\n      const indexB = emblaApi.previousScrollSnap();\n      if (fadePair) opacities[indexB] = 1 - clampedOpacity;\n      if (isFadeIndex) setProgress(fadeIndex, clampedOpacity);\n      setOpacity(indexA);\n    });\n  }\n  function setOpacity(index) {\n    const slidesInSnap = emblaApi.internalEngine().slideRegistry[index];\n    const {\n      scrollSnaps,\n      containerRect\n    } = emblaApi.internalEngine();\n    const opacity = opacities[index];\n    slidesInSnap.forEach(slideIndex => {\n      const slideStyle = emblaApi.slideNodes()[slideIndex].style;\n      const roundedOpacity = parseFloat(opacity.toFixed(2));\n      const hasOpacity = roundedOpacity > noOpacity;\n      const position = hasOpacity ? scrollSnaps[index] : containerRect.width + 2;\n      const transform = getSlideTransform(position);\n      if (hasOpacity) slideStyle.transform = transform;\n      slideStyle.opacity = roundedOpacity.toString();\n      slideStyle.pointerEvents = opacity > 0.5 ? 'auto' : 'none';\n      if (!hasOpacity) slideStyle.transform = transform;\n    });\n  }\n  function setProgress(fadeIndex, opacity) {\n    const {\n      index,\n      dragHandler,\n      scrollSnaps\n    } = emblaApi.internalEngine();\n    const pointerDown = dragHandler.pointerDown();\n    const snapFraction = 1 / (scrollSnaps.length - 1);\n    let indexA = fadeIndex;\n    let indexB = pointerDown ? emblaApi.selectedScrollSnap() : emblaApi.previousScrollSnap();\n    if (pointerDown && indexA === indexB) {\n      const reverseSign = Math.sign(distanceFromPointerDown) * -1;\n      indexA = indexB;\n      indexB = index.clone().set(indexB).add(reverseSign).get();\n    }\n    const currentPosition = indexB * snapFraction;\n    const diffPosition = (indexA - indexB) * snapFraction;\n    progress = currentPosition + diffPosition * opacity;\n  }\n  function getFadeIndex() {\n    const {\n      dragHandler,\n      index,\n      scrollBody\n    } = emblaApi.internalEngine();\n    const selectedSnap = emblaApi.selectedScrollSnap();\n    if (!dragHandler.pointerDown()) return selectedSnap;\n    const directionSign = Math.sign(scrollBody.velocity());\n    const distanceSign = Math.sign(distanceFromPointerDown);\n    const nextSnap = index.clone().set(selectedSnap).add(directionSign * -1).get();\n    if (!directionSign || !distanceSign) return null;\n    return distanceSign === directionSign ? nextSnap : selectedSnap;\n  }\n  function fade(emblaApi) {\n    const {\n      dragHandler,\n      scrollBody\n    } = emblaApi.internalEngine();\n    const pointerDown = dragHandler.pointerDown();\n    const velocity = scrollBody.velocity();\n    const duration = scrollBody.duration();\n    const fadeIndex = getFadeIndex();\n    const noFadeIndex = !isNumber(fadeIndex);\n    if (pointerDown) {\n      if (!velocity) return;\n      distanceFromPointerDown += velocity;\n      fadeVelocity = Math.abs(velocity / fadeToNextDistance);\n      lockExcessiveScroll(fadeIndex);\n    }\n    if (!pointerDown) {\n      if (!duration || noFadeIndex) return;\n      fadeVelocity += (fullOpacity - opacities[fadeIndex]) / duration;\n      fadeVelocity *= fadeFriction;\n    }\n    if (noFadeIndex) return;\n    setOpacities(fadeIndex, fadeVelocity);\n  }\n  function settled() {\n    const {\n      target,\n      location\n    } = emblaApi.internalEngine();\n    const diffToTarget = target.get() - location.get();\n    const notReachedTarget = Math.abs(diffToTarget) >= 1;\n    const fadeIndex = getFadeIndex();\n    const noFadeIndex = !isNumber(fadeIndex);\n    fade(emblaApi);\n    if (noFadeIndex || notReachedTarget) return false;\n    return opacities[fadeIndex] > 0.999;\n  }\n  function scrollProgress() {\n    return progress;\n  }\n  const self = {\n    name: 'fade',\n    options: userOptions,\n    init,\n    destroy\n  };\n  return self;\n}\nFade.globalOptions = undefined;\n\nmodule.exports = Fade;\n//# sourceMappingURL=embla-carousel-fade.cjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZW1ibGEtY2Fyb3VzZWwtZmFkZS9janMvZW1ibGEtY2Fyb3VzZWwtZmFkZS5janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdUJBQXVCLGNBQWMsR0FBRyx5QkFBeUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZWFyY2gtaW50ZWxsaWdlbmNlLXVpLy4vbm9kZV9tb2R1bGVzL2VtYmxhLWNhcm91c2VsLWZhZGUvY2pzL2VtYmxhLWNhcm91c2VsLWZhZGUuY2pzLmpzPzk3ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjbGFtcE51bWJlcihudW1iZXIsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChudW1iZXIsIG1pbiksIG1heCk7XG59XG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpO1xufVxuXG5mdW5jdGlvbiBGYWRlKHVzZXJPcHRpb25zID0ge30pIHtcbiAgY29uc3QgZnVsbE9wYWNpdHkgPSAxO1xuICBjb25zdCBub09wYWNpdHkgPSAwO1xuICBjb25zdCBmYWRlRnJpY3Rpb24gPSAwLjY4O1xuICBsZXQgZW1ibGFBcGk7XG4gIGxldCBvcGFjaXRpZXMgPSBbXTtcbiAgbGV0IGZhZGVUb05leHREaXN0YW5jZTtcbiAgbGV0IGRpc3RhbmNlRnJvbVBvaW50ZXJEb3duID0gMDtcbiAgbGV0IGZhZGVWZWxvY2l0eSA9IDA7XG4gIGxldCBwcm9ncmVzcyA9IDA7XG4gIGxldCBzaG91bGRGYWRlUGFpciA9IGZhbHNlO1xuICBsZXQgZGVmYXVsdFNldHRsZWRCZWhhdmlvdXI7XG4gIGxldCBkZWZhdWx0UHJvZ3Jlc3NCZWhhdmlvdXI7XG4gIGZ1bmN0aW9uIGluaXQoZW1ibGFBcGlJbnN0YW5jZSkge1xuICAgIGVtYmxhQXBpID0gZW1ibGFBcGlJbnN0YW5jZTtcbiAgICBjb25zdCBzZWxlY3RlZFNuYXAgPSBlbWJsYUFwaS5zZWxlY3RlZFNjcm9sbFNuYXAoKTtcbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxCb2R5LFxuICAgICAgY29udGFpbmVyUmVjdCxcbiAgICAgIGF4aXNcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICBjb25zdCBjb250YWluZXJTaXplID0gYXhpcy5tZWFzdXJlU2l6ZShjb250YWluZXJSZWN0KTtcbiAgICBmYWRlVG9OZXh0RGlzdGFuY2UgPSBjbGFtcE51bWJlcihjb250YWluZXJTaXplICogMC43NSwgMjAwLCA1MDApO1xuICAgIHNob3VsZEZhZGVQYWlyID0gZmFsc2U7XG4gICAgb3BhY2l0aWVzID0gZW1ibGFBcGkuc2Nyb2xsU25hcExpc3QoKS5tYXAoKF8sIGluZGV4KSA9PiBpbmRleCA9PT0gc2VsZWN0ZWRTbmFwID8gZnVsbE9wYWNpdHkgOiBub09wYWNpdHkpO1xuICAgIGRlZmF1bHRTZXR0bGVkQmVoYXZpb3VyID0gc2Nyb2xsQm9keS5zZXR0bGVkO1xuICAgIGRlZmF1bHRQcm9ncmVzc0JlaGF2aW91ciA9IGVtYmxhQXBpLnNjcm9sbFByb2dyZXNzO1xuICAgIHNjcm9sbEJvZHkuc2V0dGxlZCA9IHNldHRsZWQ7XG4gICAgZW1ibGFBcGkuc2Nyb2xsUHJvZ3Jlc3MgPSBzY3JvbGxQcm9ncmVzcztcbiAgICBlbWJsYUFwaS5vbignc2VsZWN0Jywgc2VsZWN0KS5vbignc2xpZGVGb2N1cycsIGZhZGVUb1NlbGVjdGVkU25hcEluc3RhbnRseSkub24oJ3BvaW50ZXJEb3duJywgcG9pbnRlckRvd24pLm9uKCdwb2ludGVyVXAnLCBwb2ludGVyVXApO1xuICAgIGRpc2FibGVTY3JvbGwoKTtcbiAgICBmYWRlVG9TZWxlY3RlZFNuYXBJbnN0YW50bHkoKTtcbiAgfVxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNjcm9sbEJvZHlcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICBzY3JvbGxCb2R5LnNldHRsZWQgPSBkZWZhdWx0U2V0dGxlZEJlaGF2aW91cjtcbiAgICBlbWJsYUFwaS5zY3JvbGxQcm9ncmVzcyA9IGRlZmF1bHRQcm9ncmVzc0JlaGF2aW91cjtcbiAgICBlbWJsYUFwaS5vZmYoJ3NlbGVjdCcsIHNlbGVjdCkub2ZmKCdzbGlkZUZvY3VzJywgZmFkZVRvU2VsZWN0ZWRTbmFwSW5zdGFudGx5KS5vZmYoJ3BvaW50ZXJEb3duJywgcG9pbnRlckRvd24pLm9mZigncG9pbnRlclVwJywgcG9pbnRlclVwKTtcbiAgICBlbWJsYUFwaS5zbGlkZU5vZGVzKCkuZm9yRWFjaChzbGlkZU5vZGUgPT4ge1xuICAgICAgY29uc3Qgc2xpZGVTdHlsZSA9IHNsaWRlTm9kZS5zdHlsZTtcbiAgICAgIHNsaWRlU3R5bGUub3BhY2l0eSA9ICcnO1xuICAgICAgc2xpZGVTdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICAgIHNsaWRlU3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgaWYgKCFzbGlkZU5vZGUuZ2V0QXR0cmlidXRlKCdzdHlsZScpKSBzbGlkZU5vZGUucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGZhZGVUb1NlbGVjdGVkU25hcEluc3RhbnRseSgpIHtcbiAgICBjb25zdCBzZWxlY3RlZFNuYXAgPSBlbWJsYUFwaS5zZWxlY3RlZFNjcm9sbFNuYXAoKTtcbiAgICBzZXRPcGFjaXRpZXMoc2VsZWN0ZWRTbmFwLCBmdWxsT3BhY2l0eSk7XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlclVwKCkge1xuICAgIHNob3VsZEZhZGVQYWlyID0gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlckRvd24oKSB7XG4gICAgc2hvdWxkRmFkZVBhaXIgPSBmYWxzZTtcbiAgICBkaXN0YW5jZUZyb21Qb2ludGVyRG93biA9IDA7XG4gICAgZmFkZVZlbG9jaXR5ID0gMDtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3QoKSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpLnNjcm9sbEJvZHkuZHVyYXRpb24oKTtcbiAgICBmYWRlVmVsb2NpdHkgPSBkdXJhdGlvbiA/IDAgOiBmdWxsT3BhY2l0eTtcbiAgICBzaG91bGRGYWRlUGFpciA9IHRydWU7XG4gICAgaWYgKCFkdXJhdGlvbikgZmFkZVRvU2VsZWN0ZWRTbmFwSW5zdGFudGx5KCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U2xpZGVUcmFuc2Zvcm0ocG9zaXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICBheGlzXG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgY29uc3QgdHJhbnNsYXRlQXhpcyA9IGF4aXMuc2Nyb2xsLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIGB0cmFuc2xhdGUke3RyYW5zbGF0ZUF4aXN9KCR7YXhpcy5kaXJlY3Rpb24ocG9zaXRpb24pfXB4KWA7XG4gIH1cbiAgZnVuY3Rpb24gZGlzYWJsZVNjcm9sbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0cmFuc2xhdGUsXG4gICAgICBzbGlkZUxvb3BlclxuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpO1xuICAgIHRyYW5zbGF0ZS5jbGVhcigpO1xuICAgIHRyYW5zbGF0ZS50b2dnbGVBY3RpdmUoZmFsc2UpO1xuICAgIHNsaWRlTG9vcGVyLmxvb3BQb2ludHMuZm9yRWFjaCgoe1xuICAgICAgdHJhbnNsYXRlXG4gICAgfSkgPT4ge1xuICAgICAgdHJhbnNsYXRlLmNsZWFyKCk7XG4gICAgICB0cmFuc2xhdGUudG9nZ2xlQWN0aXZlKGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBsb2NrRXhjZXNzaXZlU2Nyb2xsKGZhZGVJbmRleCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNjcm9sbFNuYXBzLFxuICAgICAgbG9jYXRpb24sXG4gICAgICB0YXJnZXRcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICBpZiAoIWlzTnVtYmVyKGZhZGVJbmRleCkgfHwgb3BhY2l0aWVzW2ZhZGVJbmRleF0gPCAwLjUpIHJldHVybjtcbiAgICBsb2NhdGlvbi5zZXQoc2Nyb2xsU25hcHNbZmFkZUluZGV4XSk7XG4gICAgdGFyZ2V0LnNldChsb2NhdGlvbik7XG4gIH1cbiAgZnVuY3Rpb24gc2V0T3BhY2l0aWVzKGZhZGVJbmRleCwgdmVsb2NpdHkpIHtcbiAgICBjb25zdCBzY3JvbGxTbmFwcyA9IGVtYmxhQXBpLnNjcm9sbFNuYXBMaXN0KCk7XG4gICAgc2Nyb2xsU25hcHMuZm9yRWFjaCgoXywgaW5kZXhBKSA9PiB7XG4gICAgICBjb25zdCBhYnNWZWxvY2l0eSA9IE1hdGguYWJzKHZlbG9jaXR5KTtcbiAgICAgIGNvbnN0IGN1cnJlbnRPcGFjaXR5ID0gb3BhY2l0aWVzW2luZGV4QV07XG4gICAgICBjb25zdCBpc0ZhZGVJbmRleCA9IGluZGV4QSA9PT0gZmFkZUluZGV4O1xuICAgICAgY29uc3QgbmV4dE9wYWNpdHkgPSBpc0ZhZGVJbmRleCA/IGN1cnJlbnRPcGFjaXR5ICsgYWJzVmVsb2NpdHkgOiBjdXJyZW50T3BhY2l0eSAtIGFic1ZlbG9jaXR5O1xuICAgICAgY29uc3QgY2xhbXBlZE9wYWNpdHkgPSBjbGFtcE51bWJlcihuZXh0T3BhY2l0eSwgbm9PcGFjaXR5LCBmdWxsT3BhY2l0eSk7XG4gICAgICBvcGFjaXRpZXNbaW5kZXhBXSA9IGNsYW1wZWRPcGFjaXR5O1xuICAgICAgY29uc3QgZmFkZVBhaXIgPSBpc0ZhZGVJbmRleCAmJiBzaG91bGRGYWRlUGFpcjtcbiAgICAgIGNvbnN0IGluZGV4QiA9IGVtYmxhQXBpLnByZXZpb3VzU2Nyb2xsU25hcCgpO1xuICAgICAgaWYgKGZhZGVQYWlyKSBvcGFjaXRpZXNbaW5kZXhCXSA9IDEgLSBjbGFtcGVkT3BhY2l0eTtcbiAgICAgIGlmIChpc0ZhZGVJbmRleCkgc2V0UHJvZ3Jlc3MoZmFkZUluZGV4LCBjbGFtcGVkT3BhY2l0eSk7XG4gICAgICBzZXRPcGFjaXR5KGluZGV4QSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0T3BhY2l0eShpbmRleCkge1xuICAgIGNvbnN0IHNsaWRlc0luU25hcCA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCkuc2xpZGVSZWdpc3RyeVtpbmRleF07XG4gICAgY29uc3Qge1xuICAgICAgc2Nyb2xsU25hcHMsXG4gICAgICBjb250YWluZXJSZWN0XG4gICAgfSA9IGVtYmxhQXBpLmludGVybmFsRW5naW5lKCk7XG4gICAgY29uc3Qgb3BhY2l0eSA9IG9wYWNpdGllc1tpbmRleF07XG4gICAgc2xpZGVzSW5TbmFwLmZvckVhY2goc2xpZGVJbmRleCA9PiB7XG4gICAgICBjb25zdCBzbGlkZVN0eWxlID0gZW1ibGFBcGkuc2xpZGVOb2RlcygpW3NsaWRlSW5kZXhdLnN0eWxlO1xuICAgICAgY29uc3Qgcm91bmRlZE9wYWNpdHkgPSBwYXJzZUZsb2F0KG9wYWNpdHkudG9GaXhlZCgyKSk7XG4gICAgICBjb25zdCBoYXNPcGFjaXR5ID0gcm91bmRlZE9wYWNpdHkgPiBub09wYWNpdHk7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGhhc09wYWNpdHkgPyBzY3JvbGxTbmFwc1tpbmRleF0gOiBjb250YWluZXJSZWN0LndpZHRoICsgMjtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGdldFNsaWRlVHJhbnNmb3JtKHBvc2l0aW9uKTtcbiAgICAgIGlmIChoYXNPcGFjaXR5KSBzbGlkZVN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgIHNsaWRlU3R5bGUub3BhY2l0eSA9IHJvdW5kZWRPcGFjaXR5LnRvU3RyaW5nKCk7XG4gICAgICBzbGlkZVN0eWxlLnBvaW50ZXJFdmVudHMgPSBvcGFjaXR5ID4gMC41ID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgICAgaWYgKCFoYXNPcGFjaXR5KSBzbGlkZVN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzZXRQcm9ncmVzcyhmYWRlSW5kZXgsIG9wYWNpdHkpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbmRleCxcbiAgICAgIGRyYWdIYW5kbGVyLFxuICAgICAgc2Nyb2xsU25hcHNcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICBjb25zdCBwb2ludGVyRG93biA9IGRyYWdIYW5kbGVyLnBvaW50ZXJEb3duKCk7XG4gICAgY29uc3Qgc25hcEZyYWN0aW9uID0gMSAvIChzY3JvbGxTbmFwcy5sZW5ndGggLSAxKTtcbiAgICBsZXQgaW5kZXhBID0gZmFkZUluZGV4O1xuICAgIGxldCBpbmRleEIgPSBwb2ludGVyRG93biA/IGVtYmxhQXBpLnNlbGVjdGVkU2Nyb2xsU25hcCgpIDogZW1ibGFBcGkucHJldmlvdXNTY3JvbGxTbmFwKCk7XG4gICAgaWYgKHBvaW50ZXJEb3duICYmIGluZGV4QSA9PT0gaW5kZXhCKSB7XG4gICAgICBjb25zdCByZXZlcnNlU2lnbiA9IE1hdGguc2lnbihkaXN0YW5jZUZyb21Qb2ludGVyRG93bikgKiAtMTtcbiAgICAgIGluZGV4QSA9IGluZGV4QjtcbiAgICAgIGluZGV4QiA9IGluZGV4LmNsb25lKCkuc2V0KGluZGV4QikuYWRkKHJldmVyc2VTaWduKS5nZXQoKTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFBvc2l0aW9uID0gaW5kZXhCICogc25hcEZyYWN0aW9uO1xuICAgIGNvbnN0IGRpZmZQb3NpdGlvbiA9IChpbmRleEEgLSBpbmRleEIpICogc25hcEZyYWN0aW9uO1xuICAgIHByb2dyZXNzID0gY3VycmVudFBvc2l0aW9uICsgZGlmZlBvc2l0aW9uICogb3BhY2l0eTtcbiAgfVxuICBmdW5jdGlvbiBnZXRGYWRlSW5kZXgoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZHJhZ0hhbmRsZXIsXG4gICAgICBpbmRleCxcbiAgICAgIHNjcm9sbEJvZHlcbiAgICB9ID0gZW1ibGFBcGkuaW50ZXJuYWxFbmdpbmUoKTtcbiAgICBjb25zdCBzZWxlY3RlZFNuYXAgPSBlbWJsYUFwaS5zZWxlY3RlZFNjcm9sbFNuYXAoKTtcbiAgICBpZiAoIWRyYWdIYW5kbGVyLnBvaW50ZXJEb3duKCkpIHJldHVybiBzZWxlY3RlZFNuYXA7XG4gICAgY29uc3QgZGlyZWN0aW9uU2lnbiA9IE1hdGguc2lnbihzY3JvbGxCb2R5LnZlbG9jaXR5KCkpO1xuICAgIGNvbnN0IGRpc3RhbmNlU2lnbiA9IE1hdGguc2lnbihkaXN0YW5jZUZyb21Qb2ludGVyRG93bik7XG4gICAgY29uc3QgbmV4dFNuYXAgPSBpbmRleC5jbG9uZSgpLnNldChzZWxlY3RlZFNuYXApLmFkZChkaXJlY3Rpb25TaWduICogLTEpLmdldCgpO1xuICAgIGlmICghZGlyZWN0aW9uU2lnbiB8fCAhZGlzdGFuY2VTaWduKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gZGlzdGFuY2VTaWduID09PSBkaXJlY3Rpb25TaWduID8gbmV4dFNuYXAgOiBzZWxlY3RlZFNuYXA7XG4gIH1cbiAgZnVuY3Rpb24gZmFkZShlbWJsYUFwaSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRyYWdIYW5kbGVyLFxuICAgICAgc2Nyb2xsQm9keVxuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpO1xuICAgIGNvbnN0IHBvaW50ZXJEb3duID0gZHJhZ0hhbmRsZXIucG9pbnRlckRvd24oKTtcbiAgICBjb25zdCB2ZWxvY2l0eSA9IHNjcm9sbEJvZHkudmVsb2NpdHkoKTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHNjcm9sbEJvZHkuZHVyYXRpb24oKTtcbiAgICBjb25zdCBmYWRlSW5kZXggPSBnZXRGYWRlSW5kZXgoKTtcbiAgICBjb25zdCBub0ZhZGVJbmRleCA9ICFpc051bWJlcihmYWRlSW5kZXgpO1xuICAgIGlmIChwb2ludGVyRG93bikge1xuICAgICAgaWYgKCF2ZWxvY2l0eSkgcmV0dXJuO1xuICAgICAgZGlzdGFuY2VGcm9tUG9pbnRlckRvd24gKz0gdmVsb2NpdHk7XG4gICAgICBmYWRlVmVsb2NpdHkgPSBNYXRoLmFicyh2ZWxvY2l0eSAvIGZhZGVUb05leHREaXN0YW5jZSk7XG4gICAgICBsb2NrRXhjZXNzaXZlU2Nyb2xsKGZhZGVJbmRleCk7XG4gICAgfVxuICAgIGlmICghcG9pbnRlckRvd24pIHtcbiAgICAgIGlmICghZHVyYXRpb24gfHwgbm9GYWRlSW5kZXgpIHJldHVybjtcbiAgICAgIGZhZGVWZWxvY2l0eSArPSAoZnVsbE9wYWNpdHkgLSBvcGFjaXRpZXNbZmFkZUluZGV4XSkgLyBkdXJhdGlvbjtcbiAgICAgIGZhZGVWZWxvY2l0eSAqPSBmYWRlRnJpY3Rpb247XG4gICAgfVxuICAgIGlmIChub0ZhZGVJbmRleCkgcmV0dXJuO1xuICAgIHNldE9wYWNpdGllcyhmYWRlSW5kZXgsIGZhZGVWZWxvY2l0eSk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0dGxlZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXQsXG4gICAgICBsb2NhdGlvblxuICAgIH0gPSBlbWJsYUFwaS5pbnRlcm5hbEVuZ2luZSgpO1xuICAgIGNvbnN0IGRpZmZUb1RhcmdldCA9IHRhcmdldC5nZXQoKSAtIGxvY2F0aW9uLmdldCgpO1xuICAgIGNvbnN0IG5vdFJlYWNoZWRUYXJnZXQgPSBNYXRoLmFicyhkaWZmVG9UYXJnZXQpID49IDE7XG4gICAgY29uc3QgZmFkZUluZGV4ID0gZ2V0RmFkZUluZGV4KCk7XG4gICAgY29uc3Qgbm9GYWRlSW5kZXggPSAhaXNOdW1iZXIoZmFkZUluZGV4KTtcbiAgICBmYWRlKGVtYmxhQXBpKTtcbiAgICBpZiAobm9GYWRlSW5kZXggfHwgbm90UmVhY2hlZFRhcmdldCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBvcGFjaXRpZXNbZmFkZUluZGV4XSA+IDAuOTk5O1xuICB9XG4gIGZ1bmN0aW9uIHNjcm9sbFByb2dyZXNzKCkge1xuICAgIHJldHVybiBwcm9ncmVzcztcbiAgfVxuICBjb25zdCBzZWxmID0ge1xuICAgIG5hbWU6ICdmYWRlJyxcbiAgICBvcHRpb25zOiB1c2VyT3B0aW9ucyxcbiAgICBpbml0LFxuICAgIGRlc3Ryb3lcbiAgfTtcbiAgcmV0dXJuIHNlbGY7XG59XG5GYWRlLmdsb2JhbE9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gRmFkZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtYmxhLWNhcm91c2VsLWZhZGUuY2pzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/embla-carousel-fade/cjs/embla-carousel-fade.cjs.js\n");

/***/ })

};
;